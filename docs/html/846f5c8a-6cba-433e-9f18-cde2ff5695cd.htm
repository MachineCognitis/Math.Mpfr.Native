<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-en-US.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Welcome to the MPFR Native Interface for .NET Library</title><meta name="Language" content="en-us" /><meta name="System.Keywords" content="Welcome" /><meta name="Microsoft.Help.Id" content="846f5c8a-6cba-433e-9f18-cde2ff5695cd" /><meta name="Description" content="The MPFR Native Interface for .NET Library exposes to .NET (through P-Invoke and .NET types) all of the functionality of the GNU MPFR Libraryhttps://mpfrlib.org/_self (version 6.1.2)." /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link rel="stylesheet" type="text/css" href="../styles/branding-Website.css" /><script type="text/javascript" src="../scripts/jquery-1.11.0.min.js"></script><script type="text/javascript" src="../scripts/branding-Website.js"></script><script type="text/javascript" src="../scripts/clipboard.min.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="pageHeader" id="PageHeader">MPFR Native Interface for .NET<form id="SearchForm" method="get" action="#" onsubmit="javascript:TransferToSearchPage(); return false;"><input id="SearchTextBox" type="text" maxlength="200" /><button id="SearchButton" type="submit"></button></form></div><div class="pageBody"><div class="leftNav" id="leftNav"><div id="tocNav"><div class="toclevel0" data-toclevel="0" data-childrenloaded="true"><a class="tocExpanded" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="846f5c8a-6cba-433e-9f18-cde2ff5695cd.htm" title="MPFR Native Interface for .NET" tocid="roottoc">MPFR Native Interface for .NET</a></div><div class="toclevel1 current" data-toclevel="1"><a data-tochassubtree="false" href="846f5c8a-6cba-433e-9f18-cde2ff5695cd.htm" title="Welcome to the MPFR Native Interface for .NET Library" tocid="846f5c8a-6cba-433e-9f18-cde2ff5695cd">Welcome to the MPFR Native Interface for .NET Library</a></div><div class="toclevel1" data-toclevel="1"><a class="tocCollapsed" onclick="javascript: Toggle(this);" href="#!" /><a data-tochassubtree="true" href="d4b41450-8301-1af6-67c3-6d6f7e206516.htm" title="Math.Mpfr.Native" tocid="d4b41450-8301-1af6-67c3-6d6f7e206516">Math.Mpfr.Native</a></div></div><div id="tocResizableEW" onmousedown="OnMouseDown(event);"></div><div id="TocResize" class="tocResize"><img id="ResizeImageIncrease" src="../icons/TocOpen.gif" onclick="OnIncreaseToc()" alt="Click or drag to resize" title="Click or drag to resize" /><img id="ResizeImageReset" src="../icons/TocClose.gif" style="display:none" onclick="OnResetToc()" alt="Click or drag to resize" title="Click or drag to resize" /></div></div><div class="topicContent" id="TopicContent"><table class="titleTable"><tr><td class="titleColumn">Welcome to the MPFR Native Interface for .NET Library</td></tr></table><span class="introStyle"></span> <div class="introduction"><p>
        The <strong>MPFR Native Interface for .NET Library</strong> exposes to .NET (through P-Invoke and .NET types)
        all of the functionality of the
        <a href="https://mpfrlib.org/" target="_self">GNU MPFR Library</a>
        (version 6.1.2). It automatically loads at runtime the 32-bit or 64-bit GNU MPFR library that matches the current CPU
        architecture, thus allowing building Visual Studio Projects for Any CPU, x86, or x64.
        It is based on the GNU MPFR "fat" build which automatically detects the current CPU type, and selects any available
        assembly language code optimization for that CPU, thus providing best performance.
      </p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID0RB')" onkeypress="SectionExpandCollapse_CheckKey('ID0RB', event)" tabindex="0"><img id="ID0RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Overview</span></div><div id="ID0RBSection" class="collapsibleSection"><p>
          The <a href="6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm">mpfr_lib</a> class has a static
          method for each one of the GNU MPFR functions.
          Other types are defined to mimic struct's and typedef's of the GNU MPFR and C libraries, as well as C language
          constructs such as <span class="code">char *</span> and <span class="code">void *</span>.
        </p><p>
          The MPFR Native Interface for .NET Library relies on pre-built 32-bit and 64-bit versions of the GNU MPFR Library.
          Instructions for building the GNU MPFR Library on Windows are given below.
        </p><p>
          For convenience, this help file has been created from the GNU MPFR manual version 6.1.2. It shows with examples
          how each GNU MPFR function is called in .NET. For an introduction to GNU MPFR, refer to the
          <a href="https://mpfrlib.org/manual/" target="_self">GNU MPFR Manual</a>.
        </p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID1RB')" onkeypress="SectionExpandCollapse_CheckKey('ID1RB', event)" tabindex="0"><img id="ID1RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Functions Categories</span></div><div id="ID1RBSection" class="collapsibleSection"><ul><li><p><strong>Global Variable and Constants:</strong></p><ul class="noBullet"><li><p><span class="nolink">mpfr_errno</span> - Gets or sets the global MPFR error number.<br /><span class="nolink">mpfr_version</span> - The MPFR version number in the form “i.j.k”. This release is "6.1.2".<br /><span class="nolink">mp_bits_per_limb</span> - The number of bits per limb.<br /><span class="nolink">mp_bytes_per_limb</span> - The number of bytes per limb.<br /><span class="nolink">mp_uint_per_limb</span> - The number of 32-bit, unsigned integers per limb.<br /></p></li></ul></li><li><p><strong>Integer Functions:</strong></p><ul><li><p>
                  Initializing Integers:
                </p><p><span class="nolink">mpz_init(mpz_t)</span> - Initialize <em>x</em>, and set its value to 0.<br /><span class="nolink">mpz_inits(<span id="LST8E3C38F5_0"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_0?cpp=array&lt;");</script>mpz_t<span id="LST8E3C38F5_1"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_1?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Initialize a NULL-terminated list of <span class="nolink">mpz_t</span> variables, and set their values to 0.<br /><span class="nolink">mpz_init2(mpz_t, mp_bitcnt_t)</span> - Initialize <em>x</em>, with space for <em>n</em>-bit numbers, and set its value to 0.<br /><span class="nolink">mpz_clear(mpz_t)</span> - Free the space occupied by <em>x</em>.<br /><span class="nolink">mpz_clears(<span id="LST8E3C38F5_2"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_2?cpp=array&lt;");</script>mpz_t<span id="LST8E3C38F5_3"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_3?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Free the space occupied by a NULL-terminated list of <span class="nolink">mpz_t</span> variables.<br /><span class="nolink">mpz_realloc2(mpz_t, mp_bitcnt_t)</span> - Change the space allocated for <em>x</em> to <em>n</em> bits.<br /></p></li><li><p>
                  Assigning Integers:
                </p><p><span class="nolink">mpz_set(mpz_t, mpz_t)</span> - Set the value of <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpz_set_ui(mpz_t, UInt32)</span> - Set the value of <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpz_set_si(mpz_t, Int32)</span> - Set the value of <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpz_set_d(mpz_t, Double)</span> - Set the value of <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpz_set_q(mpz_t, mpq_t)</span> - Set the value of <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpz_set_f(mpz_t, mpf_t)</span> - Set the value of <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpz_set_str(mpz_t, char_ptr, Int32)</span> - Set the value of <em>rop</em> from <em>str</em>, a null-terminated C string in base <em>base</em>.<br /><span class="nolink">mpz_swap(mpz_t, mpz_t)</span> - Swap the values <em>rop1</em> and <em>rop2</em> efficiently.<br /></p></li><li><p>
                  Simultaneous Integer Init &amp; Assign:
                </p><p><span class="nolink">mpz_init_set(mpz_t, mpz_t)</span> - Initialize <em>rop</em> with limb space and set the initial numeric value from <em>op</em>.<br /><span class="nolink">mpz_init_set_ui(mpz_t, UInt32)</span> - Initialize <em>rop</em> with limb space and set the initial numeric value from <em>op</em>.<br /><span class="nolink">mpz_init_set_si(mpz_t, Int32)</span> - Initialize <em>rop</em> with limb space and set the initial numeric value from <em>op</em>.<br /><span class="nolink">mpz_init_set_d(mpz_t, Double)</span> - Initialize <em>rop</em> with limb space and set the initial numeric value from <em>op</em>.<br /><span class="nolink">mpz_init_set_str(mpz_t, char_ptr, Int32)</span> - Initialize <em>rop</em> and set its value like <span class="nolink">mpz_set_str(mpz_t, char_ptr, Int32)</span>.<br /></p></li><li><p>
                  Converting Integers:
                </p><p><span class="nolink">mpz_get_ui(mpz_t)</span> - Return the value of <em>op</em> as an unsigned long.<br /><span class="nolink">mpz_get_si(mpz_t)</span> - Return the value of <em>op</em> as an signed long.<br /><span class="nolink">mpz_get_d(mpz_t)</span> - Convert <em>op</em> to a double, truncating if necessary (i.e. rounding towards zero).<br /><span class="nolink">mpz_get_d_2exp(Int32<span id="LST8E3C38F5_4"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_4?cpp=%");</script>, mpz_t)</span> - Convert <em>op</em> to a double, truncating if necessary (i.e. rounding towards zero), and returning the exponent separately.<br /><span class="nolink">mpz_get_str(char_ptr, Int32, mpz_t)</span> - Convert <em>op</em> to a string of digits in base <em>base</em>.<br /></p></li><li><p>
                  Integer Arithmetic:
                </p><p><span class="nolink">mpz_add(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> + <em>op2</em>.<br /><span class="nolink">mpz_add_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> + <em>op2</em>.<br /><span class="nolink">mpz_sub(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> - <em>op2</em>.<br /><span class="nolink">mpz_sub_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> - <em>op2</em>.<br /><span class="nolink">mpz_ui_sub(mpz_t, UInt32, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> - <em>op2</em>.<br /><span class="nolink">mpz_mul(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_mul_si(mpz_t, mpz_t, Int32)</span> - Set <em>rop</em> to <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_mul_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_addmul(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>rop</em> + <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_addmul_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to <em>rop</em> + <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_submul(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>rop</em> - <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_submul_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to <em>rop</em> - <em>op1</em> * <em>op2</em>.<br /><span class="nolink">mpz_mul_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set <em>rop</em> to <em>op1</em> * 2^<em>op2</em>.<br /><span class="nolink">mpz_neg(mpz_t, mpz_t)</span> - Set <em>rop</em> to -<em>op</em>.<br /><span class="nolink">mpz_abs(mpz_t, mpz_t)</span> - Set <em>rop</em> to the absolute value of <em>op</em>.<br /></p></li><li><p>
                  Integer Division:
                </p><p><span class="nolink">mpz_cdiv_q(mpz_t, mpz_t, mpz_t)</span> - Set the quotient <em>q</em> to ceiling(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_cdiv_r(mpz_t, mpz_t, mpz_t)</span> - Set the remainder <em>r</em> to <em>n</em> - q * <em>d</em> where q = ceiling(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_cdiv_qr(mpz_t, mpz_t, mpz_t, mpz_t)</span> - Set the quotient <em>q</em> to ceiling(<em>n</em> / <em>d</em>), and set the remainder <em>r</em> to <em>n</em> - <em>q</em> * <em>d</em>.<br /><span class="nolink">mpz_cdiv_q_ui(mpz_t, mpz_t, UInt32)</span> - Set the quotient <em>q</em> to ceiling(<em>n</em> / <em>d</em>), and return the remainder r = | <em>n</em> - <em>q</em> * <em>d</em> |.<br /><span class="nolink">mpz_cdiv_r_ui(mpz_t, mpz_t, UInt32)</span> - Set the remainder <em>r</em> to <em>n</em> - q * <em>d</em> where q = ceiling(<em>n</em> / <em>d</em>), and return | <em>r</em> |.<br /><span class="nolink">mpz_cdiv_qr_ui(mpz_t, mpz_t, mpz_t, UInt32)</span> - Set quotient <em>q</em> to ceiling(<em>n</em> / <em>d</em>), set the remainder <em>r</em> to <em>n</em> - <em>q</em> * <em>d</em>, and return | <em>r</em> |.<br /><span class="nolink">mpz_cdiv_ui(mpz_t, UInt32)</span> - Return the remainder | r | where r = <em>n</em> - q * <em>d</em>, and where q = ceiling(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_cdiv_q_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set the quotient <em>q</em> to ceiling(<em>n</em> / 2^<em>b</em>).<br /><span class="nolink">mpz_cdiv_r_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set the remainder <em>r</em> to <em>n</em> - q * 2^<em>b</em> where q = ceiling(<em>n</em> / 2^<em>b</em>).<br /><span class="nolink">mpz_fdiv_q(mpz_t, mpz_t, mpz_t)</span> - Set the quotient <em>q</em> to floor(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_fdiv_r(mpz_t, mpz_t, mpz_t)</span> - Set the remainder <em>r</em> to <em>n</em> - q * <em>d</em> where q = floor(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_fdiv_qr(mpz_t, mpz_t, mpz_t, mpz_t)</span> - Set the quotient <em>q</em> to floor(<em>n</em> / <em>d</em>), and set the remainder <em>r</em> to <em>n</em> - <em>q</em> * <em>d</em>.<br /><span class="nolink">mpz_fdiv_q_ui(mpz_t, mpz_t, UInt32)</span> - Set the quotient <em>q</em> to floor(<em>n</em> / <em>d</em>), and return the remainder r = | <em>n</em> - <em>q</em> * <em>d</em> |.<br /><span class="nolink">mpz_fdiv_r_ui(mpz_t, mpz_t, UInt32)</span> - Set the remainder <em>r</em> to <em>n</em> - q * <em>d</em> where q = floor(<em>n</em> / <em>d</em>), and return | <em>r</em> |.<br /><span class="nolink">mpz_fdiv_qr_ui(mpz_t, mpz_t, mpz_t, UInt32)</span> - Set quotient <em>q</em> to floor(<em>n</em> / <em>d</em>), set the remainder <em>r</em> to <em>n</em> - <em>q</em> * <em>d</em>, and return | <em>r</em> |.<br /><span class="nolink">mpz_fdiv_ui(mpz_t, UInt32)</span> - Return the remainder | r | where r = <em>n</em> - q * <em>d</em>, and where q = floor(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_fdiv_q_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set the quotient <em>q</em> to floor(<em>n</em> / 2^<em>b</em>).<br /><span class="nolink">mpz_fdiv_r_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set the remainder <em>r</em> to <em>n</em> - q * 2^<em>b</em> where q = floor(<em>n</em> / 2^<em>b</em>).<br /><span class="nolink">mpz_tdiv_q(mpz_t, mpz_t, mpz_t)</span> - Set the quotient <em>q</em> to trunc(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_tdiv_r(mpz_t, mpz_t, mpz_t)</span> - Set the remainder <em>r</em> to <em>n</em> - q * <em>d</em> where q = trunc(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_tdiv_qr(mpz_t, mpz_t, mpz_t, mpz_t)</span> - Set the quotient <em>q</em> to trunc(<em>n</em> / <em>d</em>), and set the remainder <em>r</em> to <em>n</em> - <em>q</em> * <em>d</em>.<br /><span class="nolink">mpz_tdiv_q_ui(mpz_t, mpz_t, UInt32)</span> - Set the quotient <em>q</em> to trunc(<em>n</em> / <em>d</em>), and return the remainder r = | <em>n</em> - <em>q</em> * <em>d</em> |.<br /><span class="nolink">mpz_tdiv_r_ui(mpz_t, mpz_t, UInt32)</span> - Set the remainder <em>r</em> to <em>n</em> - q * <em>d</em> where q = trunc(<em>n</em> / <em>d</em>), and return | <em>r</em> |.<br /><span class="nolink">mpz_tdiv_qr_ui(mpz_t, mpz_t, mpz_t, UInt32)</span> - Set quotient <em>q</em> to trunc(<em>n</em> / <em>d</em>), set the remainder <em>r</em> to <em>n</em> - <em>q</em> * <em>d</em>, and return | <em>r</em> |.<br /><span class="nolink">mpz_tdiv_ui(mpz_t, UInt32)</span> - Return the remainder | r | where r = <em>n</em> - q * <em>d</em>, and where q = trunc(<em>n</em> / <em>d</em>).<br /><span class="nolink">mpz_tdiv_q_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set the quotient <em>q</em> to trunc(<em>n</em> / 2^<em>b</em>).<br /><span class="nolink">mpz_tdiv_r_2exp(mpz_t, mpz_t, mp_bitcnt_t)</span> - Set the remainder <em>r</em> to <em>n</em> - q * 2^<em>b</em> where q = trunc(<em>n</em> / 2^<em>b</em>).<br /><span class="nolink">mpz_mod(mpz_t, mpz_t, mpz_t)</span> - Set <em>r</em> to <em>n</em> mod <em>d</em>.<br /><span class="nolink">mpz_mod_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>r</em> to <em>n</em> mod <em>d</em>.<br /><span class="nolink">mpz_divexact(mpz_t, mpz_t, mpz_t)</span> - Set <em>q</em> to <em>n</em> / <em>d</em> when it is known in advance that <em>d</em> divides <em>n</em>. <br /><span class="nolink">mpz_divexact_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>q</em> to <em>n</em> / <em>d</em> when it is known in advance that <em>d</em> divides <em>n</em>. <br /><span class="nolink">mpz_divisible_p(mpz_t, mpz_t)</span> - Return non-zero if <em>n</em> is exactly divisible by <em>d</em>.<br /><span class="nolink">mpz_divisible_ui_p(mpz_t, UInt32)</span> - Return non-zero if <em>n</em> is exactly divisible by <em>d</em>.<br /><span class="nolink">mpz_divisible_2exp_p(mpz_t, mp_bitcnt_t)</span> - Return non-zero if <em>n</em> is exactly divisible by 2^<em>b</em>.<br /><span class="nolink">mpz_congruent_p(mpz_t, mpz_t, mpz_t)</span> - Return non-zero if <em>n</em> is congruent to <em>c</em> modulo <em>d</em>.<br /><span class="nolink">mpz_congruent_ui_p(mpz_t, UInt32, UInt32)</span> - Return non-zero if <em>n</em> is congruent to <em>c</em> modulo <em>d</em>.<br /><span class="nolink">mpz_congruent_2exp_p(mpz_t, mpz_t, mp_bitcnt_t)</span> - Return non-zero if <em>n</em> is congruent to <em>c</em> modulo 2^<em>b</em>.<br /></p></li><li><p>
                  Integer Exponentiation:
                </p><p><span class="nolink">mpz_powm(mpz_t, mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to (<em>base</em>^<em>exp</em>) modulo <em>mod</em>. <br /><span class="nolink">mpz_powm_ui(mpz_t, mpz_t, UInt32, mpz_t)</span> - Set <em>rop</em> to (<em>base</em>^<em>exp</em>) modulo <em>mod</em>. <br /><span class="nolink">mpz_powm_sec(mpz_t, mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to (<em>base</em>^<em>exp</em>) modulo <em>mod</em>.<br /><span class="nolink">mpz_pow_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to <em>base</em>^<em>exp</em>. The case 0^0 yields 1. <br /><span class="nolink">mpz_ui_pow_ui(mpz_t, UInt32, UInt32)</span> - Set <em>rop</em> to <em>base</em>^<em>exp</em>. The case 0^0 yields 1.<br /></p></li><li><p>
                  Integer Roots:
                </p><p><span class="nolink">mpz_root(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to the truncated integer part of the <em>n</em>th root of <em>op</em>.<br /><span class="nolink">mpz_rootrem(mpz_t, mpz_t, mpz_t, UInt32)</span> - Set <em>root</em> to the truncated integer part of the <em>n</em>th root of <em>u</em>. Set <em>rem</em> to the remainder, <em>u</em> - <em>root</em>^<em>n</em>. <br /><span class="nolink">mpz_sqrt(mpz_t, mpz_t)</span> - Set <em>rop</em> to the truncated integer part of the square root of <em>op</em>.<br /><span class="nolink">mpz_sqrtrem(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop1</em> to the truncated integer part of the square root of <em>op</em>, like <span class="nolink">mpz_sqrt(mpz_t, mpz_t)</span>. Set <em>rop2</em> to the remainder <em>op</em> - <em>rop1</em> * <em>rop1</em>, which will be zero if <em>op</em> is a perfect square.<br /><span class="nolink">mpz_perfect_power_p(mpz_t)</span> - Return non-zero if <em>op</em> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <em>op</em> = a^b. <br /><span class="nolink">mpz_perfect_square_p(mpz_t)</span> - Return non-zero if <em>op</em> is a perfect square, i.e., if the square root of <em>op</em> is an integer.<br /></p></li><li><p>
                  Number Theoretic Functions:
                </p><p><span class="nolink">mpz_probab_prime_p(mpz_t, Int32)</span> - Determine whether <em>n</em> is prime.<br /><span class="nolink">mpz_nextprime(mpz_t, mpz_t)</span> - Set <em>rop</em> to the next prime greater than <em>op</em>.<br /><span class="nolink">mpz_gcd(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to the greatest common divisor of <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_gcd_ui(mpz_t, mpz_t, UInt32)</span> - Compute the greatest common divisor of <em>op1</em> and <em>op2</em>. If <em>rop</em> is not null, store the result there. <br /><span class="nolink">mpz_gcdext(mpz_t, mpz_t, mpz_t, mpz_t, mpz_t)</span> - Set <em>g</em> to the greatest common divisor of <em>a</em> and <em>b</em>, and in addition set <em>s</em> and <em>t</em> to coefficients satisfying <em>a</em> * <em>s</em> + <em>b</em> * <em>t</em> = <em>g</em>.<br /><span class="nolink">mpz_lcm(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to the least common multiple of <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_lcm_ui(mpz_t, mpz_t, UInt32)</span> - Set <em>rop</em> to the least common multiple of <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_invert(mpz_t, mpz_t, mpz_t)</span> - Compute the inverse of <em>op1</em> modulo <em>op2</em> and put the result in <em>rop</em>.<br /><span class="nolink">mpz_jacobi(mpz_t, mpz_t)</span> - Calculate the Jacobi symbol (<em>a</em>/<em>b</em>).<br /><span class="nolink">mpz_legendre(mpz_t, mpz_t)</span> - Calculate the Legendre symbol (<em>a</em>/<em>p</em>).<br /><span class="nolink">mpz_kronecker(mpz_t, mpz_t)</span> - Calculate the Jacobi symbol (<em>a</em>/<em>b</em>) with the Kronecker extension (<em>a</em>/2) = (2/<em>a</em>) when <em>a</em> odd, or (<em>a</em>/2) = 0 when <em>a</em> even. <br /><span class="nolink">mpz_kronecker_si(mpz_t, Int32)</span> - Calculate the Jacobi symbol (<em>a</em>/<em>b</em>) with the Kronecker extension (<em>a</em>/2) = (2/<em>a</em>) when <em>a</em> odd, or (<em>a</em>/2) = 0 when <em>a</em> even. <br /><span class="nolink">mpz_kronecker_ui(mpz_t, UInt32)</span> - Calculate the Jacobi symbol (<em>a</em>/<em>b</em>) with the Kronecker extension (<em>a</em>/2) = (2/<em>a</em>) when <em>a</em> odd, or (<em>a</em>/2) = 0 when <em>a</em> even. <br /><span class="nolink">mpz_si_kronecker(Int32, mpz_t)</span> - Calculate the Jacobi symbol (<em>a</em>/<em>b</em>) with the Kronecker extension (<em>a</em>/2) = (2/<em>a</em>) when <em>a</em> odd, or (<em>a</em>/2) = 0 when <em>a</em> even. <br /><span class="nolink">mpz_ui_kronecker(UInt32, mpz_t)</span> - Calculate the Jacobi symbol (<em>a</em>/<em>b</em>) with the Kronecker extension (<em>a</em>/2) = (2/<em>a</em>) when <em>a</em> odd, or (<em>a</em>/2) = 0 when <em>a</em> even. <br /><span class="nolink">mpz_remove(mpz_t, mpz_t, mpz_t)</span> - Remove all occurrences of the factor <em>f</em> from <em>op</em> and store the result in <em>rop</em>.<br /><span class="nolink">mpz_fac_ui(mpz_t, UInt32)</span> - Set <em>rop</em> to the factorial <em>n</em>!.<br /><span class="nolink">mpz_2fac_ui(mpz_t, UInt32)</span> - Set <em>rop</em> to the double-factorial <em>n</em>!!.<br /><span class="nolink">mpz_mfac_uiui(mpz_t, UInt32, UInt32)</span> - Set <em>rop</em> to the m-multi-factorial <em>n</em>!^(<em>m</em>)n.<br /><span class="nolink">mpz_primorial_ui(mpz_t, UInt32)</span> - Set <em>rop</em> to the primorial of <em>n</em>, i.e. the product of all positive prime numbers ≤ <em>n</em>. <br /><span class="nolink">mpz_bin_ui(mpz_t, mpz_t, UInt32)</span> - Compute the binomial coefficient <em>n</em> over <em>k</em> and store the result in <em>rop</em>.<br /><span class="nolink">mpz_bin_uiui(mpz_t, UInt32, UInt32)</span> - Compute the binomial coefficient <em>n</em> over <em>k</em> and store the result in <em>rop</em>.<br /><span class="nolink">mpz_fib_ui(mpz_t, UInt32)</span> - Sets <em>fn</em> to to F[<em>n</em>], the <em>n</em>’th Fibonacci number. <br /><span class="nolink">mpz_fib2_ui(mpz_t, mpz_t, UInt32)</span> - Sets <em>fn</em> to F[<em>n</em>], and <em>fnsub1</em> to F[<em>n</em> - 1]. <br /><span class="nolink">mpz_lucnum_ui(mpz_t, UInt32)</span> - Sets <em>ln</em> to to L[<em>n</em>], the <em>n</em>’th Lucas number. <br /><span class="nolink">mpz_lucnum2_ui(mpz_t, mpz_t, UInt32)</span> - Sets <em>ln</em> to L[<em>n</em>], and <em>lnsub1</em> to L[<em>n</em> - 1]. <br /><span class="nolink">mpz_millerrabin(mpz_t, Int32)</span> - An implementation of the probabilistic primality test found in Knuth's Seminumerical Algorithms book.<br /></p></li><li><p>
                  Integer Comparisons:
                </p><p><span class="nolink">mpz_cmp(mpz_t, mpz_t)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_cmp_d(mpz_t, Double)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_cmp_si(mpz_t, Int32)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_cmp_ui(mpz_t, UInt32)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_cmpabs(mpz_t, mpz_t)</span> - Compare the absolute values of <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_cmpabs_d(mpz_t, Double)</span> - Compare the absolute values of <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_cmpabs_ui(mpz_t, UInt32)</span> - Compare the absolute values of <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpz_sgn(mpz_t)</span> - Return +1 if <em>op</em> &gt; 0, 0 if <em>op</em> = 0, and -1 if <em>op</em> &lt; 0.<br /></p></li><li><p>
                  Integer Logic and Bit Fiddling:
                </p><p><span class="nolink">mpz_and(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> bitwise-and <em>op2</em>. <br /><span class="nolink">mpz_ior(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> bitwise inclusive-or <em>op2</em>. <br /><span class="nolink">mpz_xor(mpz_t, mpz_t, mpz_t)</span> - Set <em>rop</em> to <em>op1</em> bitwise exclusive-or <em>op2</em>. <br /><span class="nolink">mpz_com(mpz_t, mpz_t)</span> - Set <em>rop</em> to the one’s complement of <em>op</em>.<br /><span class="nolink">mpz_popcount(mpz_t)</span> - Return the population count of <em>op</em>.<br /><span class="nolink">mpz_hamdist(mpz_t, mpz_t)</span> - Return the hamming distance between the two operands.<br /><span class="nolink">mpz_scan0(mpz_t, mp_bitcnt_t)</span> - Scan <em>op</em> for 0 bit.<br /><span class="nolink">mpz_scan1(mpz_t, mp_bitcnt_t)</span> - Scan <em>op</em> for 1 bit.<br /><span class="nolink">mpz_setbit(mpz_t, mp_bitcnt_t)</span> - Set bit <em>bit_index</em> in <em>rop</em>.<br /><span class="nolink">mpz_clrbit(mpz_t, mp_bitcnt_t)</span> - Clear bit <em>bit_index</em> in <em>rop</em>.<br /><span class="nolink">mpz_combit(mpz_t, mp_bitcnt_t)</span> - Complement bit <em>bit_index</em> in <em>rop</em>. <br /><span class="nolink">mpz_tstbit(mpz_t, mp_bitcnt_t)</span> - Test bit <em>bit_index</em> in <em>op</em> and return 0 or 1 accordingly. <br /></p></li><li><p>
                  I/O of Integers:
                </p><p><span class="nolink">mpz_out_str(ptr<span id="LST8E3C38F5_5"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_5?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_6"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_6?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32, mpz_t)</span> - Output <em>op</em> on stdio stream <em>stream</em>, as a string of digits in base <em>base</em>.<br /><span class="nolink">mpz_inp_str(mpz_t, ptr<span id="LST8E3C38F5_7"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_7?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_8"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_8?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32)</span> - Input a possibly white-space preceded string in base <em>base</em> from stdio stream <em>stream</em>, and put the read integer in <em>rop</em>. <br /><span class="nolink">mpz_out_raw(ptr<span id="LST8E3C38F5_9"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_9?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_10"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_10?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, mpz_t)</span> - Output <em>op</em> on stdio stream <em>stream</em>, in raw binary format.<br /><span class="nolink">mpz_inp_raw(mpz_t, ptr<span id="LST8E3C38F5_11"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_11?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_12"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_12?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>)</span> - Input from stdio stream <em>stream</em> in the format written by <span class="nolink">mpz_out_raw(ptr<span id="LST8E3C38F5_13"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_13?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_14"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_14?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, mpz_t)</span>, and put the result in <em>rop</em>.<br /></p></li><li><p>
                  Integer Random Numbers:
                </p><p><span class="nolink">mpz_urandomb(mpz_t, mpfr_randstate_t, mp_bitcnt_t)</span> - Generate a uniformly distributed random integer in the range 0 to 2^<em>n</em> - 1, inclusive.<br /><span class="nolink">mpz_urandomm(mpz_t, mpfr_randstate_t, mpz_t)</span> - Generate a uniform random integer in the range 0 to <em>n</em> - 1, inclusive.<br /><span class="nolink">mpz_rrandomb(mpz_t, mpfr_randstate_t, mp_bitcnt_t)</span> - Generate a random integer with long strings of zeros and ones in the binary representation.<br /><span class="nolink">mpz_random(mpz_t, mp_size_t)</span> - Generate a random integer of at most <em>max_size</em> limbs.<br /><span class="nolink">mpz_random2(mpz_t, mp_size_t)</span> - Generate a random integer of at most <em>max_size</em> limbs, with long strings of zeros and ones in the binary representation.<br /></p></li><li><p>
                  Integer Import and Export:
                </p><p><span class="nolink">mpz_import(mpz_t, size_t, Int32, size_t, Int32, size_t, void_ptr)</span> - Set <em>rop</em> from an array of word data at <em>op</em>.<br /><span class="nolink">mpz_export(void_ptr, size_t<span id="LST8E3C38F5_15"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_15?cpp=%");</script>, Int32, size_t, Int32, size_t, mpz_t)</span> - Fill <em>rop</em> with word data from <em>op</em>.<br /></p></li><li><p>
                  Miscellaneous Integer Functions:
                </p><p><span class="nolink">mpz_fits_sint_p(mpz_t)</span> - Return non-zero iff the value of <em>op</em> fits in a signed 32-bit integer. Otherwise, return zero.<br /><span class="nolink">mpz_fits_slong_p(mpz_t)</span> - Return non-zero iff the value of <em>op</em> fits in a signed 32-bit integer. Otherwise, return zero.<br /><span class="nolink">mpz_fits_sshort_p(mpz_t)</span> - Return non-zero iff the value of <em>op</em> fits in a signed 16-bit integer. Otherwise, return zero.<br /><span class="nolink">mpz_fits_uint_p(mpz_t)</span> - Return non-zero iff the value of <em>op</em> fits in an unsigned 32-bit integer. Otherwise, return zero.<br /><span class="nolink">mpz_fits_ulong_p(mpz_t)</span> - Return non-zero iff the value of <em>op</em> fits in an unsigned 32-bit integer. Otherwise, return zero.<br /><span class="nolink">mpz_fits_ushort_p(mpz_t)</span> - Return non-zero iff the value of <em>op</em> fits in an unsigned 16-bit integer. Otherwise, return zero.<br /><span class="nolink">mpz_sizeinbase(mpz_t, Int32)</span> - Return the size of <em>op</em> measured in number of digits in the given <em>base</em>.<br /><span class="nolink">mpz_even_p(mpz_t)</span> - Determine whether <em>op</em> is even.<br /><span class="nolink">mpz_odd_p(mpz_t)</span> - Determine whether <em>op</em> is odd.<br /></p></li><li><p>
                  Integer Special Functions:
                </p><p><span class="nolink">_mpz_realloc(mpz_t, mp_size_t)</span> - Change the space for <em>integer</em> to <em>new_alloc</em> limbs.<br /><span class="nolink">mpz_getlimbn(mpz_t, mp_size_t)</span> - Return limb number <em>n</em> from <em>op</em>.<br /><span class="nolink">mpz_size(mpz_t)</span> - Return the size of <em>op</em> measured in number of limbs.<br /><span class="nolink">mpz_limbs_read(mpz_t)</span> - Return a pointer to the limb array representing the absolute value of <em>x</em>.<br /><span class="nolink">mpz_limbs_write(mpz_t, mp_size_t)</span> - Return a pointer to the limb array of <em>x</em>, intended for write access.<br /><span class="nolink">mpz_limbs_modify(mpz_t, mp_size_t)</span> - Return a pointer to the limb array of <em>x</em>, intended for write access.<br /><span class="nolink">mpz_limbs_finish(mpz_t, mp_size_t)</span> - Updates the internal size field of <em>x</em>.<br /><span class="nolink">mpz_roinit_n(mpz_t, mp_ptr, mp_size_t)</span> - Special initialization of <em>x</em>, using the given limb array and size.<br /></p></li></ul></li><li><p><strong>Rational Number Functions:</strong></p><ul><li><p>
                  Initializing Rationals:
                </p><p><span class="nolink">mpq_canonicalize(mpq_t)</span> - Remove any factors that are common to the numerator and denominator of <em>op</em>, and make the denominator positive.<br /><span class="nolink">mpq_init(mpq_t)</span> - Initialize <em>x</em> and set it to 0/1.<br /><span class="nolink">mpq_inits(<span id="LST8E3C38F5_16"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_16?cpp=array&lt;");</script>mpq_t<span id="LST8E3C38F5_17"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_17?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Initialize a NULL-terminated list of <span class="nolink">mpq_t</span> variables, and set their values to 0/1. <br /><span class="nolink">mpq_clear(mpq_t)</span> - Free the space occupied by <em>x</em>.<br /><span class="nolink">mpq_clears(<span id="LST8E3C38F5_18"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_18?cpp=array&lt;");</script>mpq_t<span id="LST8E3C38F5_19"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_19?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Free the space occupied by a NULL-terminated list of <span class="nolink">mpq_t</span> variables. <br /><span class="nolink">mpq_set(mpq_t, mpq_t)</span> - Assign <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpq_set_z(mpq_t, mpz_t)</span> - Assign <em>rop</em> from <em>op</em>.<br /><span class="nolink">mpq_set_ui(mpq_t, UInt32, UInt32)</span> - Set the value of <em>rop</em> to <em>op1</em> / <em>op2</em>.<br /><span class="nolink">mpq_set_si(mpq_t, Int32, UInt32)</span> - Set the value of <em>rop</em> to <em>op1</em> / <em>op2</em>.<br /><span class="nolink">mpq_set_str(mpq_t, char_ptr, Int32)</span> - Set <em>rop</em> from a null-terminated string <em>str</em> in the given <em>base</em>.<br /><span class="nolink">mpq_swap(mpq_t, mpq_t)</span> - Swap the values <em>rop1</em> and <em>rop2</em> efficiently. <br /></p></li><li><p>
                  Rational Conversions:
                </p><p><span class="nolink">mpq_get_d(mpq_t)</span> - Convert <em>op</em> to a <a href="http://msdn2.microsoft.com/en-us/library/643eft0t" target="_blank">Double</a>, truncating if necessary (i.e. rounding towards zero). <br /><span class="nolink">mpq_set_d(mpq_t, Double)</span> - Set <em>rop</em> to the value of <em>op</em>. There is no rounding, this conversion is exact. <br /><span class="nolink">mpq_set_f(mpq_t, mpf_t)</span> - Set <em>rop</em> to the value of <em>op</em>. There is no rounding, this conversion is exact. <br /><span class="nolink">mpq_get_str(char_ptr, Int32, mpq_t)</span> - Convert <em>op</em> to a string of digits in base <em>base</em>.<br /></p></li><li><p>
                  Rational Arithmetic:
                </p><p><span class="nolink">mpq_add(mpq_t, mpq_t, mpq_t)</span> - Set <em>sum</em> to <em>addend1</em> + <em>addend2</em>. <br /><span class="nolink">mpq_sub(mpq_t, mpq_t, mpq_t)</span> - Set <em>difference</em> to <em>minuend</em> - <em>subtrahend</em>.<br /><span class="nolink">mpq_mul(mpq_t, mpq_t, mpq_t)</span> - Set <em>product</em> to <em>multiplier</em> * <em>multiplicand</em>. <br /><span class="nolink">mpq_mul_2exp(mpq_t, mpq_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> * 2*<em>op2</em>.<br /><span class="nolink">mpq_div(mpq_t, mpq_t, mpq_t)</span> - Set <em>quotient</em> to <em>dividend</em> / <em>divisor</em>. <br /><span class="nolink">mpq_div_2exp(mpq_t, mpq_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> / 2^<em>op2</em>.<br /><span class="nolink">mpq_neg(mpq_t, mpq_t)</span> - Set <em>negated_operand</em> to -<em>operand</em>.<br /><span class="nolink">mpq_abs(mpq_t, mpq_t)</span> - Set <em>rop</em> to the absolute value of <em>op</em>.<br /><span class="nolink">mpq_inv(mpq_t, mpq_t)</span> - Set <em>inverted_number</em> to 1 / <em>number</em>.<br /></p></li><li><p>
                  Comparing Rationals:
                </p><p><span class="nolink">mpq_cmp(mpq_t, mpq_t)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpq_cmp_z(mpq_t, mpz_t)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpq_cmp_ui(mpq_t, UInt32, UInt32)</span> - Compare <em>op1</em> and <em>num2</em> / <em>den2</em>.<br /><span class="nolink">mpq_cmp_si(mpq_t, Int32, UInt32)</span> - Compare <em>op1</em> and <em>num2</em> / <em>den2</em>.<br /><span class="nolink">mpq_sgn(mpq_t)</span> - Return +1 if <em>op</em> &gt; 0, 0 if <em>op</em> = 0, and -1 if <em>op</em> &lt; 0. <br /><span class="nolink">mpq_equal(mpq_t, mpq_t)</span> - Return non-zero if <em>op1</em> and <em>op2</em> are equal, zero if they are non-equal. <br /></p></li><li><p>
                  Applying Integer Functions:
                </p><p><span class="nolink">mpq_numref(mpq_t)</span> - Return a reference to the numerator <em>op</em>.<br /><span class="nolink">mpq_denref(mpq_t)</span> - Return a reference to the denominator <em>op</em>.<br /><span class="nolink">mpq_get_num(mpz_t, mpq_t)</span> - Set <em>numerator</em> to the numerator of <em>rational</em>.<br /><span class="nolink">mpq_get_den(mpz_t, mpq_t)</span> - Set <em>denominator</em> to the denominator of <em>rational</em>.<br /><span class="nolink">mpq_set_num(mpq_t, mpz_t)</span> - Set the numerator of <em>rational</em> to <em>numerator</em>.<br /><span class="nolink">mpq_set_den(mpq_t, mpz_t)</span> - Set the denominator of <em>rational</em> to <em>denominator</em>.<br /></p></li><li><p>
                  I/O of Rationals:
                </p><p><span class="nolink">mpq_out_str(ptr<span id="LST8E3C38F5_20"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_20?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_21"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_21?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32, mpq_t)</span> - Output <em>op</em> on stdio stream <em>stream</em>, as a string of digits in base <em>base</em>.<br /><span class="nolink">mpq_inp_str(mpq_t, ptr<span id="LST8E3C38F5_22"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_22?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_23"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_23?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32)</span> - Read a string of digits from <em>stream</em> and convert them to a rational in <em>rop</em>.<br /></p></li></ul></li><li><p><strong>Floating-point Functions:</strong></p><ul><li><p>
                  Initializing Floats:
                </p><p><span class="nolink">mpf_set_default_prec(mp_bitcnt_t)</span> - Set the default precision to be at least <em>prec</em> bits.<br /><span class="nolink">mpf_get_default_prec<span id="LST8E3C38F5_24"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_24?cs=()|vb=|cpp=()|nu=()|fs=()");</script></span> - Return the default precision actually used. <br /><span class="nolink">mpf_init(mpf_t)</span> - Initialize <em>x</em> to 0.<br /><span class="nolink">mpf_init2(mpf_t, mp_bitcnt_t)</span> - Initialize <em>x</em> to 0 and set its precision to be at least <em>prec</em> bits.<br /><span class="nolink">mpf_inits(<span id="LST8E3C38F5_25"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_25?cpp=array&lt;");</script>mpf_t<span id="LST8E3C38F5_26"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_26?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Initialize a NULL-terminated list of <span class="nolink">mpf_t</span> variables, and set their values to 0.<br /><span class="nolink">mpf_clear(mpf_t)</span> - Free the space occupied by <em>x</em>.<br /><span class="nolink">mpf_clears(<span id="LST8E3C38F5_27"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_27?cpp=array&lt;");</script>mpf_t<span id="LST8E3C38F5_28"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_28?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Free the space occupied by a NULL-terminated list of <span class="nolink">mpf_t</span> variables. <br /><span class="nolink">mpf_get_prec(mpf_t)</span> - Return the current precision of <em>op</em>, in bits. <br /><span class="nolink">mpf_set_prec(mpf_t, mp_bitcnt_t)</span> - Set the precision of <em>rop</em> to be at least <em>prec</em> bits.<br /><span class="nolink">mpf_set_prec_raw(mpf_t, mp_bitcnt_t)</span> - Set the precision of <em>rop</em> to be at least <em>prec</em> bits, without changing the memory allocated. <br /><span class="nolink">mpf_size(mpf_t)</span> - Return the number of limbs currently in use.<br /></p></li><li><p>
                  Assigning Floats:
                </p><p><span class="nolink">mpf_set(mpf_t, mpf_t)</span> - Set the value of <em>rop</em> from <em>op</em>. <br /><span class="nolink">mpf_set_ui(mpf_t, UInt32)</span> - Set the value of <em>rop</em> from <em>op</em>. <br /><span class="nolink">mpf_set_si(mpf_t, Int32)</span> - Set the value of <em>rop</em> from <em>op</em>. <br /><span class="nolink">mpf_set_d(mpf_t, Double)</span> - Set the value of <em>rop</em> from <em>op</em>. <br /><span class="nolink">mpf_set_z(mpf_t, mpz_t)</span> - Set the value of <em>rop</em> from <em>op</em>. <br /><span class="nolink">mpf_set_q(mpf_t, mpq_t)</span> - Set the value of <em>rop</em> from <em>op</em>. <br /><span class="nolink">mpf_set_str(mpf_t, char_ptr, Int32)</span> - Set the value of <em>rop</em> from the string in <em>str</em>.<br /><span class="nolink">mpf_swap(mpf_t, mpf_t)</span> - Swap <em>rop1</em> and <em>rop2</em> efficiently. <br /></p></li><li><p>
                  Simultaneous Float Init &amp; Assign:
                </p><p><span class="nolink">mpf_init_set(mpf_t, mpf_t)</span> - Initialize <em>rop</em> and set its value from <em>op</em>.<br /><span class="nolink">mpf_init_set_ui(mpf_t, UInt32)</span> - Initialize <em>rop</em> and set its value from <em>op</em>.<br /><span class="nolink">mpf_init_set_si(mpf_t, Int32)</span> - Initialize <em>rop</em> and set its value from <em>op</em>.<br /><span class="nolink">mpf_init_set_d(mpf_t, Double)</span> - Initialize <em>rop</em> and set its value from <em>op</em>.<br /><span class="nolink">mpf_init_set_str(mpf_t, char_ptr, Int32)</span> - Initialize <em>rop</em> and set its value from the string in <em>str</em>.<br /></p></li><li><p>
                  Converting Floats:
                </p><p><span class="nolink">mpf_get_d(mpf_t)</span> - Convert <em>op</em> to a <a href="http://msdn2.microsoft.com/en-us/library/643eft0t" target="_blank">Double</a>, truncating if necessary (i.e. rounding towards zero). <br /><span class="nolink">mpf_get_d_2exp(ptr<span id="LST8E3C38F5_29"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_29?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>Int32<span id="LST8E3C38F5_30"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_30?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, mpf_t)</span> - Convert op to a double, truncating if necessary (i.e. rounding towards zero), and with an exponent returned separately. <br /><span class="nolink">mpf_get_si(mpf_t)</span> - Convert <em>op</em> to a 32-bit integer, truncating any fraction part.<br /><span class="nolink">mpf_get_ui(mpf_t)</span> - Convert <em>op</em> to an unsigned 32-bit integer, truncating any fraction part.<br /><span class="nolink">mpf_get_str(char_ptr, ptr<span id="LST8E3C38F5_31"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_31?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>mp_exp_t<span id="LST8E3C38F5_32"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_32?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32, size_t, mpf_t)</span> - Convert <em>op</em> to a string of digits in base <em>base</em>.<br /></p></li><li><p>
                  Float Arithmetic:
                </p><p><span class="nolink">mpf_add(mpf_t, mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op1</em> + <em>op2</em>.<br /><span class="nolink">mpf_add_ui(mpf_t, mpf_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> + <em>op2</em>.<br /><span class="nolink">mpf_sub(mpf_t, mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op1</em> - <em>op2</em>.<br /><span class="nolink">mpf_ui_sub(mpf_t, UInt32, mpf_t)</span> - Set <em>rop</em> to <em>op1</em> - <em>op2</em>.<br /><span class="nolink">mpf_sub_ui(mpf_t, mpf_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> - <em>op2</em>.<br /><span class="nolink">mpf_mul(mpf_t, mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op1</em> * <em>op2</em>. <br /><span class="nolink">mpf_mul_ui(mpf_t, mpf_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> * <em>op2</em>. <br /><span class="nolink">mpf_div(mpf_t, mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op1</em> / <em>op2</em>. <br /><span class="nolink">mpf_ui_div(mpf_t, UInt32, mpf_t)</span> - Set <em>rop</em> to <em>op1</em> / <em>op2</em>. <br /><span class="nolink">mpf_div_ui(mpf_t, mpf_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> / <em>op2</em>. <br /><span class="nolink">mpf_sqrt(mpf_t, mpf_t)</span> - Set <em>rop</em> to the square root of <em>op</em>. <br /><span class="nolink">mpf_sqrt_ui(mpf_t, UInt32)</span> - Set <em>rop</em> to the square root of <em>op</em>. <br /><span class="nolink">mpf_pow_ui(mpf_t, mpf_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em>^<em>op2</em>.<br /><span class="nolink">mpf_neg(mpf_t, mpf_t)</span> - Set <em>rop</em> to -<em>op</em>. <br /><span class="nolink">mpf_abs(mpf_t, mpf_t)</span> - Set <em>rop</em> to | <em>op</em> |. <br /><span class="nolink">mpf_mul_2exp(mpf_t, mpf_t, mp_bitcnt_t)</span> - Set <em>rop</em> to <em>op1</em> * 2^<em>op2</em>. <br /><span class="nolink">mpf_div_2exp(mpf_t, mpf_t, UInt32)</span> - Set <em>rop</em> to <em>op1</em> / 2^<em>op2</em>. <br /></p></li><li><p>
                  Float Comparison:
                </p><p><span class="nolink">mpf_cmp(mpf_t, mpf_t)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpf_cmp_z(mpf_t, mpz_t)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpf_cmp_d(mpf_t, Double)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpf_cmp_ui(mpf_t, UInt32)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpf_cmp_si(mpf_t, Int32)</span> - Compare <em>op1</em> and <em>op2</em>.<br /><span class="nolink">mpf_reldiff(mpf_t, mpf_t, mpf_t)</span> - Compute the relative difference between <em>op1</em> and <em>op2</em> and store the result in <em>rop</em>. This is | <em>op1</em> - <em>op2</em> | / <em>op1</em>. <br /><span class="nolink">mpf_sgn(mpf_t)</span> - Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0. <br /></p></li><li><p>
                  I/O of Floats:
                </p><p><span class="nolink">mpf_out_str(ptr<span id="LST8E3C38F5_33"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_33?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_34"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_34?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32, size_t, mpf_t)</span> - Print <em>op</em> to <em>stream</em>, as a string of digits.<br /><span class="nolink">mpf_inp_str(mpf_t, ptr<span id="LST8E3C38F5_35"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_35?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_36"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_36?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, Int32)</span> - Read a string in base <em>base</em> from <em>stream</em>, and put the read float in <em>rop</em>.<br /></p></li><li><p>
                  Miscellaneous Float Functions:
                </p><p><span class="nolink">mpf_ceil(mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op</em> rounded to the next higher integer. <br /><span class="nolink">mpf_floor(mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op</em> rounded to the next lower integer.<br /><span class="nolink">mpf_trunc(mpf_t, mpf_t)</span> - Set <em>rop</em> to <em>op</em> rounded to the integer towards zero. <br /><span class="nolink">mpf_integer_p(mpf_t)</span> - Return non-zero if <em>op</em> is an integer.<br /><span class="nolink">mpf_fits_ulong_p(mpf_t)</span> - Return non-zero if <em>op</em> fits in an unsigned 32-bit integer, when truncated to an integer. <br /><span class="nolink">mpf_fits_slong_p(mpf_t)</span> - Return non-zero if <em>op</em> fits in a 32-bit integer, when truncated to an integer. <br /><span class="nolink">mpf_fits_uint_p(mpf_t)</span> - Return non-zero if <em>op</em> fits in an unsigned 32-bit integer, when truncated to an integer. <br /><span class="nolink">mpf_fits_sint_p(mpf_t)</span> - Return non-zero if <em>op</em> fits in a 32-bit integer, when truncated to an integer. <br /><span class="nolink">mpf_fits_sshort_p(mpf_t)</span> - Return non-zero if <em>op</em> fits in a 16-bit integer, when truncated to an integer. <br /><span class="nolink">mpf_fits_ushort_p(mpf_t)</span> - Return non-zero if <em>op</em> fits in an unsigned 16-bit integer, when truncated to an integer. <br /><span class="nolink">mpf_urandomb(mpf_t, mpfr_randstate_t, mp_bitcnt_t)</span> - Generate a uniformly distributed random float in <em>rop</em>, such that 0 ≤ rop &lt; 1, with <em>nbits</em> significant bits in the mantissa or less if the precision of <em>rop</em> is smaller.<br /><span class="nolink">mpf_random2(mpf_t, mp_size_t, mp_exp_t)</span> - Generate a random float of at most <em>max_size</em> limbs, with long strings of zeros and ones in the binary representation.<br /></p></li></ul></li><li><p><strong>Low-level Functions:</strong></p><ul><li><p><span class="nolink">mpn_add_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Add {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the <em>n</em> least significant limbs of the result to <em>rp</em>. <br /><span class="nolink">mpn_add_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Add {<em>s1p</em>, <em>n</em>} and <em>s2limb</em>, and write the <em>n</em> least significant limbs of the result to <em>rp</em>.<br /><span class="nolink">mpn_add(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)</span> - Add {<em>s1p</em>, <em>s1n</em>} and {<em>s2p</em>, <em>s2n</em>}, and write the <em>s1n</em> least significant limbs of the result to <em>rp</em>. <br /><span class="nolink">mpn_sub_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Subtract {<em>s2p</em>, <em>n</em>} from {<em>s1p</em>, <em>n</em>}, and write the <em>n</em> least significant limbs of the result to <em>rp</em>.<br /><span class="nolink">mpn_sub_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Subtract <em>s2limb</em> from {<em>s1p</em>, <em>n</em>}, and write the <em>n</em> least significant limbs of the result to <em>rp</em>.<br /><span class="nolink">mpn_sub(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)</span> - Subtract {<em>s2p</em>, <em>s2n</em>} from {<em>s1p</em>, <em>s1n</em>}, and write the <em>s1n</em> least significant limbs of the result to <em>rp</em>.<br /><span class="nolink">mpn_neg(mp_ptr, mp_ptr, mp_size_t)</span> - Perform the negation of {<em>sp</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}.<br /><span class="nolink">mpn_mul_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Multiply {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the (2 * <em>n</em>)-limb result to <em>rp</em>.<br /><span class="nolink">mpn_mul(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)</span> - Multiply {<em>s1p</em>, <em>s1n</em>} and {<em>s2p</em>, <em>s2n</em>}, and write the (<em>s1n</em> + <em>s2n</em>)-limb result to <em>rp</em>.<br /><span class="nolink">mpn_sqr(mp_ptr, mp_ptr, mp_size_t)</span> - Compute the square of {<em>s1p</em>, <em>n</em>} and write the (2 * <em>n</em>)-limb result to <em>rp</em>.<br /><span class="nolink">mpn_mul_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Multiply {<em>s1p</em>, <em>n</em>} by <em>s2limb</em>, and write the <em>n</em> least significant limbs of the product to <em>rp</em>.<br /><span class="nolink">mpn_addmul_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Multiply {<em>s1p</em>, <em>n</em>} and <em>s2limb</em>, and add the <em>n</em> least significant limbs of the product to {<em>rp</em>, <em>n</em>} and write the result to <em>rp</em>. <br /><span class="nolink">mpn_submul_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Multiply {<em>s1p</em>, <em>n</em>} and <em>s2limb</em>, and subtract the <em>n</em> least significant limbs of the product from {<em>rp</em>, <em>n</em>} and write the result to <em>rp</em>.<br /><span class="nolink">mpn_tdiv_qr(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr, mp_size_t)</span> - Divide {<em>np</em>, <em>nn</em>} by {<em>dp</em>, <em>dn</em>} and put the quotient at {<em>qp</em>, <em>nn</em> - <em>dn</em> + 1} and the remainder at {<em>rp</em>, <em>dn</em>}.<br /><span class="nolink">mpn_divrem_1(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_limb_t)</span> - Divide {<em>s2p</em>, <em>s2n</em>} by <em>s3limb</em>, and write the quotient at <em>r1p</em>.<br /><span class="nolink">mpn_divmod_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Divide {<em>s2p</em>, <em>s2n</em>} by <em>s3limb</em>, and write the quotient at <em>r1p</em>.<br /><span class="nolink">mpn_divexact_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Divide {<em>sp</em>, <em>n</em>} by <em>d</em>, expecting it to divide exactly, and writing the result to {r<em>rp</em>, <em>n</em>}.<br /><span class="nolink">mpn_divexact_by3(mp_ptr, mp_ptr, mp_size_t)</span> - Divide {<em>sp</em>, <em>n</em>} by 3, expecting it to divide exactly, and writing the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_divexact_by3c(mp_ptr, mp_ptr, mp_size_t, mp_limb_t)</span> - Divide {<em>sp</em>, <em>n</em>} by 3, expecting it to divide exactly, and writing the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_mod_1(mp_ptr, mp_size_t, mp_limb_t)</span> - Divide {<em>s1p</em>, <em>s1n</em>} by <em>s2limb</em>, and return the remainder. <br /><span class="nolink">mpn_lshift(mp_ptr, mp_ptr, mp_size_t, UInt32)</span> - Shift {<em>sp</em>, <em>n</em>} left by <em>count</em> bits, and write the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_rshift(mp_ptr, mp_ptr, mp_size_t, UInt32)</span> - Shift {<em>sp</em>, <em>n</em>} right by <em>count</em> bits, and write the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_cmp(mp_ptr, mp_ptr, mp_size_t)</span> - Compare {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}.<br /><span class="nolink">mpn_zero_p(mp_ptr, mp_size_t)</span> - Test {<em>sp</em>, <em>n</em>} and return 1 if the operand is zero, 0 otherwise.<br /><span class="nolink">mpn_gcd(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)</span> - Set {<em>rp</em>, retval} to the greatest common divisor of {<em>xp</em>, <em>xn</em>} and {<em>yp</em>, <em>yn</em>}.<br /><span class="nolink">mpn_gcd_1(mp_ptr, mp_size_t, mp_limb_t)</span> - Return the greatest common divisor of {<em>xp</em>, <em>xn</em>} and <em>ylimb</em>.<br /><span class="nolink">mpn_gcdext(mp_ptr, mp_ptr, ptr<span id="LST8E3C38F5_37"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_37?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>mp_size_t<span id="LST8E3C38F5_38"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_38?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, mp_ptr, mp_size_t, mp_ptr, mp_size_t)</span> - Compute the greatest common divisor G of U and V. Compute a cofactor S such that G = US + VT.<br /><span class="nolink">mpn_sqrtrem(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Compute the square root of {<em>sp</em>, <em>n</em>} and put the result at {<em>r1p</em>, ceil(<em>n</em> / 2)} and the remainder at {<em>r2p</em>, retval}.<br /><span class="nolink">mpn_sizeinbase(mp_ptr, mp_size_t, Int32)</span> - Return the size of {<em>xp</em>, <em>n</em>} measured in number of digits in the given <em>base</em>.<br /><span class="nolink">mpn_get_str(char_ptr, Int32, mp_ptr, mp_size_t)</span> - Convert {<em>s1p</em>, <em>s1n</em>} to a raw unsigned char array at <em>str</em> in base <em>base</em>, and return the number of characters produced.<br /><span class="nolink">mpn_set_str(mp_ptr, char_ptr, size_t, Int32)</span> - Convert bytes {<em>str</em>, <em>strsize</em>} in the given <em>base</em> to limbs at <em>rp</em>. <br /><span class="nolink">mpn_scan0(mp_ptr, mp_bitcnt_t)</span> - Scan <em>s1p</em> from bit position <em>bit</em> for the next clear bit.<br /><span class="nolink">mpn_scan1(mp_ptr, mp_bitcnt_t)</span> - Scan <em>s1p</em> from bit position <em>bit</em> for the next set bit.<br /><span class="nolink">mpn_random(mp_ptr, mp_size_t)</span> - Generate a random number of length <em>r1n</em> and store it at <em>r1p</em>.<br /><span class="nolink">mpn_random2(mp_ptr, mp_size_t)</span> - Generate a random number of length <em>r1n</em> and store it at <em>r1p</em>.<br /><span class="nolink">mpn_popcount(mp_ptr, mp_size_t)</span> - Count the number of set bits in {<em>s1p</em>, <em>n</em>}. <br /><span class="nolink">mpn_hamdist(mp_ptr, mp_ptr, mp_size_t)</span> - Compute the hamming distance between {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, which is the number of bit positions where the two operands have different bit values. <br /><span class="nolink">mpn_perfect_square_p(mp_ptr, mp_size_t)</span> - Return non-zero iff {<em>s1p</em>, <em>n</em>} is a perfect square.<br /><span class="nolink">mpn_perfect_power_p(mp_ptr, mp_size_t)</span> - Return non-zero iff {<em>sp</em>, <em>n</em>} is a perfect power.<br /><span class="nolink">mpn_and_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical and of {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_ior_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical inclusive or of {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_xor_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical exclusive or of {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_andn_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical and of {<em>s1p</em>, <em>n</em>} and the bitwise complement of {<em>s2p</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}.<br /><span class="nolink">mpn_iorn_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical inclusive or of {<em>s1p</em>, <em>n</em>} and the bitwise complement of {<em>s2p</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_nand_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical and of {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the bitwise complement of the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_nior_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical inclusive or of {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the bitwise complement of the result to {<em>rp</em>, <em>n</em>}.<br /><span class="nolink">mpn_xnor_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise logical exclusive or of {<em>s1p</em>, <em>n</em>} and {<em>s2p</em>, <em>n</em>}, and write the bitwise complement of the result to {<em>rp</em>, <em>n</em>}. <br /><span class="nolink">mpn_com(mp_ptr, mp_ptr, mp_size_t)</span> - Perform the bitwise complement of {<em>sp</em>, <em>n</em>}, and write the result to {<em>rp</em>, <em>n</em>}.<br /><span class="nolink">mpn_copyi(mp_ptr, mp_ptr, mp_size_t)</span> - Copy from {<em>s1p</em>, <em>n</em>} to {<em>rp</em>, <em>n</em>}, increasingly. <br /><span class="nolink">mpn_copyd(mp_ptr, mp_ptr, mp_size_t)</span> - Copy from {<em>s1p</em>, <em>n</em>} to {<em>rp</em>, <em>n</em>}, decreasingly. <br /><span class="nolink">mpn_zero(mp_ptr, mp_size_t)</span> - Zero {<em>rp</em>, <em>n</em>}.<br /></p></li><li><p>
                  Low-level functions for cryptography:
                </p><p><span class="nolink">mpn_cnd_add_n(mp_limb_t, mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - If <em>cnd</em> is non-zero, it produces the same result as a regular <span class="nolink">mpn_add_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span>, and if <em>cnd</em> is zero, it copies {<em>s1p</em>, <em>n</em>} to the result area and returns zero.<br /><span class="nolink">mpn_cnd_sub_n(mp_limb_t, mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span> - If <em>cnd</em> is non-zero, it produces the same result as a regular <span class="nolink">mpn_sub_n(mp_ptr, mp_ptr, mp_ptr, mp_size_t)</span>, and if <em>cnd</em> is zero, it copies {<em>s1p</em>, <em>n</em>} to the result area and returns zero.<br /><span class="nolink">mpn_sec_add_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t, mp_ptr)</span> - Set R to A + b, where R = {<em>rp</em>, <em>n</em>}, A = {<em>ap</em>, <em>n</em>}, and <em>b</em> is a single limb.<br /><span class="nolink">mpn_sec_add_1_itch(mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_add_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t, mp_ptr)</span>.<br /><span class="nolink">mpn_sec_sub_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t, mp_ptr)</span> - Set R to A - b, where R = {<em>rp</em>, <em>n</em>}, A = {<em>ap</em>, <em>n</em>}, and <em>b</em> is a single limb.<br /><span class="nolink">mpn_sec_sub_1_itch(mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_sub_1(mp_ptr, mp_ptr, mp_size_t, mp_limb_t, mp_ptr)</span>.<br /><span class="nolink">mpn_cnd_swap(mp_limb_t, mp_ptr, mp_ptr, mp_size_t)</span> - If <em>cnd</em> is non-zero, swaps the contents of the areas {<em>ap</em>, <em>n</em>} and {<em>bp</em>, <em>n</em>}. Otherwise, the areas are left unmodified.<br /><span class="nolink">mpn_sec_mul(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr)</span> - Set R to A * B, where A = {<em>ap</em>, <em>an</em>}, B = {<em>bp</em>, <em>bn</em>}, and R = {<em>rp</em>, <em>an</em> + <em>bn</em>}. <br /><span class="nolink">mpn_sec_mul_itch(mp_size_t, mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_mul(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr)</span>.<br /><span class="nolink">mpn_sec_sqr(mp_ptr, mp_ptr, mp_size_t, mp_ptr)</span> - Set R to A^2, where A = {<em>ap</em>, <em>an</em>}, and R = {<em>rp</em>, 2 * <em>an</em>}. <br /><span class="nolink">mpn_sec_sqr_itch(mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_sqr(mp_ptr, mp_ptr, mp_size_t, mp_ptr)</span>.<br /><span class="nolink">mpn_sec_powm(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_bitcnt_t, mp_ptr, mp_size_t, mp_ptr)</span> - Set R to (B^E) modulo M, where R = {<em>rp</em>, <em>n</em>}, M = {<em>mp</em>, <em>n</em>}, and E = {<em>ep</em>, ceil(<em>enb</em> / <span class="nolink">mp_bits_per_limb</span>)}. <br /><span class="nolink">mpn_sec_powm_itch(mp_size_t, mp_bitcnt_t, mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_powm(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_bitcnt_t, mp_ptr, mp_size_t, mp_ptr)</span>.<br /><span class="nolink">mpn_sec_tabselect(mp_ptr, mp_ptr, mp_size_t, mp_size_t, mp_size_t)</span> - Select entry <em>which</em> from table <em>tab</em>, which has <em>nents</em> entries, each <em>n</em> limbs. Store the selected entry at <em>rp</em>.<br /><span class="nolink">mpn_sec_div_qr(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr)</span> - Set Q to the truncated quotient N / D and R to N modulo D, where N = {<em>np</em>, <em>nn</em>}, D = {<em>dp</em>, <em>dn</em>}, Q’s most significant limb is the function return value and the remaining limbs are {<em>qp</em>, <em>nn</em> - <em>dn</em>}, and R = {<em>np</em>, <em>dn</em>}. <br /><span class="nolink">mpn_sec_div_qr_itch(mp_size_t, mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_div_qr(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr)</span>.<br /><span class="nolink">mpn_sec_div_r(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr)</span> - Set R to N modulo D, where N = {<em>np</em>, <em>nn</em>}, D = {<em>dp</em>, <em>dn</em>}, and R = {<em>np</em>, <em>dn</em>}. <br /><span class="nolink">mpn_sec_div_r_itch(mp_size_t, mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_div_r(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_ptr)</span>.<br /><span class="nolink">mpn_sec_invert(mp_ptr, mp_ptr, mp_ptr, mp_size_t, mp_bitcnt_t, mp_ptr)</span> - Set R to the inverse of A modulo M, where R = {<em>rp</em>, <em>n</em>}, A = {<em>ap</em>, <em>n</em>}, and M = {<em>mp</em>, <em>n</em>}. This function’s interface is preliminary. <br /><span class="nolink">mpn_sec_invert_itch(mp_size_t)</span> - Return the scratch space in number of limbs required by the function <span class="nolink">mpn_sec_invert(mp_ptr, mp_ptr, mp_ptr, mp_size_t, mp_bitcnt_t, mp_ptr)</span>.<br /></p></li></ul></li><li><p><strong>Random Number Functions:</strong></p><ul><li><p>
                  Random State Initialization:
                </p><p><span class="nolink">mpfr_randinit_default(mpfr_randstate_t)</span> - Initialize <em>state</em> with a default algorithm.<br /><span class="nolink">mpfr_randinit_mt(mpfr_randstate_t)</span> - Initialize <em>state</em> for a Mersenne Twister algorithm.<br /><span class="nolink">mpfr_randinit_lc_2exp(mpfr_randstate_t, mpz_t, UInt32, mp_bitcnt_t)</span> - Initialize <em>state</em> with a linear congruential algorithm X = (<em>a</em>X + <em>c</em>) mod 2^<em>m2exp</em>.<br /><span class="nolink">mpfr_randinit_lc_2exp_size(mpfr_randstate_t, mp_bitcnt_t)</span> - Initialize <em>state</em> for a linear congruential algorithm as per <span class="nolink">mpfr_randinit_lc_2exp(mpfr_randstate_t, mpz_t, UInt32, mp_bitcnt_t)</span>.<br /><span class="nolink">mpfr_randinit_set(mpfr_randstate_t, mpfr_randstate_t)</span> - Initialize <em>rop</em> with a copy of the algorithm and state from <em>op</em>.<br /><span class="nolink">mpfr_randclear(mpfr_randstate_t)</span> - Free all memory occupied by <em>state</em>.<br /></p></li><li><p>
                  Random State Seeding:
                </p><p><span class="nolink">mpfr_randseed(mpfr_randstate_t, mpz_t)</span> - Set an initial <em>seed</em> value into <em>state</em>.<br /><span class="nolink">mpfr_randseed_ui(mpfr_randstate_t, UInt32)</span> - Set an initial <em>seed</em> value into <em>state</em>.<br /></p></li><li><p>
                  Random State Miscellaneous:
                </p><p><span class="nolink">mpfr_urandomb_ui(mpfr_randstate_t, UInt32)</span> - Generate a uniformly distributed random number of <em>n</em> bits, i.e. in the range 0 to 2^<em>n</em> - 1 inclusive.<br /><span class="nolink">mpfr_urandomm_ui(mpfr_randstate_t, UInt32)</span> - Generate a uniformly distributed random number in the range 0 to <em>n</em> - 1, inclusive.<br /></p></li></ul></li><li><p><strong>Formatted Output:</strong></p><ul><li><p>
                  Formatted Output Functions:
                </p><p><a href="1464ba85-72de-fabc-68e3-9677dfbb9932.htm">mpfr_printf</a> - Print to the standard output stdout.<br /><a href="86b0ccc8-9cb2-d3d2-920c-ca50e8fbb68a.htm">mpfr_vprintf</a> - Print to the standard output stdout.<br /><span class="nolink">mpfr_fprintf(ptr<span id="LST8E3C38F5_39"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_39?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_40"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_40?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String, <span id="LST8E3C38F5_41"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_41?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_42"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_42?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Print to the stream <em>fp</em>.<br /><span class="nolink">mpfr_vfprintf(ptr<span id="LST8E3C38F5_43"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_43?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_44"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_44?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String, <span id="LST8E3C38F5_45"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_45?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_46"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_46?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Print to the stream <em>fp</em>.<br /><span class="nolink">mpfr_sprintf(char_ptr, String, <span id="LST8E3C38F5_47"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_47?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_48"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_48?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Form a null-terminated string in <em>buf</em>.<br /><span class="nolink">mpfr_vsprintf(char_ptr, String, <span id="LST8E3C38F5_49"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_49?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_50"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_50?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Form a null-terminated string in <em>buf</em>.<br /><span class="nolink">mpfr_snprintf(char_ptr, size_t, String, <span id="LST8E3C38F5_51"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_51?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_52"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_52?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Form a null-terminated string in <em>buf</em>.<br /><span class="nolink">mpfr_vsnprintf(char_ptr, size_t, String, <span id="LST8E3C38F5_53"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_53?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_54"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_54?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Form a null-terminated string in <em>buf</em>.<br /><span class="nolink">mpfr_asprintf(ptr<span id="LST8E3C38F5_55"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_55?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>char_ptr<span id="LST8E3C38F5_56"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_56?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String, <span id="LST8E3C38F5_57"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_57?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_58"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_58?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Form a null-terminated string in a block of memory obtained from the current memory allocation function.<br /><span class="nolink">mpfr_vasprintf(ptr<span id="LST8E3C38F5_59"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_59?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>char_ptr<span id="LST8E3C38F5_60"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_60?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String, <span id="LST8E3C38F5_61"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_61?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_62"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_62?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Form a null-terminated string in a block of memory obtained from the current memory allocation function.<br /></p></li></ul></li><li><p><strong>Formatted Input:</strong></p><ul><li><p>
                  Formatted Input Functions:
                </p><p><span class="nolink">mpfr_scanf(String, <span id="LST8E3C38F5_63"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_63?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_64"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_64?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Read from the standard input stdin.<br /><span class="nolink">mpfr_vscanf(String, <span id="LST8E3C38F5_65"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_65?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_66"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_66?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Read from the standard input stdin.<br /><span class="nolink">mpfr_fscanf(ptr<span id="LST8E3C38F5_67"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_67?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_68"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_68?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String, <span id="LST8E3C38F5_69"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_69?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_70"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_70?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Read from the stream fp.<br /><span class="nolink">mpfr_vfscanf(ptr<span id="LST8E3C38F5_71"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_71?cs=&lt;|vb=(Of |cpp=&lt;|fs=&lt;'|nu=(");</script>FILE<span id="LST8E3C38F5_72"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_72?cs=&gt;|vb=)|cpp=&gt;|fs=&gt;|nu=)");</script>, String, <span id="LST8E3C38F5_73"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_73?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_74"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_74?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Read from the stream fp.<br /><span class="nolink">mpfr_sscanf(String, String, <span id="LST8E3C38F5_75"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_75?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_76"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_76?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Read from a null-terminated string <em>s</em>.<br /><span class="nolink">mpfr_vsscanf(String, String, <span id="LST8E3C38F5_77"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_77?cpp=array&lt;");</script>Object<span id="LST8E3C38F5_78"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_78?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - Read from a null-terminated string <em>s</em>.<br /></p></li></ul></li><li><p><strong>Custom Allocation:</strong></p><ul><li><p><span class="nolink">mp_set_memory_functions(allocate_function, reallocate_function, free_function)</span> - Replace the current allocation functions from the arguments.<br /><span class="nolink">mp_get_memory_functions(allocate_function<span id="LST8E3C38F5_79"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_79?cpp=%");</script>, reallocate_function<span id="LST8E3C38F5_80"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_80?cpp=%");</script>, free_function<span id="LST8E3C38F5_81"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_81?cpp=%");</script>)</span> - Get the current allocation functions, storing function pointers to the locations given by the arguments.<br /><span class="nolink">allocate(size_t)</span> - Return a pointer to newly allocated space with at least <em>alloc_size</em> bytes.<br /><span class="nolink">reallocate(void_ptr, size_t, size_t)</span> - Resize a previously allocated block <em>ptr</em> of <em>old_size</em> bytes to be <em>new_size</em> bytes.<br /><span class="nolink">free(<span id="LST8E3C38F5_82"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_82?cpp=array&lt;");</script>mp_ptr<span id="LST8E3C38F5_83"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST8E3C38F5_83?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</span> - De-allocate the space pointed to by <em>ptrs</em>.<br /><span class="nolink">free(mpfr_randstate_t)</span> - De-allocate the space pointed to by <em>ptr</em>.<br /><span class="nolink">free(char_ptr)</span> - De-allocate the space pointed to by <em>ptr</em>.<br /><span class="nolink">free(void_ptr)</span> - De-allocate the space pointed to by <em>ptr</em>.<br /><span class="nolink">free(void_ptr, size_t)</span> - De-allocate the space pointed to by <em>ptr</em>.<br /><span class="nolink">ZeroMemory(IntPtr, Int32)</span> - The <span class="nolink">ZeroMemory(IntPtr, Int32)</span> routine fills a block of memory with zeros, given a pointer to the block and the length, in bytes, to be filled.<br /></p></li></ul></li></ul></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID2RB')" onkeypress="SectionExpandCollapse_CheckKey('ID2RB', event)" tabindex="0"><img id="ID2RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />C and .NET Types Equivalence</span></div><div id="ID2RBSection" class="collapsibleSection"><p>
          The table below shows how each C type maps to .NET.
          Note that the <span class="nolink">mp_limb_t</span>
          and <span class="nolink">size_t</span> C types map
          to the CPU word, i.e., 32 or 64 bits.
          In particular, because <span class="nolink">mp_limb_t</span>
          is the type of the integers that make up multi-precision numbers, matching the CPU word size ensures
          maximum performance.
          Unless you intend to use low-level (mpn) functions, you do not need to take into account the
          CPU word size, and can build for the "Any CPU" platform.
        </p><div class="tableSection"><table><tr><th><p>C Types</p></th><th><p>.NET Types</p></th></tr><tr><td><p>short</p></td><td><p>Int16</p></td></tr><tr><td><p>int</p></td><td><p>Int32</p></td></tr><tr><td><p>long</p></td><td><p>Int32</p></td></tr><tr><td><p>long long</p></td><td><p>Int64</p></td></tr><tr><td><p><span class="nolink">mp_bitcnt_t</span></p></td><td><p>UInt32</p></td></tr><tr><td><p><span class="nolink">mp_exp_t</span></p></td><td><p>Int32</p></td></tr><tr><td><p><span class="nolink">mp_size_t</span></p></td><td><p>Int32</p></td></tr><tr><td><p><span class="nolink">mp_limb_t</span></p></td><td><p>UInt32 (on 32-bit CPU) / UInt64 (on 64-bit CPU)</p></td></tr><tr><td><p><span class="nolink">size_t</span></p></td><td><p>UInt32 (on 32-bit CPU) / UInt64 (on 64-bit CPU)</p></td></tr></table></div></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID3RB')" onkeypress="SectionExpandCollapse_CheckKey('ID3RB', event)" tabindex="0"><img id="ID3RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Building the GNU MPFR Library on Windows</span></div><div id="ID3RBSection" class="collapsibleSection"><ol><li><p>
              Install <a href="https://github.com/msys2/msys2/wiki/MSYS2-introduction" target="_self">MSYS2</a>.              
            </p><p>
              On a 64-bit computer, install <a href="https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/" target="_self">msys2-x86_64-20161025.exe</a>,
              and on a 32-bit computer, install <a href="https://github.com/MachineCognitis/Math.Mpfr.Native/tree/master/Math.Mpfr.Native/Dependencies/" target="_self">msys2-i686-20161025.exe</a>.
              You can also check for a more recent version of MSYS2 <a href="https://github.com/msys2/msys2/wiki/MSYS2-installation" target="_blank">here</a>.
              Install MSYS2 to its default location.
            </p><p>
              After installation, you need to updates MSYS2 packages. From the Windows Start Menu, start <span class="command">MSYS2 MSYS</span>. In the shell command window,
              enter the command:
            </p><ul class="noBullet"><li><p><span class="input">pacman -Syuu</span></p></li></ul><p>
              and follow instructions.
              You will have to close the command window, reopen a new one, and reenter the command <span class="input">pacman -Syuu</span>.
            </p><p>
              Finally, in order to build software, you need to install a number of packages with the command:
            </p><ul class="noBullet"><li><p><span class="input">pacman -S --needed base-devel mingw-w64-i686-toolchain mingw-w64-x86_64-toolchain git subversion mercurial mingw-w64-i686-cmake mingw-w64-x86_64-cmake</span></p></li></ul><p>
              run from the same command window as in the previous step.
            </p><p>
              To build 32-bit software, use the <span class="command">MSYS2 MinGW 32-bit</span> command from the Windows Start Menu, and
              for 64-bit software, use <span class="command">MSYS2 MinGW 64-bit</span>.
            </p></li><li><p>
              Install <a href="http://yasm.tortall.net/Download.html" target="_self">yasm</a>.
            </p><p>
              On a 64-bit computer, copy <a href="https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/" target="_self">yasm-1.3.0-win64.exe</a>
              to <em>C:\msys64\usr\bin</em>, and rename it to <em>yasm.exe</em>.
            </p><p>
              Similarly on a 32-bit computer, copy <a href="https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/" target="_self">yasm-1.3.0-win32.exe</a>
              to <em>C:\msys32\usr\bin</em>, and rename it to <em>yasm.exe</em>.
            </p></li><li><p>
              Build <a href="https://mpfrlib.org/" target="_self">GNU MPFR</a>.
            </p><p>
              Create folders <em>C:\Temp\x86</em> and <em>C:\Temp\x64</em>.
              These are the folder where the compiled 32-bit and 64-bit versions of GNU MPFR will be installed.
              Unzip <a href="https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/" target="_self">mpfr-6.1.2.tar.bz2</a>
              in folder <em>C:\Temp</em>.
              This puts GNU MPFR in subfolder <em>mpfr-6.1.2</em>.
            </p><p>
              In each one of the command windows openend with the commands <span class="command">MSYS2 MinGW 32-bit</span>
              and <span class="command">MSYS2 MinGW 64-bit</span> from the Windows Start Menu, run the commands below:
            </p><ul class="noBullet"><li><p><span class="input">cd /c/Temp/mpfr-6.1.2</span><br /><span class="input">./configure --enable-fat --disable-static --enable-shared --prefix=/c/Temp/x86</span> or <span class="input">x64</span><br /><span class="input">make</span><br /><span class="input">make check</span><br /><span class="input">make install</span><br /></p></li></ul><p>
              The <span class="input">--prefix</span> specifies the install folder.
              Note that the Windows <em>C:\</em> drive is specified as the root <em>/C/</em> folder in the <span class="command">MinGW</span> window.
              Note also that the <span class="input">configure</span> and <span class="input">make</span> commands are to be run against a fresly uncompressed GNU MPFR source.
              The <span class="input">make install</span> command creates <em>libmpfr-4.dll</em> in the <em>C:\Temp\x86</em> and <em>C:\Temp\x64</em> folders.
              These two compiled versions of the GNU MPFR library are to be copied to the <em>x86</em> and <em>x64</em> folders of the <em>Math.Mpfr.Native</em> Visual Studio projects.
              They can also be copied directly into the <em>x86</em> and <em>x64</em> folders of the <em>bin/Debug</em> or <em>bin/Release</em> folders.
            </p><p>
              The 32-bit and 64-bit <span class="input">make check</span> commands generate some warnings, but all tests passed successfully.
            </p></li></ol></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID4RB')" onkeypress="SectionExpandCollapse_CheckKey('ID4RB', event)" tabindex="0"><img id="ID4RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Building the GNU MPFR Library for a Specific CPU Type on Windows</span></div><div id="ID4RBSection" class="collapsibleSection"><p>
          The <span class="input">--enable-fat</span> build option above creates a library where optimized low level subroutines are chosen at runtime according to the CPU detected.
          By using instead the <span class="input">--host</span> option, you can build a library for a specific CPU type.
          You will end up with a library that runs only on that CPU type, but the library will be samller.
          See the <a href="https://mpfrlib.org/manual/Build-Options.html#Build-Options/" target="_self">Build Options</a> from the GNU MPFR Manual for the supported CPU types.
        </p></div><div class="collapsibleAreaRegion"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID5RB')" onkeypress="SectionExpandCollapse_CheckKey('ID5RB', event)" tabindex="0"><img id="ID5RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />Using the GNU MPFR Library in a Visual Studio C++ Project</span></div><div id="ID5RBSection" class="collapsibleSection"><p>
          Although our main goal was to compile GNU MPFR in order to use it from .NET, the compiled 32-bit and 64-bit GNU MPFR libraries may be used directly in Visual Studio C++ projects.
          For example, create a default Visual Studio C++ Console Application.
          Set the <strong>Platform</strong> to <strong>x64</strong>.
          Copy from the <em>C:\Temp\x64</em> folder the files <em>include\mpfr.h</em>, <em>bin\libmpfr-4.dll</em>, and <em>lib\libmpfr.dll.a</em> to the Visual Studio C++ project folder.
          Include <em>mpfr.h</em> in your C++ source file.
          In the <strong>Linker</strong>, <strong>Input Property Page</strong> of the project, add <em>libmpfr.dll.a</em> to the <strong>Additional Dependencies</strong>.
          Build your C++ project, and copy <em>libmpfr-4.dll</em> to the output <em>bin</em> folder.
          Run your application.
        </p><p>
          See <a href="https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/" target="_self">ConsoleApplication12.zip</a>
          for a sample Visual Studio C++ project.
        </p></div><div class="collapsibleAreaRegion" id="seeAlsoSection"><span class="collapsibleRegionTitle" onclick="SectionExpandCollapse('ID6RB')" onkeypress="SectionExpandCollapse_CheckKey('ID6RB', event)" tabindex="0"><img id="ID6RBToggle" class="collapseToggle" src="../icons/SectionExpanded.png" />See Also</span></div><div id="ID6RBSection" class="collapsibleSection"><h4 class="subHeading">Other Resources</h4><div class="seeAlsoStyle"><a href="https://github.com/msys2/msys2/wiki/MSYS2-introduction" target="_self">MSYS2</a></div><div class="seeAlsoStyle"><a href="http://yasm.tortall.net/Download.html" target="_self">yasm</a></div><div class="seeAlsoStyle"><a href="https://mpfrlib.org/" target="_self">GNU MPFR</a></div><div class="seeAlsoStyle"><a href="https://github.com/MachineCognitis/Math.Mpfr.Native" target="_self">Math.Mpfr.Native on GitHub</a></div></div></div></div><div id="pageFooter" class="pageFooter" /></body></html>