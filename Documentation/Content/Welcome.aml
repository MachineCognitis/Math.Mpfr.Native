<?xml version="1.0" encoding="utf-8"?>
<topic id="846f5c8a-6cba-433e-9f18-cde2ff5695cd" revisionNumber="1">
	<developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
		
    <introduction>
      <para>
        The <legacyBold>MPFR Native Interface for .NET Library</legacyBold> exposes to .NET (through P-Invoke and .NET types)
        all of the functionality of the
        <externalLink>
          <linkText>GNU MPFR Library</linkText>
          <linkUri>https://mpfrlib.org/</linkUri>
          <linkTarget>_self</linkTarget>
        </externalLink>
        (version 6.1.2). It automatically loads at runtime the 32-bit or 64-bit GNU MPFR library that matches the current CPU
        architecture, thus allowing building Visual Studio Projects for Any CPU, x86, or x64.
        It is based on the GNU MPFR "fat" build which automatically detects the current CPU type, and selects any available
        assembly language code optimization for that CPU, thus providing best performance.
      </para>
 		</introduction>

    <section>
      <title>Overview</title>
      <content>
        <para>
          The <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpfr_lib</codeEntityReference> class has a static
          method for each one of the GNU MPFR functions.
          Other types are defined to mimic struct's and typedef's of the GNU MPFR and C libraries, as well as C language
          constructs such as <codeInline>char *</codeInline> and <codeInline>void *</codeInline>.
        </para>
        <para>
          The MPFR Native Interface for .NET Library relies on pre-built 32-bit and 64-bit versions of the GNU MPFR Library.
          Instructions for building the GNU MPFR Library on Windows are given below.
        </para>
        <para>
          For convenience, this help file has been created from the GNU MPFR manual version 6.1.2. It shows with examples
          how each GNU MPFR function is called in .NET. For an introduction to GNU MPFR, refer to the
          <externalLink>
            <linkText>GNU MPFR Manual</linkText>
            <linkUri>https://mpfrlib.org/manual/</linkUri>
            <linkTarget>_self</linkTarget>
          </externalLink>.
        </para>
      </content>
    </section>

    <section>
      <title>Functions Categories</title>
      <content>
        <list class="bullet">

          <listItem>
            <para>
              <legacyBold>Global Variable and Constants:</legacyBold>
            </para>
            <list class="nobullet">
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">P:Math.Mpfr.Native.mpfr_lib.mpfr_errno</codeEntityReference> - Gets or sets the global MPFR error number.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">F:Math.Mpfr.Native.mpfr_lib.mpfr_version</codeEntityReference> - The MPFR version number in the form “i.j.k”. This release is "6.1.2".<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">F:Math.Mpfr.Native.mpfr_lib.mp_bits_per_limb</codeEntityReference> - The number of bits per limb.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">F:Math.Mpfr.Native.mpfr_lib.mp_bytes_per_limb</codeEntityReference> - The number of bytes per limb.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">F:Math.Mpfr.Native.mpfr_lib.mp_uint_per_limb</codeEntityReference> - The number of 32-bit, unsigned integers per limb.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Integer Functions:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Initializing Integers:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Initialize <legacyItalic>x</legacyItalic>, and set its value to 0.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_inits(Math.Mpfr.Native.mpz_t[])</codeEntityReference> - Initialize a NULL-terminated list of <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpz_t</codeEntityReference> variables, and set their values to 0.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init2(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Initialize <legacyItalic>x</legacyItalic>, with space for <legacyItalic>n</legacyItalic>-bit numbers, and set its value to 0.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_clear(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Free the space occupied by <legacyItalic>x</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_clears(Math.Mpfr.Native.mpz_t[])</codeEntityReference> - Free the space occupied by a NULL-terminated list of <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpz_t</codeEntityReference> variables.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_realloc2(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Change the space allocated for <legacyItalic>x</legacyItalic> to <legacyItalic>n</legacyItalic> bits.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Assigning Integers:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_si(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_d(Math.Mpfr.Native.mpz_t,System.Double)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_q(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_f(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_str(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.char_ptr,System.Int32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>str</legacyItalic>, a null-terminated C string in base <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_swap(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Swap the values <legacyItalic>rop1</legacyItalic> and <legacyItalic>rop2</legacyItalic> efficiently.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Simultaneous Integer Init &amp; Assign:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init_set(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> with limb space and set the initial numeric value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init_set_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> with limb space and set the initial numeric value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init_set_si(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> with limb space and set the initial numeric value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init_set_d(Math.Mpfr.Native.mpz_t,System.Double)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> with limb space and set the initial numeric value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_init_set_str(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.char_ptr,System.Int32)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> and set its value like <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_set_str(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.char_ptr,System.Int32)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Converting Integers:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_get_ui(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return the value of <legacyItalic>op</legacyItalic> as an unsigned long.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_get_si(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return the value of <legacyItalic>op</legacyItalic> as an signed long.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_get_d(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a double, truncating if necessary (i.e. rounding towards zero).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_get_d_2exp(System.Int32@,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a double, truncating if necessary (i.e. rounding towards zero), and returning the exponent separately.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_get_str(Math.Mpfr.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a string of digits in base <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Arithmetic:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_add(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> + <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_add_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> + <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sub(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sub_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_ui_sub(Math.Mpfr.Native.mpz_t,System.UInt32,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mul(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mul_si(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mul_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_addmul(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>rop</legacyItalic> + <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_addmul_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>rop</legacyItalic> + <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_submul(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>rop</legacyItalic> - <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_submul_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>rop</legacyItalic> - <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mul_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * 2^<legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_neg(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to -<legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_abs(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the absolute value of <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Division:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_q(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_r(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic> where q = ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_qr(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_q_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and return the remainder r = | <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_r_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic> where q = ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and return | <legacyItalic>r</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_qr_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set quotient <legacyItalic>q</legacyItalic> to ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic>, and return | <legacyItalic>r</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Return the remainder | r | where r = <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic>, and where q = ceiling(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_q_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to ceiling(<legacyItalic>n</legacyItalic> / 2^<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cdiv_r_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * 2^<legacyItalic>b</legacyItalic> where q = ceiling(<legacyItalic>n</legacyItalic> / 2^<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_q(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_r(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic> where q = floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_qr(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_q_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and return the remainder r = | <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_r_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic> where q = floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and return | <legacyItalic>r</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_qr_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set quotient <legacyItalic>q</legacyItalic> to floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic>, and return | <legacyItalic>r</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Return the remainder | r | where r = <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic>, and where q = floor(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_q_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to floor(<legacyItalic>n</legacyItalic> / 2^<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fdiv_r_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * 2^<legacyItalic>b</legacyItalic> where q = floor(<legacyItalic>n</legacyItalic> / 2^<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_q(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_r(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic> where q = trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_qr(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_q_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and return the remainder r = | <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_r_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic> where q = trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), and return | <legacyItalic>r</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_qr_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set quotient <legacyItalic>q</legacyItalic> to trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>), set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - <legacyItalic>q</legacyItalic> * <legacyItalic>d</legacyItalic>, and return | <legacyItalic>r</legacyItalic> |.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Return the remainder | r | where r = <legacyItalic>n</legacyItalic> - q * <legacyItalic>d</legacyItalic>, and where q = trunc(<legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_q_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the quotient <legacyItalic>q</legacyItalic> to trunc(<legacyItalic>n</legacyItalic> / 2^<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tdiv_r_2exp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the remainder <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> - q * 2^<legacyItalic>b</legacyItalic> where q = trunc(<legacyItalic>n</legacyItalic> / 2^<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mod(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> mod <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mod_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>r</legacyItalic> to <legacyItalic>n</legacyItalic> mod <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_divexact(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>q</legacyItalic> to <legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic> when it is known in advance that <legacyItalic>d</legacyItalic> divides <legacyItalic>n</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_divexact_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>q</legacyItalic> to <legacyItalic>n</legacyItalic> / <legacyItalic>d</legacyItalic> when it is known in advance that <legacyItalic>d</legacyItalic> divides <legacyItalic>n</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_divisible_p(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero if <legacyItalic>n</legacyItalic> is exactly divisible by <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_divisible_ui_p(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Return non-zero if <legacyItalic>n</legacyItalic> is exactly divisible by <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_divisible_2exp_p(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Return non-zero if <legacyItalic>n</legacyItalic> is exactly divisible by 2^<legacyItalic>b</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_congruent_p(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero if <legacyItalic>n</legacyItalic> is congruent to <legacyItalic>c</legacyItalic> modulo <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_congruent_ui_p(Math.Mpfr.Native.mpz_t,System.UInt32,System.UInt32)</codeEntityReference> - Return non-zero if <legacyItalic>n</legacyItalic> is congruent to <legacyItalic>c</legacyItalic> modulo <legacyItalic>d</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_congruent_2exp_p(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Return non-zero if <legacyItalic>n</legacyItalic> is congruent to <legacyItalic>c</legacyItalic> modulo 2^<legacyItalic>b</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Exponentiation:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_powm(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to (<legacyItalic>base</legacyItalic>^<legacyItalic>exp</legacyItalic>) modulo <legacyItalic>mod</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_powm_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to (<legacyItalic>base</legacyItalic>^<legacyItalic>exp</legacyItalic>) modulo <legacyItalic>mod</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_powm_sec(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to (<legacyItalic>base</legacyItalic>^<legacyItalic>exp</legacyItalic>) modulo <legacyItalic>mod</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_pow_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>base</legacyItalic>^<legacyItalic>exp</legacyItalic>. The case 0^0 yields 1. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_ui_pow_ui(Math.Mpfr.Native.mpz_t,System.UInt32,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>base</legacyItalic>^<legacyItalic>exp</legacyItalic>. The case 0^0 yields 1.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Roots:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_root(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the truncated integer part of the <legacyItalic>n</legacyItalic>th root of <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_rootrem(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>root</legacyItalic> to the truncated integer part of the <legacyItalic>n</legacyItalic>th root of <legacyItalic>u</legacyItalic>. Set <legacyItalic>rem</legacyItalic> to the remainder, <legacyItalic>u</legacyItalic> - <legacyItalic>root</legacyItalic>^<legacyItalic>n</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sqrt(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the truncated integer part of the square root of <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sqrtrem(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop1</legacyItalic> to the truncated integer part of the square root of <legacyItalic>op</legacyItalic>, like <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sqrt(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference>. Set <legacyItalic>rop2</legacyItalic> to the remainder <legacyItalic>op</legacyItalic> - <legacyItalic>rop1</legacyItalic> * <legacyItalic>rop1</legacyItalic>, which will be zero if <legacyItalic>op</legacyItalic> is a perfect square.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_perfect_power_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <legacyItalic>op</legacyItalic> = a^b. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_perfect_square_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> is a perfect square, i.e., if the square root of <legacyItalic>op</legacyItalic> is an integer.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Number Theoretic Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_probab_prime_p(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Determine whether <legacyItalic>n</legacyItalic> is prime.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_nextprime(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the next prime greater than <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_gcd(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the greatest common divisor of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_gcd_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Compute the greatest common divisor of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>. If <legacyItalic>rop</legacyItalic> is not null, store the result there. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_gcdext(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>g</legacyItalic> to the greatest common divisor of <legacyItalic>a</legacyItalic> and <legacyItalic>b</legacyItalic>, and in addition set <legacyItalic>s</legacyItalic> and <legacyItalic>t</legacyItalic> to coefficients satisfying <legacyItalic>a</legacyItalic> * <legacyItalic>s</legacyItalic> + <legacyItalic>b</legacyItalic> * <legacyItalic>t</legacyItalic> = <legacyItalic>g</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_lcm(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the least common multiple of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_lcm_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the least common multiple of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_invert(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Compute the inverse of <legacyItalic>op1</legacyItalic> modulo <legacyItalic>op2</legacyItalic> and put the result in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_jacobi(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Calculate the Jacobi symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>b</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_legendre(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Calculate the Legendre symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>p</legacyItalic>).<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_kronecker(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Calculate the Jacobi symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>b</legacyItalic>) with the Kronecker extension (<legacyItalic>a</legacyItalic>/2) = (2/<legacyItalic>a</legacyItalic>) when <legacyItalic>a</legacyItalic> odd, or (<legacyItalic>a</legacyItalic>/2) = 0 when <legacyItalic>a</legacyItalic> even. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_kronecker_si(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Calculate the Jacobi symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>b</legacyItalic>) with the Kronecker extension (<legacyItalic>a</legacyItalic>/2) = (2/<legacyItalic>a</legacyItalic>) when <legacyItalic>a</legacyItalic> odd, or (<legacyItalic>a</legacyItalic>/2) = 0 when <legacyItalic>a</legacyItalic> even. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_kronecker_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Calculate the Jacobi symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>b</legacyItalic>) with the Kronecker extension (<legacyItalic>a</legacyItalic>/2) = (2/<legacyItalic>a</legacyItalic>) when <legacyItalic>a</legacyItalic> odd, or (<legacyItalic>a</legacyItalic>/2) = 0 when <legacyItalic>a</legacyItalic> even. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_si_kronecker(System.Int32,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Calculate the Jacobi symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>b</legacyItalic>) with the Kronecker extension (<legacyItalic>a</legacyItalic>/2) = (2/<legacyItalic>a</legacyItalic>) when <legacyItalic>a</legacyItalic> odd, or (<legacyItalic>a</legacyItalic>/2) = 0 when <legacyItalic>a</legacyItalic> even. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_ui_kronecker(System.UInt32,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Calculate the Jacobi symbol (<legacyItalic>a</legacyItalic>/<legacyItalic>b</legacyItalic>) with the Kronecker extension (<legacyItalic>a</legacyItalic>/2) = (2/<legacyItalic>a</legacyItalic>) when <legacyItalic>a</legacyItalic> odd, or (<legacyItalic>a</legacyItalic>/2) = 0 when <legacyItalic>a</legacyItalic> even. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_remove(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Remove all occurrences of the factor <legacyItalic>f</legacyItalic> from <legacyItalic>op</legacyItalic> and store the result in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fac_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the factorial <legacyItalic>n</legacyItalic>!.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_2fac_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the double-factorial <legacyItalic>n</legacyItalic>!!.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_mfac_uiui(Math.Mpfr.Native.mpz_t,System.UInt32,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the m-multi-factorial <legacyItalic>n</legacyItalic>!^(<legacyItalic>m</legacyItalic>)n.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_primorial_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the primorial of <legacyItalic>n</legacyItalic>, i.e. the product of all positive prime numbers &#8804; <legacyItalic>n</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_bin_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Compute the binomial coefficient <legacyItalic>n</legacyItalic> over <legacyItalic>k</legacyItalic> and store the result in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_bin_uiui(Math.Mpfr.Native.mpz_t,System.UInt32,System.UInt32)</codeEntityReference> - Compute the binomial coefficient <legacyItalic>n</legacyItalic> over <legacyItalic>k</legacyItalic> and store the result in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fib_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Sets <legacyItalic>fn</legacyItalic> to to F[<legacyItalic>n</legacyItalic>], the <legacyItalic>n</legacyItalic>’th Fibonacci number. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fib2_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Sets <legacyItalic>fn</legacyItalic> to F[<legacyItalic>n</legacyItalic>], and <legacyItalic>fnsub1</legacyItalic> to F[<legacyItalic>n</legacyItalic> - 1]. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_lucnum_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Sets <legacyItalic>ln</legacyItalic> to to L[<legacyItalic>n</legacyItalic>], the <legacyItalic>n</legacyItalic>’th Lucas number. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_lucnum2_ui(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Sets <legacyItalic>ln</legacyItalic> to L[<legacyItalic>n</legacyItalic>], and <legacyItalic>lnsub1</legacyItalic> to L[<legacyItalic>n</legacyItalic> - 1]. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_millerrabin(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - An implementation of the probabilistic primality test found in Knuth's Seminumerical Algorithms book.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Comparisons:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmp(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmp_d(Math.Mpfr.Native.mpz_t,System.Double)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmp_si(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmp_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmpabs(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Compare the absolute values of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmpabs_d(Math.Mpfr.Native.mpz_t,System.Double)</codeEntityReference> - Compare the absolute values of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_cmpabs_ui(Math.Mpfr.Native.mpz_t,System.UInt32)</codeEntityReference> - Compare the absolute values of <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sgn(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return +1 if <legacyItalic>op</legacyItalic> &gt; 0, 0 if <legacyItalic>op</legacyItalic> = 0, and -1 if <legacyItalic>op</legacyItalic> &lt; 0.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Logic and Bit Fiddling:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_and(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> bitwise-and <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_ior(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> bitwise inclusive-or <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_xor(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> bitwise exclusive-or <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_com(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the one’s complement of <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_popcount(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return the population count of <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_hamdist(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return the hamming distance between the two operands.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_scan0(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Scan <legacyItalic>op</legacyItalic> for 0 bit.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_scan1(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Scan <legacyItalic>op</legacyItalic> for 1 bit.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_setbit(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set bit <legacyItalic>bit_index</legacyItalic> in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_clrbit(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Clear bit <legacyItalic>bit_index</legacyItalic> in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_combit(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Complement bit <legacyItalic>bit_index</legacyItalic> in <legacyItalic>rop</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_tstbit(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Test bit <legacyItalic>bit_index</legacyItalic> in <legacyItalic>op</legacyItalic> and return 0 or 1 accordingly. <markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  I/O of Integers:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_out_str(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.Int32,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Output <legacyItalic>op</legacyItalic> on stdio stream <legacyItalic>stream</legacyItalic>, as a string of digits in base <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_inp_str(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.Int32)</codeEntityReference> - Input a possibly white-space preceded string in base <legacyItalic>base</legacyItalic> from stdio stream <legacyItalic>stream</legacyItalic>, and put the read integer in <legacyItalic>rop</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_out_raw(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},Math.Mpfr.Native.mpz_t)</codeEntityReference> - Output <legacyItalic>op</legacyItalic> on stdio stream <legacyItalic>stream</legacyItalic>, in raw binary format.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_inp_raw(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE})</codeEntityReference> - Input from stdio stream <legacyItalic>stream</legacyItalic> in the format written by <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_out_raw(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},Math.Mpfr.Native.mpz_t)</codeEntityReference>, and put the result in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Random Numbers:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_urandomb(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Generate a uniformly distributed random integer in the range 0 to 2^<legacyItalic>n</legacyItalic> - 1, inclusive.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_urandomm(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Generate a uniform random integer in the range 0 to <legacyItalic>n</legacyItalic> - 1, inclusive.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_rrandomb(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Generate a random integer with long strings of zeros and ones in the binary representation.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_random(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Generate a random integer of at most <legacyItalic>max_size</legacyItalic> limbs.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_random2(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Generate a random integer of at most <legacyItalic>max_size</legacyItalic> limbs, with long strings of zeros and ones in the binary representation.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Import and Export:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_import(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.size_t,System.Int32,Math.Mpfr.Native.size_t,System.Int32,Math.Mpfr.Native.size_t,Math.Mpfr.Native.void_ptr)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> from an array of word data at <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_export(Math.Mpfr.Native.void_ptr,Math.Mpfr.Native.size_t@,System.Int32,Math.Mpfr.Native.size_t,System.Int32,Math.Mpfr.Native.size_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Fill <legacyItalic>rop</legacyItalic> with word data from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Miscellaneous Integer Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fits_sint_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero iff the value of <legacyItalic>op</legacyItalic> fits in a signed 32-bit integer. Otherwise, return zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fits_slong_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero iff the value of <legacyItalic>op</legacyItalic> fits in a signed 32-bit integer. Otherwise, return zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fits_sshort_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero iff the value of <legacyItalic>op</legacyItalic> fits in a signed 16-bit integer. Otherwise, return zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fits_uint_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero iff the value of <legacyItalic>op</legacyItalic> fits in an unsigned 32-bit integer. Otherwise, return zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fits_ulong_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero iff the value of <legacyItalic>op</legacyItalic> fits in an unsigned 32-bit integer. Otherwise, return zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_fits_ushort_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return non-zero iff the value of <legacyItalic>op</legacyItalic> fits in an unsigned 16-bit integer. Otherwise, return zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_sizeinbase(Math.Mpfr.Native.mpz_t,System.Int32)</codeEntityReference> - Return the size of <legacyItalic>op</legacyItalic> measured in number of digits in the given <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_even_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Determine whether <legacyItalic>op</legacyItalic> is even.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_odd_p(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Determine whether <legacyItalic>op</legacyItalic> is odd.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Integer Special Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib._mpz_realloc(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Change the space for <legacyItalic>integer</legacyItalic> to <legacyItalic>new_alloc</legacyItalic> limbs.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_getlimbn(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return limb number <legacyItalic>n</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_size(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return the size of <legacyItalic>op</legacyItalic> measured in number of limbs.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_limbs_read(Math.Mpfr.Native.mpz_t)</codeEntityReference> - Return a pointer to the limb array representing the absolute value of <legacyItalic>x</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_limbs_write(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return a pointer to the limb array of <legacyItalic>x</legacyItalic>, intended for write access.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_limbs_modify(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return a pointer to the limb array of <legacyItalic>x</legacyItalic>, intended for write access.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_limbs_finish(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Updates the internal size field of <legacyItalic>x</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpz_roinit_n(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Special initialization of <legacyItalic>x</legacyItalic>, using the given limb array and size.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Rational Number Functions:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Initializing Rationals:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_canonicalize(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Remove any factors that are common to the numerator and denominator of <legacyItalic>op</legacyItalic>, and make the denominator positive.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_init(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Initialize <legacyItalic>x</legacyItalic> and set it to 0/1.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_inits(Math.Mpfr.Native.mpq_t[])</codeEntityReference> - Initialize a NULL-terminated list of <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpq_t</codeEntityReference> variables, and set their values to 0/1. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_clear(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Free the space occupied by <legacyItalic>x</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_clears(Math.Mpfr.Native.mpq_t[])</codeEntityReference> - Free the space occupied by a NULL-terminated list of <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpq_t</codeEntityReference> variables. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Assign <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_z(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Assign <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_ui(Math.Mpfr.Native.mpq_t,System.UInt32,System.UInt32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_si(Math.Mpfr.Native.mpq_t,System.Int32,System.UInt32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_str(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.char_ptr,System.Int32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> from a null-terminated string <legacyItalic>str</legacyItalic> in the given <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_swap(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Swap the values <legacyItalic>rop1</legacyItalic> and <legacyItalic>rop2</legacyItalic> efficiently. <markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Rational Conversions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_get_d(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference>, truncating if necessary (i.e. rounding towards zero). <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_d(Math.Mpfr.Native.mpq_t,System.Double)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the value of <legacyItalic>op</legacyItalic>. There is no rounding, this conversion is exact. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_f(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the value of <legacyItalic>op</legacyItalic>. There is no rounding, this conversion is exact. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_get_str(Math.Mpfr.Native.char_ptr,System.Int32,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a string of digits in base <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Rational Arithmetic:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_add(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>sum</legacyItalic> to <legacyItalic>addend1</legacyItalic> + <legacyItalic>addend2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_sub(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>difference</legacyItalic> to <legacyItalic>minuend</legacyItalic> - <legacyItalic>subtrahend</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_mul(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>product</legacyItalic> to <legacyItalic>multiplier</legacyItalic> * <legacyItalic>multiplicand</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_mul_2exp(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * 2*<legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_div(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>quotient</legacyItalic> to <legacyItalic>dividend</legacyItalic> / <legacyItalic>divisor</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_div_2exp(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / 2^<legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_neg(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>negated_operand</legacyItalic> to -<legacyItalic>operand</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_abs(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the absolute value of <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_inv(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>inverted_number</legacyItalic> to 1 / <legacyItalic>number</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Comparing Rationals:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_cmp(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_cmp_z(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_cmp_ui(Math.Mpfr.Native.mpq_t,System.UInt32,System.UInt32)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>num2</legacyItalic> / <legacyItalic>den2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_cmp_si(Math.Mpfr.Native.mpq_t,System.Int32,System.UInt32)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>num2</legacyItalic> / <legacyItalic>den2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_sgn(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Return +1 if <legacyItalic>op</legacyItalic> &gt; 0, 0 if <legacyItalic>op</legacyItalic> = 0, and -1 if <legacyItalic>op</legacyItalic> &lt; 0. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_equal(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Return non-zero if <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic> are equal, zero if they are non-equal. <markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Applying Integer Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_numref(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Return a reference to the numerator <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_denref(Math.Mpfr.Native.mpq_t)</codeEntityReference> - Return a reference to the denominator <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_get_num(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>numerator</legacyItalic> to the numerator of <legacyItalic>rational</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_get_den(Math.Mpfr.Native.mpz_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set <legacyItalic>denominator</legacyItalic> to the denominator of <legacyItalic>rational</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_num(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the numerator of <legacyItalic>rational</legacyItalic> to <legacyItalic>numerator</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_set_den(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the denominator of <legacyItalic>rational</legacyItalic> to <legacyItalic>denominator</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  I/O of Rationals:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_out_str(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.Int32,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Output <legacyItalic>op</legacyItalic> on stdio stream <legacyItalic>stream</legacyItalic>, as a string of digits in base <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpq_inp_str(Math.Mpfr.Native.mpq_t,Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.Int32)</codeEntityReference> - Read a string of digits from <legacyItalic>stream</legacyItalic> and convert them to a rational in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Floating-point Functions:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Initializing Floats:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_default_prec(Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the default precision to be at least <legacyItalic>prec</legacyItalic> bits.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_default_prec</codeEntityReference> - Return the default precision actually used. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Initialize <legacyItalic>x</legacyItalic> to 0.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init2(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Initialize <legacyItalic>x</legacyItalic> to 0 and set its precision to be at least <legacyItalic>prec</legacyItalic> bits.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_inits(Math.Mpfr.Native.mpf_t[])</codeEntityReference> - Initialize a NULL-terminated list of <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpf_t</codeEntityReference> variables, and set their values to 0.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_clear(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Free the space occupied by <legacyItalic>x</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_clears(Math.Mpfr.Native.mpf_t[])</codeEntityReference> - Free the space occupied by a NULL-terminated list of <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mpf_t</codeEntityReference> variables. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_prec(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return the current precision of <legacyItalic>op</legacyItalic>, in bits. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_prec(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the precision of <legacyItalic>rop</legacyItalic> to be at least <legacyItalic>prec</legacyItalic> bits.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_prec_raw(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set the precision of <legacyItalic>rop</legacyItalic> to be at least <legacyItalic>prec</legacyItalic> bits, without changing the memory allocated. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_size(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return the number of limbs currently in use.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Assigning Floats:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_ui(Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_si(Math.Mpfr.Native.mpf_t,System.Int32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_d(Math.Mpfr.Native.mpf_t,System.Double)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_z(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_q(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpq_t)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_set_str(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.char_ptr,System.Int32)</codeEntityReference> - Set the value of <legacyItalic>rop</legacyItalic> from the string in <legacyItalic>str</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_swap(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Swap <legacyItalic>rop1</legacyItalic> and <legacyItalic>rop2</legacyItalic> efficiently. <markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Simultaneous Float Init &amp; Assign:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init_set(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> and set its value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init_set_ui(Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> and set its value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init_set_si(Math.Mpfr.Native.mpf_t,System.Int32)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> and set its value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init_set_d(Math.Mpfr.Native.mpf_t,System.Double)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> and set its value from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_init_set_str(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.char_ptr,System.Int32)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> and set its value from the string in <legacyItalic>str</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Converting Floats:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_d(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a <codeEntityReference autoUpgrade="true">T:System.Double</codeEntityReference>, truncating if necessary (i.e. rounding towards zero). <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_d_2exp(Math.Mpfr.Native.ptr{System.Int32},Math.Mpfr.Native.mpf_t)</codeEntityReference> - Convert op to a double, truncating if necessary (i.e. rounding towards zero), and with an exponent returned separately. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_si(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a 32-bit integer, truncating any fraction part.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_ui(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to an unsigned 32-bit integer, truncating any fraction part.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_get_str(Math.Mpfr.Native.char_ptr,Math.Mpfr.Native.ptr{Math.Mpfr.Native.mp_exp_t},System.Int32,Math.Mpfr.Native.size_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Convert <legacyItalic>op</legacyItalic> to a string of digits in base <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Float Arithmetic:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_add(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> + <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_add_ui(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> + <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_sub(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_ui_sub(Math.Mpfr.Native.mpf_t,System.UInt32,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_sub_ui(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_mul(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_mul_ui(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_div(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_ui_div(Math.Mpfr.Native.mpf_t,System.UInt32,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_div_ui(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / <legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_sqrt(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the square root of <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_sqrt_ui(Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to the square root of <legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_pow_ui(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic>^<legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_neg(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to -<legacyItalic>op</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_abs(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to | <legacyItalic>op</legacyItalic> |. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_mul_2exp(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> * 2^<legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_div_2exp(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op1</legacyItalic> / 2^<legacyItalic>op2</legacyItalic>. <markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Float Comparison:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_cmp(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_cmp_z(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_cmp_d(Math.Mpfr.Native.mpf_t,System.Double)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_cmp_ui(Math.Mpfr.Native.mpf_t,System.UInt32)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_cmp_si(Math.Mpfr.Native.mpf_t,System.Int32)</codeEntityReference> - Compare <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_reldiff(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Compute the relative difference between <legacyItalic>op1</legacyItalic> and <legacyItalic>op2</legacyItalic> and store the result in <legacyItalic>rop</legacyItalic>. This is | <legacyItalic>op1</legacyItalic> - <legacyItalic>op2</legacyItalic> | / <legacyItalic>op1</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_sgn(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0. <markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  I/O of Floats:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_out_str(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.Int32,Math.Mpfr.Native.size_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Print <legacyItalic>op</legacyItalic> to <legacyItalic>stream</legacyItalic>, as a string of digits.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_inp_str(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.Int32)</codeEntityReference> - Read a string in base <legacyItalic>base</legacyItalic> from <legacyItalic>stream</legacyItalic>, and put the read float in <legacyItalic>rop</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Miscellaneous Float Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_ceil(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op</legacyItalic> rounded to the next higher integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_floor(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op</legacyItalic> rounded to the next lower integer.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_trunc(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpf_t)</codeEntityReference> - Set <legacyItalic>rop</legacyItalic> to <legacyItalic>op</legacyItalic> rounded to the integer towards zero. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_integer_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> is an integer.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_fits_ulong_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> fits in an unsigned 32-bit integer, when truncated to an integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_fits_slong_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> fits in a 32-bit integer, when truncated to an integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_fits_uint_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> fits in an unsigned 32-bit integer, when truncated to an integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_fits_sint_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> fits in a 32-bit integer, when truncated to an integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_fits_sshort_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> fits in a 16-bit integer, when truncated to an integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_fits_ushort_p(Math.Mpfr.Native.mpf_t)</codeEntityReference> - Return non-zero if <legacyItalic>op</legacyItalic> fits in an unsigned 16-bit integer, when truncated to an integer. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_urandomb(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Generate a uniformly distributed random float in <legacyItalic>rop</legacyItalic>, such that 0 &#8804; rop &lt; 1, with <legacyItalic>nbits</legacyItalic> significant bits in the mantissa or less if the precision of <legacyItalic>rop</legacyItalic> is smaller.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpf_random2(Math.Mpfr.Native.mpf_t,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_exp_t)</codeEntityReference> - Generate a random float of at most <legacyItalic>max_size</legacyItalic> limbs, with long strings of zeros and ones in the binary representation.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Low-level Functions:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_add_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Add {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the <legacyItalic>n</legacyItalic> least significant limbs of the result to <legacyItalic>rp</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_add_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Add {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and <legacyItalic>s2limb</legacyItalic>, and write the <legacyItalic>n</legacyItalic> least significant limbs of the result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_add(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Add {<legacyItalic>s1p</legacyItalic>, <legacyItalic>s1n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>s2n</legacyItalic>}, and write the <legacyItalic>s1n</legacyItalic> least significant limbs of the result to <legacyItalic>rp</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sub_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Subtract {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>} from {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the <legacyItalic>n</legacyItalic> least significant limbs of the result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sub_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Subtract <legacyItalic>s2limb</legacyItalic> from {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the <legacyItalic>n</legacyItalic> least significant limbs of the result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sub(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Subtract {<legacyItalic>s2p</legacyItalic>, <legacyItalic>s2n</legacyItalic>} from {<legacyItalic>s1p</legacyItalic>, <legacyItalic>s1n</legacyItalic>}, and write the <legacyItalic>s1n</legacyItalic> least significant limbs of the result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_neg(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the negation of {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_mul_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Multiply {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the (2 * <legacyItalic>n</legacyItalic>)-limb result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_mul(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Multiply {<legacyItalic>s1p</legacyItalic>, <legacyItalic>s1n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>s2n</legacyItalic>}, and write the (<legacyItalic>s1n</legacyItalic> + <legacyItalic>s2n</legacyItalic>)-limb result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sqr(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Compute the square of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and write the (2 * <legacyItalic>n</legacyItalic>)-limb result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_mul_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Multiply {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} by <legacyItalic>s2limb</legacyItalic>, and write the <legacyItalic>n</legacyItalic> least significant limbs of the product to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_addmul_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Multiply {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and <legacyItalic>s2limb</legacyItalic>, and add the <legacyItalic>n</legacyItalic> least significant limbs of the product to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>} and write the result to <legacyItalic>rp</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_submul_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Multiply {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and <legacyItalic>s2limb</legacyItalic>, and subtract the <legacyItalic>n</legacyItalic> least significant limbs of the product from {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>} and write the result to <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_tdiv_qr(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Divide {<legacyItalic>np</legacyItalic>, <legacyItalic>nn</legacyItalic>} by {<legacyItalic>dp</legacyItalic>, <legacyItalic>dn</legacyItalic>} and put the quotient at {<legacyItalic>qp</legacyItalic>, <legacyItalic>nn</legacyItalic> - <legacyItalic>dn</legacyItalic> + 1} and the remainder at {<legacyItalic>rp</legacyItalic>, <legacyItalic>dn</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_divrem_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Divide {<legacyItalic>s2p</legacyItalic>, <legacyItalic>s2n</legacyItalic>} by <legacyItalic>s3limb</legacyItalic>, and write the quotient at <legacyItalic>r1p</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_divmod_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Divide {<legacyItalic>s2p</legacyItalic>, <legacyItalic>s2n</legacyItalic>} by <legacyItalic>s3limb</legacyItalic>, and write the quotient at <legacyItalic>r1p</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_divexact_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Divide {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} by <legacyItalic>d</legacyItalic>, expecting it to divide exactly, and writing the result to {r<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_divexact_by3(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Divide {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} by 3, expecting it to divide exactly, and writing the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_divexact_by3c(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Divide {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} by 3, expecting it to divide exactly, and writing the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_mod_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Divide {<legacyItalic>s1p</legacyItalic>, <legacyItalic>s1n</legacyItalic>} by <legacyItalic>s2limb</legacyItalic>, and return the remainder. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_lshift(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,System.UInt32)</codeEntityReference> - Shift {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} left by <legacyItalic>count</legacyItalic> bits, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_rshift(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,System.UInt32)</codeEntityReference> - Shift {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} right by <legacyItalic>count</legacyItalic> bits, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_cmp(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Compare {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_zero_p(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Test {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} and return 1 if the operand is zero, 0 otherwise.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_gcd(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Set {<legacyItalic>rp</legacyItalic>, retval} to the greatest common divisor of {<legacyItalic>xp</legacyItalic>, <legacyItalic>xn</legacyItalic>} and {<legacyItalic>yp</legacyItalic>, <legacyItalic>yn</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_gcd_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t)</codeEntityReference> - Return the greatest common divisor of {<legacyItalic>xp</legacyItalic>, <legacyItalic>xn</legacyItalic>} and <legacyItalic>ylimb</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_gcdext(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.ptr{Math.Mpfr.Native.mp_size_t},Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Compute the greatest common divisor G of U and V. Compute a cofactor S such that G = US + VT.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sqrtrem(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Compute the square root of {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} and put the result at {<legacyItalic>r1p</legacyItalic>, ceil(<legacyItalic>n</legacyItalic> / 2)} and the remainder at {<legacyItalic>r2p</legacyItalic>, retval}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sizeinbase(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,System.Int32)</codeEntityReference> - Return the size of {<legacyItalic>xp</legacyItalic>, <legacyItalic>n</legacyItalic>} measured in number of digits in the given <legacyItalic>base</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_get_str(Math.Mpfr.Native.char_ptr,System.Int32,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Convert {<legacyItalic>s1p</legacyItalic>, <legacyItalic>s1n</legacyItalic>} to a raw unsigned char array at <legacyItalic>str</legacyItalic> in base <legacyItalic>base</legacyItalic>, and return the number of characters produced.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_set_str(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.char_ptr,Math.Mpfr.Native.size_t,System.Int32)</codeEntityReference> - Convert bytes {<legacyItalic>str</legacyItalic>, <legacyItalic>strsize</legacyItalic>} in the given <legacyItalic>base</legacyItalic> to limbs at <legacyItalic>rp</legacyItalic>. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_scan0(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Scan <legacyItalic>s1p</legacyItalic> from bit position <legacyItalic>bit</legacyItalic> for the next clear bit.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_scan1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Scan <legacyItalic>s1p</legacyItalic> from bit position <legacyItalic>bit</legacyItalic> for the next set bit.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_random(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Generate a random number of length <legacyItalic>r1n</legacyItalic> and store it at <legacyItalic>r1p</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_random2(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Generate a random number of length <legacyItalic>r1n</legacyItalic> and store it at <legacyItalic>r1p</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_popcount(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Count the number of set bits in {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_hamdist(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Compute the hamming distance between {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, which is the number of bit positions where the two operands have different bit values. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_perfect_square_p(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return non-zero iff {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} is a perfect square.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_perfect_power_p(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return non-zero iff {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>} is a perfect power.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_and_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical and of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_ior_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical inclusive or of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_xor_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical exclusive or of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_andn_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical and of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and the bitwise complement of {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_iorn_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical inclusive or of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and the bitwise complement of {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_nand_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical and of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the bitwise complement of the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_nior_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical inclusive or of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the bitwise complement of the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_xnor_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise logical exclusive or of {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>s2p</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the bitwise complement of the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_com(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Perform the bitwise complement of {<legacyItalic>sp</legacyItalic>, <legacyItalic>n</legacyItalic>}, and write the result to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_copyi(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Copy from {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}, increasingly. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_copyd(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Copy from {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} to {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}, decreasingly. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_zero(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Zero {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Low-level functions for cryptography:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_cnd_add_n(Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - If <legacyItalic>cnd</legacyItalic> is non-zero, it produces the same result as a regular <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_add_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference>, and if <legacyItalic>cnd</legacyItalic> is zero, it copies {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} to the result area and returns zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_cnd_sub_n(Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - If <legacyItalic>cnd</legacyItalic> is non-zero, it produces the same result as a regular <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sub_n(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference>, and if <legacyItalic>cnd</legacyItalic> is zero, it copies {<legacyItalic>s1p</legacyItalic>, <legacyItalic>n</legacyItalic>} to the result area and returns zero.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_add_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to A + b, where R = {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}, A = {<legacyItalic>ap</legacyItalic>, <legacyItalic>n</legacyItalic>}, and <legacyItalic>b</legacyItalic> is a single limb.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_add_1_itch(Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_add_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_sub_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to A - b, where R = {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}, A = {<legacyItalic>ap</legacyItalic>, <legacyItalic>n</legacyItalic>}, and <legacyItalic>b</legacyItalic> is a single limb.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_sub_1_itch(Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_sub_1(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_cnd_swap(Math.Mpfr.Native.mp_limb_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - If <legacyItalic>cnd</legacyItalic> is non-zero, swaps the contents of the areas {<legacyItalic>ap</legacyItalic>, <legacyItalic>n</legacyItalic>} and {<legacyItalic>bp</legacyItalic>, <legacyItalic>n</legacyItalic>}. Otherwise, the areas are left unmodified.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_mul(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to A * B, where A = {<legacyItalic>ap</legacyItalic>, <legacyItalic>an</legacyItalic>}, B = {<legacyItalic>bp</legacyItalic>, <legacyItalic>bn</legacyItalic>}, and R = {<legacyItalic>rp</legacyItalic>, <legacyItalic>an</legacyItalic> + <legacyItalic>bn</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_mul_itch(Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_mul(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_sqr(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to A^2, where A = {<legacyItalic>ap</legacyItalic>, <legacyItalic>an</legacyItalic>}, and R = {<legacyItalic>rp</legacyItalic>, 2 * <legacyItalic>an</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_sqr_itch(Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_sqr(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_powm(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_bitcnt_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to (B^E) modulo M, where R = {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}, M = {<legacyItalic>mp</legacyItalic>, <legacyItalic>n</legacyItalic>}, and E = {<legacyItalic>ep</legacyItalic>, ceil(<legacyItalic>enb</legacyItalic> / <codeEntityReference autoUpgrade="true">F:Math.Mpfr.Native.mpfr_lib.mp_bits_per_limb</codeEntityReference>)}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_powm_itch(Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_bitcnt_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_powm(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_bitcnt_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_tabselect(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Select entry <legacyItalic>which</legacyItalic> from table <legacyItalic>tab</legacyItalic>, which has <legacyItalic>nents</legacyItalic> entries, each <legacyItalic>n</legacyItalic> limbs. Store the selected entry at <legacyItalic>rp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_div_qr(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set Q to the truncated quotient N / D and R to N modulo D, where N = {<legacyItalic>np</legacyItalic>, <legacyItalic>nn</legacyItalic>}, D = {<legacyItalic>dp</legacyItalic>, <legacyItalic>dn</legacyItalic>}, Q’s most significant limb is the function return value and the remaining limbs are {<legacyItalic>qp</legacyItalic>, <legacyItalic>nn</legacyItalic> - <legacyItalic>dn</legacyItalic>}, and R = {<legacyItalic>np</legacyItalic>, <legacyItalic>dn</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_div_qr_itch(Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_div_qr(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_div_r(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to N modulo D, where N = {<legacyItalic>np</legacyItalic>, <legacyItalic>nn</legacyItalic>}, D = {<legacyItalic>dp</legacyItalic>, <legacyItalic>dn</legacyItalic>}, and R = {<legacyItalic>np</legacyItalic>, <legacyItalic>dn</legacyItalic>}. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_div_r_itch(Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_div_r(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_invert(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_bitcnt_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference> - Set R to the inverse of A modulo M, where R = {<legacyItalic>rp</legacyItalic>, <legacyItalic>n</legacyItalic>}, A = {<legacyItalic>ap</legacyItalic>, <legacyItalic>n</legacyItalic>}, and M = {<legacyItalic>mp</legacyItalic>, <legacyItalic>n</legacyItalic>}. This function’s interface is preliminary. <markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_invert_itch(Math.Mpfr.Native.mp_size_t)</codeEntityReference> - Return the scratch space in number of limbs required by the function <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpn_sec_invert(Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_ptr,Math.Mpfr.Native.mp_size_t,Math.Mpfr.Native.mp_bitcnt_t,Math.Mpfr.Native.mp_ptr)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Random Number Functions:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Random State Initialization:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randinit_default(Math.Mpfr.Native.mpfr_randstate_t)</codeEntityReference> - Initialize <legacyItalic>state</legacyItalic> with a default algorithm.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randinit_mt(Math.Mpfr.Native.mpfr_randstate_t)</codeEntityReference> - Initialize <legacyItalic>state</legacyItalic> for a Mersenne Twister algorithm.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randinit_lc_2exp(Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mpz_t,System.UInt32,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Initialize <legacyItalic>state</legacyItalic> with a linear congruential algorithm X = (<legacyItalic>a</legacyItalic>X + <legacyItalic>c</legacyItalic>) mod 2^<legacyItalic>m2exp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randinit_lc_2exp_size(Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference> - Initialize <legacyItalic>state</legacyItalic> for a linear congruential algorithm as per <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randinit_lc_2exp(Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mpz_t,System.UInt32,Math.Mpfr.Native.mp_bitcnt_t)</codeEntityReference>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randinit_set(Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mpfr_randstate_t)</codeEntityReference> - Initialize <legacyItalic>rop</legacyItalic> with a copy of the algorithm and state from <legacyItalic>op</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randclear(Math.Mpfr.Native.mpfr_randstate_t)</codeEntityReference> - Free all memory occupied by <legacyItalic>state</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Random State Seeding:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randseed(Math.Mpfr.Native.mpfr_randstate_t,Math.Mpfr.Native.mpz_t)</codeEntityReference> - Set an initial <legacyItalic>seed</legacyItalic> value into <legacyItalic>state</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_randseed_ui(Math.Mpfr.Native.mpfr_randstate_t,System.UInt32)</codeEntityReference> - Set an initial <legacyItalic>seed</legacyItalic> value into <legacyItalic>state</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
              <listItem>
                <para>
                  Random State Miscellaneous:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomb_ui(Math.Mpfr.Native.mpfr_randstate_t,System.UInt32)</codeEntityReference> - Generate a uniformly distributed random number of <legacyItalic>n</legacyItalic> bits, i.e. in the range 0 to 2^<legacyItalic>n</legacyItalic> - 1 inclusive.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_urandomm_ui(Math.Mpfr.Native.mpfr_randstate_t,System.UInt32)</codeEntityReference> - Generate a uniformly distributed random number in the range 0 to <legacyItalic>n</legacyItalic> - 1, inclusive.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Formatted Output:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Formatted Output Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_printf(System.String,System.Object[])</codeEntityReference> - Print to the standard output stdout.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vprintf(System.String,System.Object[])</codeEntityReference> - Print to the standard output stdout.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_fprintf(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.String,System.Object[])</codeEntityReference> - Print to the stream <legacyItalic>fp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vfprintf(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.String,System.Object[])</codeEntityReference> - Print to the stream <legacyItalic>fp</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_sprintf(Math.Mpfr.Native.char_ptr,System.String,System.Object[])</codeEntityReference> - Form a null-terminated string in <legacyItalic>buf</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vsprintf(Math.Mpfr.Native.char_ptr,System.String,System.Object[])</codeEntityReference> - Form a null-terminated string in <legacyItalic>buf</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_snprintf(Math.Mpfr.Native.char_ptr,Math.Mpfr.Native.size_t,System.String,System.Object[])</codeEntityReference> - Form a null-terminated string in <legacyItalic>buf</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vsnprintf(Math.Mpfr.Native.char_ptr,Math.Mpfr.Native.size_t,System.String,System.Object[])</codeEntityReference> - Form a null-terminated string in <legacyItalic>buf</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_asprintf(Math.Mpfr.Native.ptr{Math.Mpfr.Native.char_ptr},System.String,System.Object[])</codeEntityReference> - Form a null-terminated string in a block of memory obtained from the current memory allocation function.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf(Math.Mpfr.Native.ptr{Math.Mpfr.Native.char_ptr},System.String,System.Object[])</codeEntityReference> - Form a null-terminated string in a block of memory obtained from the current memory allocation function.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Formatted Input:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Formatted Input Functions:
                </para>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_scanf(System.String,System.Object[])</codeEntityReference> - Read from the standard input stdin.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vscanf(System.String,System.Object[])</codeEntityReference> - Read from the standard input stdin.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_fscanf(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.String,System.Object[])</codeEntityReference> - Read from the stream fp.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vfscanf(Math.Mpfr.Native.ptr{Math.Mpfr.Native.FILE},System.String,System.Object[])</codeEntityReference> - Read from the stream fp.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_sscanf(System.String,System.String,System.Object[])</codeEntityReference> - Read from a null-terminated string <legacyItalic>s</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mpfr_vsscanf(System.String,System.String,System.Object[])</codeEntityReference> - Read from a null-terminated string <legacyItalic>s</legacyItalic>.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

          <listItem>
            <para>
              <legacyBold>Custom Allocation:</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mp_set_memory_functions(Math.Mpfr.Native.allocate_function,Math.Mpfr.Native.reallocate_function,Math.Mpfr.Native.free_function)</codeEntityReference> - Replace the current allocation functions from the arguments.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.mp_get_memory_functions(Math.Mpfr.Native.allocate_function@,Math.Mpfr.Native.reallocate_function@,Math.Mpfr.Native.free_function@)</codeEntityReference> - Get the current allocation functions, storing function pointers to the locations given by the arguments.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.allocate(Math.Mpfr.Native.size_t)</codeEntityReference> - Return a pointer to newly allocated space with at least <legacyItalic>alloc_size</legacyItalic> bytes.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.reallocate(Math.Mpfr.Native.void_ptr,Math.Mpfr.Native.size_t,Math.Mpfr.Native.size_t)</codeEntityReference> - Resize a previously allocated block <legacyItalic>ptr</legacyItalic> of <legacyItalic>old_size</legacyItalic> bytes to be <legacyItalic>new_size</legacyItalic> bytes.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.free(Math.Mpfr.Native.mp_ptr[])</codeEntityReference> - De-allocate the space pointed to by <legacyItalic>ptrs</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.free(Math.Mpfr.Native.mpfr_randstate_t)</codeEntityReference> - De-allocate the space pointed to by <legacyItalic>ptr</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.free(Math.Mpfr.Native.char_ptr)</codeEntityReference> - De-allocate the space pointed to by <legacyItalic>ptr</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.free(Math.Mpfr.Native.void_ptr)</codeEntityReference> - De-allocate the space pointed to by <legacyItalic>ptr</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.free(Math.Mpfr.Native.void_ptr,Math.Mpfr.Native.size_t)</codeEntityReference> - De-allocate the space pointed to by <legacyItalic>ptr</legacyItalic>.<markup>
                    <br/>
                  </markup>
                  <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.ZeroMemory(System.IntPtr,System.Int32)</codeEntityReference> - The <codeEntityReference autoUpgrade="true">M:Math.Mpfr.Native.mpfr_lib.ZeroMemory(System.IntPtr,System.Int32)</codeEntityReference> routine fills a block of memory with zeros, given a pointer to the block and the length, in bytes, to be filled.<markup>
                    <br/>
                  </markup>
                </para>
              </listItem>
            </list>
          </listItem>

        </list>
      </content>
    </section>

    <section>
      <title>C and .NET Types Equivalence</title>
      <content>
        <para>
          The table below shows how each C type maps to .NET.
          Note that the <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mp_limb_t</codeEntityReference>
          and <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.size_t</codeEntityReference> C types map
          to the CPU word, i.e., 32 or 64 bits.
          In particular, because <codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mp_limb_t</codeEntityReference>
          is the type of the integers that make up multi-precision numbers, matching the CPU word size ensures
          maximum performance.
          Unless you intend to use low-level (mpn) functions, you do not need to take into account the
          CPU word size, and can build for the "Any CPU" platform.
        </para>
        <table>
          <tableHeader>
            <row>
              <entry><para>C Types</para></entry>
              <entry><para>.NET Types</para></entry>
            </row>
          </tableHeader>
          <row>
            <entry><para>short</para></entry>
            <entry><para>Int16</para></entry>
          </row>
          <row>
            <entry><para>int</para></entry>
            <entry><para>Int32</para></entry>
          </row>
          <row>
            <entry><para>long</para></entry>
            <entry><para>Int32</para></entry>
          </row>
          <row>
            <entry><para>long long</para></entry>
            <entry><para>Int64</para></entry>
          </row>
          <row>
            <entry><para><codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mp_bitcnt_t</codeEntityReference></para></entry>
            <entry><para>UInt32</para></entry>
          </row>
          <row>
            <entry><para><codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mp_exp_t</codeEntityReference></para></entry>
            <entry><para>Int32</para></entry>
          </row>
          <row>
            <entry><para><codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mp_size_t</codeEntityReference></para></entry>
            <entry><para>Int32</para></entry>
          </row>
          <row>
            <entry><para><codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.mp_limb_t</codeEntityReference></para></entry>
            <entry><para>UInt32 (on 32-bit CPU) / UInt64 (on 64-bit CPU)</para></entry>
          </row>
          <row>
            <entry><para><codeEntityReference autoUpgrade="true">T:Math.Mpfr.Native.size_t</codeEntityReference></para></entry>
            <entry><para>UInt32 (on 32-bit CPU) / UInt64 (on 64-bit CPU)</para></entry>
          </row>
        </table>
      </content>
    </section>

    <section>
      <title>Building the GNU MPFR Library on Windows</title>
      <content>
        <list class="ordered">
          <listItem>
            <para>
              Install <externalLink><linkText>MSYS2</linkText><linkUri>https://github.com/msys2/msys2/wiki/MSYS2-introduction</linkUri><linkTarget>_self</linkTarget></externalLink>.              
            </para>
            <para>
              On a 64-bit computer, install <externalLink><linkText>msys2-x86_64-20161025.exe</linkText><linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/</linkUri><linkTarget>_self</linkTarget></externalLink>,
              and on a 32-bit computer, install <externalLink><linkText>msys2-i686-20161025.exe</linkText><linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native/tree/master/Math.Mpfr.Native/Dependencies/</linkUri><linkTarget>_self</linkTarget></externalLink>.
              You can also check for a more recent version of MSYS2 <externalLink><linkText>here</linkText><linkUri>https://github.com/msys2/msys2/wiki/MSYS2-installation</linkUri></externalLink>.
              Install MSYS2 to its default location.
            </para>
            <para>
              After installation, you need to updates MSYS2 packages. From the Windows Start Menu, start <command>MSYS2 MSYS</command>. In the shell command window,
              enter the command:
            </para>
            <list class="nobullet">
               <listItem>
                 <para>
                  <userInput>pacman -Syuu</userInput>
                </para>
              </listItem>
            </list>
            <para>
              and follow instructions.
              You will have to close the command window, reopen a new one, and reenter the command <userInput>pacman -Syuu</userInput>.
            </para>
            <para>
              Finally, in order to build software, you need to install a number of packages with the command:
            </para>
            <list class="nobullet">
               <listItem>
                 <para>
                  <userInput>pacman -S --needed base-devel mingw-w64-i686-toolchain mingw-w64-x86_64-toolchain git subversion mercurial mingw-w64-i686-cmake mingw-w64-x86_64-cmake</userInput>
                </para>
              </listItem>
            </list>
            <para>
              run from the same command window as in the previous step.
            </para>
            <para>
              To build 32-bit software, use the <command>MSYS2 MinGW 32-bit</command> command from the Windows Start Menu, and
              for 64-bit software, use <command>MSYS2 MinGW 64-bit</command>.
            </para>
          </listItem>
          <listItem>
            <para>
              Install <externalLink><linkText>yasm</linkText><linkUri>http://yasm.tortall.net/Download.html</linkUri><linkTarget>_self</linkTarget></externalLink>.
            </para>
            <para>
              On a 64-bit computer, copy <externalLink><linkText>yasm-1.3.0-win64.exe</linkText><linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/</linkUri><linkTarget>_self</linkTarget></externalLink>
              to <localUri>C:\msys64\usr\bin</localUri>, and rename it to <localUri>yasm.exe</localUri>.
            </para>
            <para>
              Similarly on a 32-bit computer, copy <externalLink><linkText>yasm-1.3.0-win32.exe</linkText><linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/</linkUri><linkTarget>_self</linkTarget></externalLink>
              to <localUri>C:\msys32\usr\bin</localUri>, and rename it to <localUri>yasm.exe</localUri>.
            </para>
          </listItem>
          <listItem>
            <para>
              Build <externalLink><linkText>GNU MPFR</linkText><linkUri>https://mpfrlib.org/</linkUri><linkTarget>_self</linkTarget></externalLink>.
            </para>
            <para>
              Create folders <localUri>C:\Temp\x86</localUri> and <localUri>C:\Temp\x64</localUri>.
              These are the folder where the compiled 32-bit and 64-bit versions of GNU MPFR will be installed.
              Unzip <externalLink><linkText>mpfr-6.1.2.tar.bz2</linkText><linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/</linkUri><linkTarget>_self</linkTarget></externalLink>
              in folder <localUri>C:\Temp</localUri>.
              This puts GNU MPFR in subfolder <localUri>mpfr-6.1.2</localUri>.
            </para>
            <para>
              In each one of the command windows openend with the commands <command>MSYS2 MinGW 32-bit</command>
              and <command>MSYS2 MinGW 64-bit</command> from the Windows Start Menu, run the commands below:
            </para>
            <list class="nobullet">
               <listItem>
                 <para>
                   <userInput>cd /c/Temp/mpfr-6.1.2</userInput><markup><br/></markup>
                   <userInput>./configure --enable-fat --disable-static --enable-shared --prefix=/c/Temp/x86</userInput> or <userInput>x64</userInput><markup><br/></markup>
                   <userInput>make</userInput><markup><br/></markup>
                   <userInput>make check</userInput><markup><br/></markup>
                   <userInput>make install</userInput><markup><br/></markup>
                </para>
              </listItem>
            </list>
            <para>
              The <userInput>--prefix</userInput> specifies the install folder.
              Note that the Windows <localUri>C:\</localUri> drive is specified as the root <localUri>/C/</localUri> folder in the <command>MinGW</command> window.
              Note also that the <userInput>configure</userInput> and <userInput>make</userInput> commands are to be run against a fresly uncompressed GNU MPFR source.
              The <userInput>make install</userInput> command creates <localUri>libmpfr-4.dll</localUri> in the <localUri>C:\Temp\x86</localUri> and <localUri>C:\Temp\x64</localUri> folders.
              These two compiled versions of the GNU MPFR library are to be copied to the <localUri>x86</localUri> and <localUri>x64</localUri> folders of the <localUri>Math.Mpfr.Native</localUri> Visual Studio projects.
              They can also be copied directly into the <localUri>x86</localUri> and <localUri>x64</localUri> folders of the <localUri>bin/Debug</localUri> or <localUri>bin/Release</localUri> folders.
            </para>
            <para>
              The 32-bit and 64-bit <userInput>make check</userInput> commands generate some warnings, but all tests passed successfully.
            </para>
          </listItem>
        </list>
      </content>
    </section>        
    
    <section>
      <title>Building the GNU MPFR Library for a Specific CPU Type on Windows</title>
      <content>
        <para>
          The <userInput>--enable-fat</userInput> build option above creates a library where optimized low level subroutines are chosen at runtime according to the CPU detected.
          By using instead the <userInput>--host</userInput> option, you can build a library for a specific CPU type.
          You will end up with a library that runs only on that CPU type, but the library will be samller.
          See the <externalLink><linkText>Build Options</linkText><linkUri>https://mpfrlib.org/manual/Build-Options.html#Build-Options/</linkUri><linkTarget>_self</linkTarget></externalLink> from the GNU MPFR Manual for the supported CPU types.
        </para>
      </content>
    </section>        
    
    <section>
      <title>Using the GNU MPFR Library in a Visual Studio C++ Project</title>
      <content>
        <para>
          Although our main goal was to compile GNU MPFR in order to use it from .NET, the compiled 32-bit and 64-bit GNU MPFR libraries may be used directly in Visual Studio C++ projects.
          For example, create a default Visual Studio C++ Console Application.
          Set the <system>Platform</system> to <system>x64</system>.
          Copy from the <localUri>C:\Temp\x64</localUri> folder the files <localUri>include\mpfr.h</localUri>, <localUri>bin\libmpfr-4.dll</localUri>, and <localUri>lib\libmpfr.dll.a</localUri> to the Visual Studio C++ project folder.
          Include <localUri>mpfr.h</localUri> in your C++ source file.
          In the <system>Linker</system>, <system>Input Property Page</system> of the project, add <localUri>libmpfr.dll.a</localUri> to the <system>Additional Dependencies</system>.
          Build your C++ project, and copy <localUri>libmpfr-4.dll</localUri> to the output <localUri>bin</localUri> folder.
          Run your application.
        </para>
        <para>
          See <externalLink><linkText>ConsoleApplication12.zip</linkText><linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native/blob/master/Math.Mpfr.Native/Dependencies/</linkUri><linkTarget>_self</linkTarget></externalLink>
          for a sample Visual Studio C++ project.
        </para>
      </content>
    </section>        
    
		<relatedTopics>
      <externalLink>
        <linkText>MSYS2</linkText>
        <linkUri>https://github.com/msys2/msys2/wiki/MSYS2-introduction</linkUri>
        <linkTarget>_self</linkTarget>
      </externalLink>
      <externalLink>
        <linkText>yasm</linkText>
        <linkUri>http://yasm.tortall.net/Download.html</linkUri>
        <linkTarget>_self</linkTarget>
      </externalLink>
      <externalLink>
        <linkText>GNU MPFR</linkText>
        <linkUri>https://mpfrlib.org/</linkUri>
        <linkTarget>_self</linkTarget>
      </externalLink>
      <externalLink>
        <linkText>Math.Mpfr.Native on GitHub</linkText>
        <linkUri>https://github.com/MachineCognitis/Math.Mpfr.Native</linkUri>
        <linkTarget>_self</linkTarget>
      </externalLink>
    </relatedTopics>
	
  </developerConceptualDocument>
</topic>
