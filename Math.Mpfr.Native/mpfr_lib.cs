
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using System.Runtime.ConstrainedExecution;
using System.Security;
using Math.Gmp.Native;

namespace Math.Mpfr.Native
{

    /// <summary>
    /// Represents all of the functions of the GNU MPFR library.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <h2>Functions Categories</h2>
    /// </para>
    /// <para><a name="Initialization_Functions"/><h3>Initialization Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_clear">mpfr_clear</see> - Free the space occupied by the significand of <i>x</i>.</description></item>
    /// <item><description><see cref="mpfr_clears">mpfr_clears</see> - Free the space occupied by all the <see cref="mpfr_t">mpfr_t</see> variables of the given list <i>x</i>.</description></item>
    /// <item><description><see cref="mpfr_get_default_prec">mpfr_get_default_prec</see> - Return the current default MPFR precision in bits.</description></item>
    /// <item><description><see cref="mpfr_get_prec">mpfr_get_prec</see> - Return the precision of <i>x</i>, i.e., the number of bits used to store its significand.</description></item>
    /// <item><description><see cref="mpfr_init">mpfr_init</see> - Initialize <i>x</i>, set its precision to the default precision, and set its value to NaN.</description></item>
    /// <item><description><see cref="mpfr_init2">mpfr_init2</see> - Initialize <i>x</i>, set its precision to be exactly <i>prec</i> bits and its value to NaN.</description></item>
    /// <item><description><see cref="mpfr_inits">mpfr_inits</see> - Initialize all the <see cref="mpfr_t">mpfr_t</see> variables of the given list <i>x</i>, set their precision to the default precision and their value to NaN.</description></item>
    /// <item><description><see cref="mpfr_inits2">mpfr_inits2</see> - Initialize all the <see cref="mpfr_t">mpfr_t</see> variables of the given variable argument <i>x</i>, set their precision to be exactly <i>prec</i> bits and their value to NaN.</description></item>
    /// <item><description><see cref="mpfr_set_default_prec">mpfr_set_default_prec</see> - Set the default precision to be exactly <i>prec</i> bits, where <i>prec</i> can be any integer between <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see>and <see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see>.</description></item>
    /// <item><description><see cref="mpfr_set_prec">mpfr_set_prec</see> - Reset the precision of <i>x</i> to be exactly <i>prec</i> bits, and set its value to NaN.</description></item>
    /// </list>
    /// <para><a name="Assignment_Functions"/><h3>Assignment Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_set">mpfr_set</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_d">mpfr_set_d</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_f">mpfr_set_f</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_flt">mpfr_set_flt</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_inf">mpfr_set_inf</see> - Set the variable <i>x</i> to infinity.</description></item>
    /// <item><description><see cref="mpfr_set_nan">mpfr_set_nan</see> - Set the variable <i>x</i> to NaN.</description></item>
    /// <item><description><see cref="mpfr_set_q">mpfr_set_q</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_si">mpfr_set_si</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_si_2exp">mpfr_set_si_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_sj">mpfr_set_sj</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_str">mpfr_set_str</see> - Set <i>rop</i> to the value of the string <i>s</i> in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_ui">mpfr_set_ui</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_uj">mpfr_set_uj</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_z">mpfr_set_z</see> - Set the value of <i>rop</i> from <i>op</i> rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_z_2exp">mpfr_set_z_2exp</see> - Set the value of <i>rop</i> from <i>op</i> multiplied by two to the power <i>e</i>, rounded toward the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_set_zero">mpfr_set_zero</see> - Set the variable <i>x</i> to zero.</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">mpfr_strtofr</see> - Read a floating-point number from a string <i>nptr</i> in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_swap">mpfr_swap</see> - Swap the structures pointed to by <i>x</i> and <i>y</i>.</description></item>
    /// </list>
    /// <para><a name="Combined_Initialization_and_Assignment_Functions"/><h3>Combined Initialization and Assignment Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_init_set">mpfr_init_set</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_d">mpfr_init_set_d</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_f">mpfr_init_set_f</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_q">mpfr_init_set_q</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_si">mpfr_init_set_si</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_str">mpfr_init_set_str</see> - Initialize <i>x</i> and set its value from the string <i>s</i> in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_ui">mpfr_init_set_ui</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_init_set_z">mpfr_init_set_z</see> - Initialize <i>rop</i> and set its value from <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// </list>
    /// <para><a name="Conversion_Functions"/><h3>Conversion Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</see> - Return non-zero if <i>op</i> would fit in the C data type  long when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_sint_p">mpfr_fits_sint_p</see> - Return non-zero if <i>op</i> would fit in the C data type  int when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_slong_p">mpfr_fits_slong_p</see> - Return non-zero if <i>op</i> would fit in the C data type  long when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</see> - Return non-zero if <i>op</i> would fit in the C data type  short when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_uint_p">mpfr_fits_uint_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned int when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned long when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned long when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</see> - Return non-zero if <i>op</i> would fit in the C data type  unsigned short when rounded to an integer in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_free_str">mpfr_free_str</see> - Free a string allocated by <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str</see> using the unallocation function .</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp">mpfr_frexp</see> - Set <i>exp</i> and <i>y</i> such that 0.5 &#8804; abs &lt; 1 and <i>y</i> * 2^<i>exp</i> = <i>x</i> rounded to the precision of <i>y</i>, using the given rounding mode.</description></item>
    /// <item><description><see cref="mpfr_get_d">mpfr_get_d</see> - Convert <i>op</i> to a double, using the rounding mode <i>rnd</i>.</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp">mpfr_get_d_2exp</see> - Return d and set <i>exp</i> such that 0.5 &#8804; abs &lt;1 and d * 2^<i>exp</i> = <i>op</i> rounded to double precision, using the given rounding mode.</description></item>
    /// <item><description><see cref="mpfr_get_f">mpfr_get_f</see> - Convert <i>op</i> to a <see cref="mpf_t">mpf_t</see>, after rounding it with respect to <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_get_flt">mpfr_get_flt</see> - Convert <i>op</i> to a float, using the rounding mode <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_get_si">mpfr_get_si</see> - Convert <i>op</i> to a long after rounding it with respect to <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_get_sj">mpfr_get_sj</see> - Convert <i>op</i> to an <see cref="intmax_t">intmax_t</see> after rounding it with respect to <i>rnd</i>.</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">mpfr_get_str</see> - Convert <i>op</i> to a string of digits in base <i>b</i>, with rounding in the direction <i>rnd</i>, where <i>n</i> is either zero  or the number of significant digits output in the string; in the latter case, <i>n</i> must be greater or equal to 2.</description></item>
    /// <item><description><see cref="mpfr_get_ui">mpfr_get_ui</see> - Convert <i>op</i> to an unsigned long after rounding it with respect to <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_get_uj">mpfr_get_uj</see> - Convert <i>op</i> to an <see cref="uintmax_t">uintmax_t</see> after rounding it with respect to <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_get_z">mpfr_get_z</see> - Convert <i>op</i> to a <see cref="mpz_t">mpz_t</see>, after rounding it with respect to <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_get_q">mpfr_get_q</see> - Convert <i>op</i> to a <see cref="mpq_t"/>.</description></item>
    /// <item><description><see cref="mpfr_get_z_2exp">mpfr_get_z_2exp</see> - Put the scaled significand of <i>op</i>  into <i>rop</i>, and return the exponent exp  such that <i>op</i> = <i>rop</i> * 2^exp.</description></item>
    /// </list>
    /// <para><a name="Basic_Arithmetic_Functions"/><h3>Basic Arithmetic Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_abs">mpfr_abs</see> - Set <i>rop</i> to the absolute value of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_add">mpfr_add</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_add_d">mpfr_add_d</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_add_q">mpfr_add_q</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_add_si">mpfr_add_si</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_add_ui">mpfr_add_ui</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_add_z">mpfr_add_z</see> - Set <i>rop</i> to <i>op1</i> + <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_cbrt">mpfr_cbrt</see> - Set <i>rop</i> to the cubic root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_rootn_ui">mpfr_rootn_ui</see> - Set <i>rop</i> to the <i>k</i>th root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_d_div">mpfr_d_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_d_sub">mpfr_d_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_dim">mpfr_dim</see> - Set <i>rop</i> to the positive difference of <i>op1</i> and <i>op2</i>, i.e., <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i> if <i>op1</i> &gt; <i>op2</i>, +0 if <i>op1</i> &#8804; <i>op2</i>, and NaN if <i>op1</i> or <i>op2</i> is NaN.</description></item>
    /// <item><description><see cref="mpfr_div">mpfr_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_2si">mpfr_div_2si</see> - Set <i>rop</i> to <i>op1</i> divided by 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_2ui">mpfr_div_2ui</see> - Set <i>rop</i> to <i>op1</i> divided by 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_d">mpfr_div_d</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_q">mpfr_div_q</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_si">mpfr_div_si</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_ui">mpfr_div_ui</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_div_z">mpfr_div_z</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul">mpfr_mul</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_2si">mpfr_mul_2si</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_2ui">mpfr_mul_2ui</see> - Set <i>rop</i> to <i>op1</i> * 2^<i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_d">mpfr_mul_d</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_q">mpfr_mul_q</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_si">mpfr_mul_si</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_ui">mpfr_mul_ui</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_mul_z">mpfr_mul_z</see> - Set <i>rop</i> to <i>op1</i> * <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_neg">mpfr_neg</see> - Set <i>rop</i> to -<i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_pow">mpfr_pow</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_pow_si">mpfr_pow_si</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_pow_ui">mpfr_pow_ui</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_pow_z">mpfr_pow_z</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_rec_sqrt">mpfr_rec_sqrt</see> - Set <i>rop</i> to the reciprocal square root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_root">mpfr_root</see> - Set <i>rop</i> to the <i>k</i>th root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_si_div">mpfr_si_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_si_sub">mpfr_si_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sqr">mpfr_sqr</see> - Set <i>rop</i> to the square of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sqrt">mpfr_sqrt</see> - Set <i>rop</i> to the square root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sqrt_ui">mpfr_sqrt_ui</see> - Set <i>rop</i> to the square root of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sub">mpfr_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sub_d">mpfr_sub_d</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sub_q">mpfr_sub_q</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sub_si">mpfr_sub_si</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sub_ui">mpfr_sub_ui</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sub_z">mpfr_sub_z</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sum">mpfr_sum</see> - Set <i>rop</i> to the sum of all elements of <i>tab</i>, whose size is <i>n</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_ui_div">mpfr_ui_div</see> - Set <i>rop</i> to <i>op1</i> / <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_ui_pow">mpfr_ui_pow</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</see> - Set <i>rop</i> to <i>op1</i> raised to <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_ui_sub">mpfr_ui_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_z_sub">mpfr_z_sub</see> - Set <i>rop</i> to <i>op1</i> - <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// </list>
    /// <para><a name="Comparison_Functions"/><h3>Comparison Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_cmp">mpfr_cmp</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_d">mpfr_cmp_d</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_f">mpfr_cmp_f</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_q">mpfr_cmp_q</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_si">mpfr_cmp_si</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</see> - Compare <i>op1</i> and <i>op2</i> * 2^<i>e</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_ui">mpfr_cmp_ui</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</see> - Compare <i>op1</i> and <i>op2</i> * 2^<i>e</i>.</description></item>
    /// <item><description><see cref="mpfr_cmp_z">mpfr_cmp_z</see> - Compare <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_cmpabs">mpfr_cmpabs</see> - Compare |<i>op1</i>| and |<i>op2</i>|.</description></item>
    /// <item><description><see cref="mpfr_equal_p">mpfr_equal_p</see> - Return non-zero if <i>op1</i> = <i>op2</i>, and zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_greater_p">mpfr_greater_p</see> - Return non-zero if <i>op1</i> &gt; <i>op2</i>, and zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_greaterequal_p">mpfr_greaterequal_p</see> - Return non-zero if <i>op1</i> &#8805; <i>op2</i>, and zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_inf_p">mpfr_inf_p</see> - Return non-zero if <i>op</i> is an infinity. Return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_less_p">mpfr_less_p</see> - Return non-zero if <i>op1</i> &lt; <i>op2</i>, and zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_lessequal_p">mpfr_lessequal_p</see> - Return non-zero if <i>op1</i> &#8804; <i>op2</i>, and zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_lessgreater_p">mpfr_lessgreater_p</see> - Return non-zero if <i>op1</i> &lt; <i>op2</i> or <i>op1</i> &gt; <i>op2</i> , zero otherwise .</description></item>
    /// <item><description><see cref="mpfr_nan_p">mpfr_nan_p</see> - Return non-zero if <i>op</i> is NaN. Return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_number_p">mpfr_number_p</see> - Return non-zero if <i>op</i> is an ordinary number . Return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_regular_p">mpfr_regular_p</see> - Return non-zero if <i>op</i> is a regular number . Return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_sgn">mpfr_sgn</see> - Return a positive value if <i>op</i> &gt; 0, zero if <i>op</i> = 0, and a negative value if <i>op</i> &lt; 0.</description></item>
    /// <item><description><see cref="mpfr_unordered_p">mpfr_unordered_p</see> - Return non-zero if <i>op1</i> or <i>op2</i> is a NaN , zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_zero_p">mpfr_zero_p</see> - Return non-zero if <i>op</i> is zero. Return zero otherwise.</description></item>
    /// </list>
    /// <para><a name="Special_Functions"/><h3>Special Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_acos">mpfr_acos</see> - Set <i>rop</i> to the arc-cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_acosh">mpfr_acosh</see> - Set <i>rop</i> to the inverse hyperbolic cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_agm">mpfr_agm</see> - Set <i>rop</i> to the arithmetic-geometric mean of <i>op1</i> and <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_ai">mpfr_ai</see> - Set <i>rop</i> to the value of the Airy function Ai on <i>x</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_asin">mpfr_asin</see> - Set <i>rop</i> to the arc-sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_asinh">mpfr_asinh</see> - Set <i>rop</i> to the inverse hyperbolic sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_atan">mpfr_atan</see> - Set <i>rop</i> to the arc-tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_atan2">mpfr_atan2</see> - Set <i>rop</i> to the arc-tangent2 of <i>y</i> and <i>x</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_atanh">mpfr_atanh</see> - Set <i>rop</i> to the inverse hyperbolic tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_const_catalan">mpfr_const_catalan</see> - Set <i>rop</i> to the value of Catalan’s constant 0.915… rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_const_euler">mpfr_const_euler</see> - Set <i>rop</i> to the value of Euler’s constant 0.577… rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_const_log2">mpfr_const_log2</see> - Set <i>rop</i> to the logarithm of 2 rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_const_pi">mpfr_const_pi</see> - Set <i>rop</i> to the value of Pi rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_cos">mpfr_cos</see> - Set <i>rop</i> to the cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_cosh">mpfr_cosh</see> - Set <i>rop</i> to the hyperbolic cosine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_cot">mpfr_cot</see> - Set <i>rop</i> to the cotangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_coth">mpfr_coth</see> - Set <i>rop</i> to the hyperbolic cotangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_csc">mpfr_csc</see> - Set <i>rop</i> to the cosecant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_csch">mpfr_csch</see> - Set <i>rop</i> to the hyperbolic cosecant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_digamma">mpfr_digamma</see> - Set <i>rop</i> to the value of the Digamma  function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_eint">mpfr_eint</see> - Set <i>rop</i> to the exponential integral of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_erf">mpfr_erf</see> - Set <i>rop</i> to the value of the error function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_erfc">mpfr_erfc</see> - Set <i>rop</i> to the value of the complementary error function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_exp">mpfr_exp</see> - Set <i>rop</i> to the exponential of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_exp10">mpfr_exp10</see> - Set <i>rop</i> to 10^<i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_exp2">mpfr_exp2</see> - Set <i>rop</i> to 2^<i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_expm1">mpfr_expm1</see> - Set <i>rop</i> to the e^<i>op</i> - 1, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fac_ui">mpfr_fac_ui</see> - Set <i>rop</i> to the factorial of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fma">mpfr_fma</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) + <i>op3</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fms">mpfr_fms</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) - <i>op3</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fmma">mpfr_fmma</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) + (<i>op3</i> × <i>op4</i>) rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fmms">mpfr_fmms</see> - Set <i>rop</i> to (<i>op1</i> × <i>op2</i>) - (<i>op3</i> × <i>op4</i>) rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_free_cache">mpfr_free_cache</see> - Free all caches and pools used by MPFR internally.</description></item>
    /// <item><description><see cref="mpfr_free_cache2">mpfr_free_cache2</see> - Free various caches and pools used by MPFR internally, as specified by <i>way</i>, which is a set of flags.</description></item>
    /// <item><description><see cref="mpfr_free_pool">mpfr_free_pool</see> - Free the pools used by MPFR internally.</description></item>
    /// <item><description><see cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</see> - This function should be called before calling <see cref="gmp_lib.mp_set_memory_functions"/>.</description></item>
    /// <item><description><see cref="mpfr_gamma">mpfr_gamma</see> - Set <i>rop</i> to the value of the Gamma function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_gamma_inc">mpfr_gamma_inc</see> - Set <i>rop</i> to the value of the Incomplete Gamma function on <i>op</i> and <i>op2</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_beta">mpfr_beta</see> - Set <i>rop</i> to the value of the Beta function at arguments <i>op1</i> and <i>op2</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_hypot">mpfr_hypot</see> - Set <i>rop</i> to the Euclidean norm of <i>x</i> and <i>y</i>, i.e., the square root of the sum of the squares of <i>x</i> and <i>y</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_j0">mpfr_j0</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 0 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_j1">mpfr_j1</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 1 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_jn">mpfr_jn</see> - Set <i>rop</i> to the value of the first kind Bessel function of order <i>n</i> on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma">mpfr_lgamma</see> - Set <i>rop</i> to the value of the logarithm of the absolute value of the Gamma function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_li2">mpfr_li2</see> - Set <i>rop</i> to real part of the dilogarithm of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_lngamma">mpfr_lngamma</see> - Set <i>rop</i> to the value of the logarithm of the Gamma function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_log">mpfr_log</see> - Set <i>rop</i> to the natural logarithm of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_log_ui">mpfr_log_ui</see> - Set <i>rop</i> to the natural logarithm of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_log10">mpfr_log10</see> - Set <i>rop</i> to log10 rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_log1p">mpfr_log1p</see> - Set <i>rop</i> to the logarithm of one plus <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_log2">mpfr_log2</see> - Set <i>rop</i> to log2 rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sec">mpfr_sec</see> - Set <i>rop</i> to the secant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sech">mpfr_sech</see> - Set <i>rop</i> to the hyperbolic secant of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sin">mpfr_sin</see> - Set <i>rop</i> to the sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sin_cos">mpfr_sin_cos</see> - Set simultaneously <i>sop</i> to the sine of <i>op</i> and <i>cop</i> to the cosine of <i>op</i>, rounded in the direction <i>rnd</i> with the corresponding precisions of <i>sop</i> and <i>cop</i>, which must be different variables.</description></item>
    /// <item><description><see cref="mpfr_sinh">mpfr_sinh</see> - Set <i>rop</i> to the hyperbolic sine of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_sinh_cosh">mpfr_sinh_cosh</see> - Set simultaneously <i>sop</i> to the hyperbolic sine of <i>op</i> and <i>cop</i> to the hyperbolic cosine of <i>op</i>, rounded in the direction <i>rnd</i> with the corresponding precision of <i>sop</i> and <i>cop</i>, which must be different variables.</description></item>
    /// <item><description><see cref="mpfr_tan">mpfr_tan</see> - Set <i>rop</i> to the tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_tanh">mpfr_tanh</see> - Set <i>rop</i> to the hyperbolic tangent of <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_y0">mpfr_y0</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 0 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_y1">mpfr_y1</see> - Set <i>rop</i> to the value of the first kind Bessel function of order 1 on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_yn">mpfr_yn</see> - Set <i>rop</i> to the value of the first kind Bessel function of order <i>n</i> on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_zeta">mpfr_zeta</see> - Set <i>rop</i> to the value of the Riemann Zeta function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_zeta_ui">mpfr_zeta_ui</see> - Set <i>rop</i> to the value of the Riemann Zeta function on <i>op</i> rounded in the direction <i>rnd</i>.</description></item>
    /// </list>
    /// <para><a name="Input_and_Output_Functions"/><h3>Input and Output Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_inp_str">mpfr_inp_str</see> - Input a string in base <i>base</i> from stream <i>stream</i>, rounded in the direction <i>rnd</i>, and put the read float in <i>rop</i>.</description></item>
    /// <item><description><see cref="mpfr_out_str">mpfr_out_str</see> - Output <i>op</i> on stream <i>stream</i>, as a string of digits in base <i>base</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_fpif_import">mpfr_fpif_import</see> - Import the number <i>op</i> from the stream <i>stream</i> in a floating-point interchange format (see <see cref="mpfr_fpif_export"/>).</description></item>
    /// <item><description><see cref="mpfr_fpif_export">mpfr_fpif_export</see> - Export the number <i>op</i> to the stream <i>stream</i> in a floating-point interchange format.</description></item>
    /// </list>
    /// <para><a name="Formatted_Output_Functions"/><h3>Formatted Output Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_asprintf">mpfr_asprintf</see> - Write output as a null terminated string in a block of memory allocated using the allocation function .</description></item>
    /// <item><description><see cref="mpfr_fprintf">mpfr_fprintf</see> - Print to the stream <i>stream</i> the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
    /// <item><description><see cref="mpfr_printf">mpfr_printf</see> - Print to stdout the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
    /// <item><description><see cref="mpfr_snprintf">mpfr_snprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
    /// <item><description><see cref="mpfr_sprintf">mpfr_sprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf">mpfr_vasprintf</see> - Write output as a null terminated string in a block of memory allocated using the allocation function .</description></item>
    /// <item><description><see cref="mpfr_vfprintf">mpfr_vfprintf</see> - Print to the stream <i>stream</i> the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
    /// <item><description><see cref="mpfr_vprintf">mpfr_vprintf</see> - Print to stdout the optional <i>arguments</i> under the control of the template string <i>template</i>.</description></item>
    /// <item><description><see cref="mpfr_vsnprintf">mpfr_vsnprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
    /// <item><description><see cref="mpfr_vsprintf">mpfr_vsprintf</see> - Form a null-terminated string corresponding to the optional <i>arguments</i> under the control of the template string <i>template</i>, and print it in <i>buf</i>.</description></item>
    /// </list>
    /// <para><a name="Integer_and_Remainder_Related_Functions"/><h3>Integer and Remainder Related Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_ceil">mpfr_ceil</see> - Set <i>rop</i> to <i>op</i> rounded to the next higher or equal representable integer (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDU"/>).</description></item>
    /// <item><description><see cref="mpfr_floor">mpfr_floor</see> - Set <i>rop</i> to <i>op</i> rounded to the next lower or equal representable integer (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDD"/>).</description></item>
    /// <item><description><see cref="mpfr_fmod">mpfr_fmod</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded toward zero.</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmodquo</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded toward zero.</description></item>
    /// <item><description><see cref="mpfr_frac">mpfr_frac</see> - Set <i>rop</i> to the fractional part of <i>op</i>, having the same sign as <i>op</i>, rounded in the direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_integer_p">mpfr_integer_p</see> - Return non-zero iff <i>op</i> is an integer.</description></item>
    /// <item><description><see cref="mpfr_modf">mpfr_modf</see> - Set simultaneously <i>iop</i> to the integral part of <i>op</i> and <i>fop</i> to the fractional part of <i>op</i>, rounded in the direction <i>rnd</i> with the corresponding precision of <i>iop</i> and <i>fop</i>.</description></item>
    /// <item><description><see cref="mpfr_remainder">mpfr_remainder</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded to the nearest integer .</description></item>
    /// <item><description><see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">mpfr_remquo</see> - Set <i>r</i> to the value of <i>x</i> - n * <i>y</i>, rounded according to the direction <i>rnd</i>, where n is the integer quotient of <i>x</i> divided by <i>y</i>, rounded to the nearest integer .</description></item>
    /// <item><description><see cref="mpfr_rint">mpfr_rint</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer in the given direction <i>rnd</i>.</description></item>
    /// <item><description><see cref="mpfr_rint_ceil">mpfr_rint_ceil</see> - Set <i>rop</i> to <i>op</i> rounded to the next higher or equal integer.</description></item>
    /// <item><description><see cref="mpfr_rint_floor">mpfr_rint_floor</see> - Set <i>rop</i> to <i>op</i> rounded to the next lower or equal integer.</description></item>
    /// <item><description><see cref="mpfr_rint_round">mpfr_rint_round</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest integer, rounding halfway cases away from zero.</description></item>
    /// <item><description><see cref="mpfr_rint_roundeven">mpfr_rint_roundeven</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest integer, rounding halfway cases to the nearest even integer.</description></item>
    /// <item><description><see cref="mpfr_rint_trunc">mpfr_rint_trunc</see> - Set <i>rop</i> to <i>op</i> rounded to the next integer toward zero.</description></item>
    /// <item><description><see cref="mpfr_round">mpfr_round</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer, rounding halfway cases away from zero.</description></item>
    /// <item><description><see cref="mpfr_roundeven">mpfr_roundeven</see> - Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer, rounding halfway cases with the even-rounding rule zero (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDZ"/>).</description></item>
    /// <item><description><see cref="mpfr_trunc">mpfr_trunc</see> - Set <i>rop</i> to <i>op</i> rounded to the next representable integer toward zero (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDZ"/>).</description></item>
    /// </list>
    /// <para><a name="Rounding_Related_Functions"/><h3>Rounding Related Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_can_round">mpfr_can_round</see> - Return non-zero value if one is able to round correctly x to precision <i>prec</i> with the direction <i>rnd2</i>, and 0 otherwise.</description></item>
    /// <item><description><see cref="mpfr_get_default_rounding_mode">mpfr_get_default_rounding_mode</see> - Get the default rounding mode.</description></item>
    /// <item><description><see cref="mpfr_min_prec">mpfr_min_prec</see> - Return the minimal number of bits required to store the significand of <i>x</i>, and 0 for special values, including 0.</description></item>
    /// <item><description><see cref="mpfr_prec_round">mpfr_prec_round</see> - Round <i>x</i> according to <i>rnd</i> with precision <i>prec</i>, which must be an integer between <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see> and <see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see>.</description></item>
    /// <item><description><see cref="mpfr_print_rnd_mode">mpfr_print_rnd_mode</see> - Return a string  corresponding to the rounding mode <i>rnd</i>, or a null pointer if <i>rnd</i> is an invalid rounding mode.</description></item>
    /// <item><description><see cref="mpfr_set_default_rounding_mode">mpfr_set_default_rounding_mode</see> - Set the default rounding mode to <i>rnd</i>.</description></item>
    /// </list>
    /// <para><a name="Miscellaneous_Functions"/><h3>Miscellaneous Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</see> - Return a non-zero value if MPFR was compiled with decimal float support, return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</see> - Return a non-zero value if MPFR was compiled with GMP internals, return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_buildopt_sharedcache_p ">mpfr_buildopt_sharedcache_p </see> - Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant, return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</see> - Return a non-zero value if MPFR was compiled as thread safe using compiler-level Thread Local Storage, return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</see> - Return a non-zero value if MPFR was compiled with ‘__float128’ support, return zero otherwise.</description></item>
    /// <item><description><see cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</see> - Return a string saying which thresholds file has been used at compile time.</description></item>
    /// <item><description><see cref="mpfr_copysign">mpfr_copysign</see> - Set the value of <i>rop</i> from <i>op1</i>, rounded toward the given direction <i>rnd</i>, then set its sign bit to that of <i>op2</i> .</description></item>
    /// <item><description><see cref="mpfr_get_patches">mpfr_get_patches</see> - Return a null-terminated string containing the ids of the patches applied to the MPFR library , separated by spaces.</description></item>
    /// <item><description><see cref="mpfr_get_version">mpfr_get_version</see> - Return the MPFR version, as a null-terminated string.</description></item>
    /// <item><description><see cref="mpfr_nrandom">mpfr_nrandom</see> - Generate one random float according to a standard normal gaussian distribution (with mean zero and variance one).</description></item>
    /// <item><description><see cref="mpfr_grandom">mpfr_grandom</see> - Generate two random floats according to a standard normal gaussian distribution (with mean zero and variance one).</description></item>
    /// <item><description><see cref="mpfr_erandom">mpfr_erandom</see> - Generate one random float according to an exponential distribution, with mean one.</description></item>
    /// <item><description><see cref="mpfr_max">mpfr_max</see> - Set <i>rop</i> to the maximum of <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_min">mpfr_min</see> - Set <i>rop</i> to the minimum of <i>op1</i> and <i>op2</i>.</description></item>
    /// <item><description><see cref="mpfr_nextabove">mpfr_nextabove</see> - Equivalent to <see cref="mpfr_nexttoward">mpfr_nexttoward</see> where y is plus infinity.</description></item>
    /// <item><description><see cref="mpfr_nextbelow">mpfr_nextbelow</see> - Equivalent to <see cref="mpfr_nexttoward">mpfr_nexttoward</see> where y is minus infinity.</description></item>
    /// <item><description><see cref="mpfr_nexttoward">mpfr_nexttoward</see> - Replace <i>x</i> by the next floating-point number in the direction of <i>y</i>.</description></item>
    /// <item><description><see cref="mpfr_set_exp">mpfr_set_exp</see> - Set the exponent of <i>x</i> if <i>e</i> is in the current exponent range.</description></item>
    /// <item><description><see cref="mpfr_setsign">mpfr_setsign</see> - Set the value of <i>rop</i> from <i>op</i>, rounded toward the given direction <i>rnd</i>, then set  its sign bit if <i>s</i> is non-zero , even when <i>op</i> is a NaN.</description></item>
    /// <item><description><see cref="mpfr_signbit">mpfr_signbit</see> - Return a non-zero value iff <i>op</i> has its sign bit set .</description></item>
    /// <item><description><see cref="mpfr_urandom">mpfr_urandom</see> - Generate a uniformly distributed random float.</description></item>
    /// <item><description><see cref="mpfr_urandomb">mpfr_urandomb</see> - Generate a uniformly distributed random float in the interval 0 &#8804; <i>rop</i> &lt; 1.</description></item>
    /// <item><description><see cref="MPFR_VERSION">MPFR_VERSION</see> - <see cref="MPFR_VERSION">MPFR_VERSION</see> is the version of MPFR.</description></item>
    /// <item><description><see cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</see> - <see cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</see> is the major MPFR version.</description></item>
    /// <item><description><see cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</see> - <see cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</see> is the minor MPFR version.</description></item>
    /// <item><description><see cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</see> - Create an integer in the same format as used by <see cref="MPFR_VERSION">MPFR_VERSION</see> from the given <i>major</i>, <i>minor</i> and <i>patchlevel</i>.</description></item>
    /// <item><description><see cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</see> - <see cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</see> is the patch level of MPFR version.</description></item>
    /// <item><description><see cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</see> - <see cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</see> is the version  as a string constant.</description></item>
    /// <item><description><see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see> - The maximum number of bits that can be used to represent the significand of a floating-point number.</description></item>
    /// <item><description><see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see> - The minimum number of bits that can be used to represent the significand of a floating-point number.</description></item>
    /// </list>
    /// <para><a name="Exception_Related_Functions"/><h3>Exception Related Functions:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_check_range">mpfr_check_range</see> - Check that <i>x</i> is within the current range of acceptable values.</description></item>
    /// <item><description><see cref="mpfr_clear_divby0">mpfr_clear_divby0</see> - Clear (lower) the divide-by-zero flag.</description></item>
    /// <item><description><see cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</see> - Clear (lower) the erange flag.</description></item>
    /// <item><description><see cref="mpfr_clear_flags">mpfr_clear_flags</see> - Clear (lower) all global flags .</description></item>
    /// <item><description><see cref="mpfr_clear_inexflag">mpfr_clear_inexflag</see> - Clear (lower) the inexact flag.</description></item>
    /// <item><description><see cref="mpfr_clear_nanflag">mpfr_clear_nanflag</see> - Clear (lower) the invalid flag.</description></item>
    /// <item><description><see cref="mpfr_clear_overflow">mpfr_clear_overflow</see> - Clear (lower) the overflow flag.</description></item>
    /// <item><description><see cref="mpfr_clear_underflow">mpfr_clear_underflow</see> - Clear (lower) the underflow flag.</description></item>
    /// <item><description><see cref="mpfr_divby0_p">mpfr_divby0_p</see> - Return the divide-by-zero flag, which is non-zero iff the flag is set.</description></item>
    /// <item><description><see cref="mpfr_erangeflag_p">mpfr_erangeflag_p</see> - Return the erange flag, which is non-zero iff the flag is set.</description></item>
    /// <item><description><see cref="mpfr_get_emax">mpfr_get_emax</see> - Return the  largest exponent allowed for a floating-point variable.</description></item>
    /// <item><description><see cref="mpfr_get_emax_max">mpfr_get_emax_max</see> - Return the maximum exponent allowed for <see cref="mpfr_set_emax">mpfr_set_emax</see>.</description></item>
    /// <item><description><see cref="mpfr_get_emax_min">mpfr_get_emax_min</see> - Return the minimum exponent allowed for <see cref="mpfr_set_emax">mpfr_set_emax</see>.</description></item>
    /// <item><description><see cref="mpfr_get_emin">mpfr_get_emin</see> - Return the  smallest exponent allowed for a floating-point variable.</description></item>
    /// <item><description><see cref="mpfr_get_emin_max">mpfr_get_emin_max</see> - Return the maximum exponent allowed for <see cref="mpfr_set_emin">mpfr_set_emin</see>.</description></item>
    /// <item><description><see cref="mpfr_get_emin_min">mpfr_get_emin_min</see> - Return the minimum exponent allowed for <see cref="mpfr_set_emin">mpfr_set_emin</see>.</description></item>
    /// <item><description><see cref="mpfr_get_exp">mpfr_get_exp</see> - Return the exponent of <i>x</i>, assuming that <i>x</i> is a non-zero ordinary number and the significand is considered in [1/2,1).</description></item>
    /// <item><description><see cref="mpfr_inexflag_p">mpfr_inexflag_p</see> - Return the inexact flag, which is non-zero iff the flag is set.</description></item>
    /// <item><description><see cref="mpfr_nanflag_p">mpfr_nanflag_p</see> - Return the invalid flag, which is non-zero iff the flag is set.</description></item>
    /// <item><description><see cref="mpfr_overflow_p">mpfr_overflow_p</see> - Return the overflow flag, which is non-zero iff the flag is set.</description></item>
    /// <item><description><see cref="mpfr_set_divby0">mpfr_set_divby0</see> - Set (raise) the divide-by-zero flag.</description></item>
    /// <item><description><see cref="mpfr_set_emax">mpfr_set_emax</see> - Set the largest exponent allowed for a floating-point variable.</description></item>
    /// <item><description><see cref="mpfr_set_emin">mpfr_set_emin</see> - Set the smallest exponent allowed for a floating-point variable.</description></item>
    /// <item><description><see cref="mpfr_set_erangeflag">mpfr_set_erangeflag</see> - Set (raise) the erange flag.</description></item>
    /// <item><description><see cref="mpfr_set_inexflag">mpfr_set_inexflag</see> - Set (raise) the inexact flag.</description></item>
    /// <item><description><see cref="mpfr_set_nanflag">mpfr_set_nanflag</see> - Set (raise) the invalid flag.</description></item>
    /// <item><description><see cref="mpfr_set_overflow">mpfr_set_overflow</see> - Set (raise) the overflow flag.</description></item>
    /// <item><description><see cref="mpfr_set_underflow">mpfr_set_underflow</see> - Set (raise) the underflow flag.</description></item>
    /// <item><description><see cref="mpfr_subnormalize">mpfr_subnormalize</see> - This function rounds <i>x</i> emulating subnormal number arithmetic.</description></item>
    /// <item><description><see cref="mpfr_underflow_p">mpfr_underflow_p</see> - Return the underflow flag, which is non-zero iff the flag is set.</description></item>
    /// <item><description><see cref="mpfr_flags_clear">mpfr_flags_clear</see> - Clear (lower) the group of flags specified by <i>mask</i>.</description></item>
    /// <item><description><see cref="mpfr_flags_set">mpfr_flags_set</see> - Set (raise) the group of flags specified by <i>mask</i>.</description></item>
    /// <item><description><see cref="mpfr_flags_test">mpfr_flags_test</see> - Return the flags specified by <i>mask</i>.</description></item>
    /// <item><description><see cref="mpfr_flags_save">mpfr_flags_save</see> - Return all the flags.</description></item>
    /// <item><description><see cref="mpfr_flags_restore">mpfr_flags_restore</see> = Restore the flags specified by <i>mask</i> to their state represented in <i>flags</i>.</description></item>
    /// </list>
    /// <para><a name="Compatibility_With_MPF"/><h3>Compatibility With MPF:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_div_2exp">mpfr_div_2exp</see> - This function is identical to <see cref="mpfr_div_2ui">mpfr_div_2ui</see>.</description></item>
    /// <item><description><see cref="mpfr_eq">mpfr_eq</see> - Return non-zero if <i>op1</i> and <i>op2</i> are both non-zero ordinary numbers with the same exponent and the same first <i>op3</i> bits.</description></item>
    /// <item><description><see cref="mpfr_mul_2exp">mpfr_mul_2exp</see> - This function is identical to <see cref="mpfr_mul_2ui">mpfr_mul_2ui</see>.</description></item>
    /// <item><description><see cref="mpfr_reldiff">mpfr_reldiff</see> - Compute the relative difference between <i>op1</i> and <i>op2</i> and store the result in <i>rop</i>.</description></item>
    /// <item><description><see cref="mpfr_set_prec_raw">mpfr_set_prec_raw</see> - Reset the precision of <i>x</i> to be exactly <i>prec</i> bits.</description></item>
    /// </list>
    /// <para><a name="Custom_Interface"/><h3>Custom Interface:</h3></para>
    /// <list type="bullet">
    /// <item><description><see cref="mpfr_custom_clear">mpfr_custom_clear</see> - Free the space occupied by <i>x</i>.</description></item>
    /// <item><description><see cref="mpfr_custom_get_exp">mpfr_custom_get_exp</see> - Return the exponent of <i>x</i>.</description></item>
    /// <item><description><see cref="mpfr_custom_get_kind">mpfr_custom_get_kind</see> - Return the current kind of a <see cref="mpfr_t">mpfr_t</see> as created by <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>.</description></item>
    /// <item><description><see cref="mpfr_custom_get_significand">mpfr_custom_get_significand</see> - Return a pointer to the significand used by a <see cref="mpfr_t">mpfr_t</see> initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>.</description></item>
    /// <item><description><see cref="mpfr_custom_get_size">mpfr_custom_get_size</see> - Return the needed size in bytes to store the significand of a floating-point number of precision <i>prec</i>.</description></item>
    /// <item><description><see cref="mpfr_custom_init">mpfr_custom_init</see> - Initialize a significand of precision <i>prec</i>.</description></item>
    /// <item><description><see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> - Perform a dummy initialization of a <see cref="mpfr_t">mpfr_t</see>.</description></item>
    /// <item><description><see cref="mpfr_custom_move">mpfr_custom_move</see> - Inform MPFR that the significand of <i>x</i> has moved due to a garbage collect and update its new position to <i>new_position</i>.</description></item>
    /// </list>
    /// </remarks>
    public static class mpfr_lib
    {

        // Safe handle to the loaded MPFR library.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        private static SafeHandle _mpfr_lib = new SafeHandle(_load_mpfr_lib());

        private static IntPtr _load_mpfr_lib()
        {
            // Load MPFR library based on current computer x86 or x64 architecture.
            string folderName = IntPtr.Size == 4 ? "x86" : "x64";
            // Get pathname of executing assembly.
            string codeBase = System.Reflection.Assembly.GetExecutingAssembly().EscapedCodeBase;
            // Get directory pathname of MPFR library.
            string libpath = System.IO.Path.GetDirectoryName(System.Uri.UnescapeDataString((new System.UriBuilder(codeBase)).Path)) + System.IO.Path.DirectorySeparatorChar + folderName;
            // Add MPFR library directory to DLL search paths.
            SafeNativeMethods.SetDllDirectory(libpath);
            // Load MPFR library and create safe handle to it.
            IntPtr handle = SafeNativeMethods.LoadLibrary(@"libmpfr-6.dll");
            // Retrieve and cache MPFR dynamic memory allocation functions.
            return handle;
        }

        /// <summary>
        /// The minimum number of bits that can be used to represent the significand of a floating-point number.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In the current implementation, <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see> is 1.
        /// </para>
        /// </remarks>
        /// <seealso cref="MPFR_PREC_MAX">MPFR_PREC_MAX</seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html">GNU MPFR</a></seealso>
        public static readonly mpfr_prec_t MPFR_PREC_MIN = 1;

        /// <summary>
        /// The maximum number of bits that can be used to represent the significand of a floating-point number.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In the current implementation, <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see> is 2,147,483,647.
        /// </para>
        /// </remarks>
        /// <seealso cref="MPFR_PREC_MIN">MPFR_PREC_MIN</seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html">GNU MPFR</a></seealso>
        public static readonly mpfr_prec_t MPFR_PREC_MAX = 2147483647;

        /// <summary>
        /// <see cref="MPFR_VERSION">MPFR_VERSION</see> is the version of MPFR.
        /// </summary>
        /// <seealso cref="mpfr_get_version">mpfr_get_version</seealso>
        /// <seealso cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
        /// <seealso cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
        /// <seealso cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
        /// <seealso cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
        /// <seealso cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        public static readonly int MPFR_VERSION = MPFR_VERSION_NUM(MPFR_VERSION_MAJOR, MPFR_VERSION_MINOR, MPFR_VERSION_PATCHLEVEL);

        /// <summary>
        /// <see cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</see> is the major MPFR version.
        /// </summary>
        /// <seealso cref="mpfr_get_version">mpfr_get_version</seealso>
        /// <seealso cref="MPFR_VERSION">MPFR_VERSION</seealso>
        /// <seealso cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
        /// <seealso cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
        /// <seealso cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
        /// <seealso cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        public static readonly int MPFR_VERSION_MAJOR = 4;

        /// <summary>
        /// <see cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</see> is the minor MPFR version.
        /// </summary>
        /// <seealso cref="mpfr_get_version">mpfr_get_version</seealso>
        /// <seealso cref="MPFR_VERSION">MPFR_VERSION</seealso>
        /// <seealso cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
        /// <seealso cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
        /// <seealso cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
        /// <seealso cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        public static readonly int MPFR_VERSION_MINOR = 0;

        /// <summary>
        /// <see cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</see> is the patch level of MPFR version.
        /// </summary>
        /// <seealso cref="mpfr_get_version">mpfr_get_version</seealso>
        /// <seealso cref="MPFR_VERSION">MPFR_VERSION</seealso>
        /// <seealso cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
        /// <seealso cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
        /// <seealso cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
        /// <seealso cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        public static readonly int MPFR_VERSION_PATCHLEVEL = 0;

        /// <summary>
        /// <see cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</see> is the version (with an optional suffix, used in development and pre-release versions) as a string constant.
        /// </summary>
        /// <seealso cref="mpfr_get_version">mpfr_get_version</seealso>
        /// <seealso cref="MPFR_VERSION">MPFR_VERSION</seealso>
        /// <seealso cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
        /// <seealso cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
        /// <seealso cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
        /// <seealso cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        public static readonly string MPFR_VERSION_STRING = "4.0.0";

        /// <summary>
        /// Create an integer in the same format as used by <see cref="MPFR_VERSION">MPFR_VERSION</see> from the given <paramref name="major"/>, <paramref name="minor"/> and <paramref name="patchlevel"/>. 
        /// </summary>
        /// <param name="major">The major version.</param>
        /// <param name="minor">The minor version.</param>
        /// <param name="patchlevel">The patch level.</param>
        /// <returns>An integer in the same format as used by <see cref="MPFR_VERSION">MPFR_VERSION</see> from the given <paramref name="major"/>, <paramref name="minor"/> and <paramref name="patchlevel"/>.</returns>
        /// <seealso cref="mpfr_get_version">mpfr_get_version</seealso>
        /// <seealso cref="MPFR_VERSION">MPFR_VERSION</seealso>
        /// <seealso cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
        /// <seealso cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
        /// <seealso cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
        /// <seealso cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        public static int MPFR_VERSION_NUM(int major, int minor, int patchlevel)
        {
            return (((major) << 16) | ((minor) << 8) | (patchlevel));
        }

        /// <summary>
        /// Output <paramref name="op"/> on stream <paramref name="stream"/>, as a string of digits in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="stream">The output stream.</param>
        /// <param name="base">The base.</param>
        /// <param name="n">Number of significant digits.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return the number of characters written, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// The base may vary from 2 to 62. 
        /// Print <paramref name="n"/> significant digits exactly, or if <paramref name="n"/> is 0,
        /// enough digits so that <paramref name="op"/> can be read back exactly (see <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str</see>). 
        /// </para>
        /// <para>
        /// In addition to the significant digits, a decimal point (defined by the current locale) at the right of
        /// the first digit and a trailing exponent in base 10, in the form ‘eNNN’, are printed.
        /// If <paramref name="base"/> is greater than 10, ‘@’ will be used instead of ‘e’ as exponent delimiter. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_inp_str">mpfr_inp_str</seealso>
        /// <seealso cref="mpfr_fpif_export">mpfr_fpif_export</seealso>
        /// <seealso cref="mpfr_fpif_import">mpfr_fpif_import</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Write op to temporary file, and assert that the number of bytes written is 24.
        /// Assert.IsTrue(mpfr_lib.mpfr_out_str(stream, 10, 0, op, mpfr_rnd_t.MPFR_RNDN) == 24);
        /// 
        /// // Close temporary file.
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that the content of the temporary file is "123456".
        /// string result = System.IO.File.ReadAllText(pathname);
        /// Assert.IsTrue(result == "1.23456000000000000000e5");
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123456.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Get a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName() 
        /// 
        /// ' Open temporary file for writing.
        /// Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname,"w")
        /// 
        /// ' Write op to temporary file, and assert that the number of bytes written is 24.
        /// Assert.IsTrue(mpfr_lib.mpfr_out_str(stream, 10, 0, op, mpfr_rnd_t.MPFR_RNDN) = 24)
        /// 
        /// ' Close temporary file.
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that the content of the temporary file is "123456".
        /// Dim result As String = System.IO.File.ReadAllText(pathname)
        /// Assert.IsTrue(result = "1.23456000000000000000e5")
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpfr_out_str(ptr<FILE> stream, int @base, size_t n, mpfr_t op, mpfr_rnd_t rnd)
        {
            if (IntPtr.Size == 4)
                return SafeNativeMethods.__gmpfr_out_str_x86(stream.Value.Value, @base, (uint)n, op.ToIntPtr(), (int)rnd);
            else
                return SafeNativeMethods.__gmpfr_out_str_x64(stream.Value.Value, @base, (ulong)n, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Input a string in base <paramref name="base"/> from stream <paramref name="stream"/>, rounded in the direction <paramref name="rnd"/>, and put the read float in <paramref name="rop"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="stream">The input stream.</param>
        /// <param name="base">The base.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// This function reads a word (defined as a sequence of characters between whitespace) and parses it using <see cref="mpfr_set_str">mpfr_set_str</see>.
        /// See the documentation of <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> for a detailed description of the valid string formats. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_out_str">mpfr_out_str</seealso>
        /// <seealso cref="mpfr_fpif_export">mpfr_fpif_export</seealso>
        /// <seealso cref="mpfr_fpif_import">mpfr_fpif_import</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize op.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// 
        /// // Write op to a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// System.IO.File.WriteAllText(pathname, "123456");
        /// 
        /// // Read op from the temporary file, and assert that the number of bytes read is 6.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpfr_inp_str(op, stream, 10, mpfr_rnd_t.MPFR_RNDN) == 6);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123456.
        ///  Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123456U);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize op.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// 
        /// ' Write op to a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// System.IO.File.WriteAllText(pathname, "123456")
        /// 
        /// ' Read op from the temporary file, and assert that the number of bytes read is 6.
        /// Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
        /// /// _wfopen_s(stream.Value.Value, pathname,"r")
        /// Assert.IsTrue(mpfr_lib.mpfr_inp_str(op, stream, 10, mpfr_rnd_t.MPFR_RNDN) = 6)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123456U)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpfr_inp_str(mpfr_t rop, ptr<FILE> stream, int @base, mpfr_rnd_t rnd)
        {
            if (IntPtr.Size == 4)
                return SafeNativeMethods.__gmpfr_inp_str_x86(rop.ToIntPtr(), stream.Value.Value, @base, (int)rnd);
            else
                return SafeNativeMethods.__gmpfr_inp_str_x64(rop.ToIntPtr(), stream.Value.Value, @base, (int)rnd);
        }

        /// <summary>
        /// Export the number <paramref name="op"/> to the stream <paramref name="stream"/> in a floating-point interchange format. 
        /// </summary>
        /// <param name="stream">The export stream.</param>
        /// <param name="op">The floating-point number.</param>
        /// <returns>Return 0 iff the export was successful.</returns>
        /// <remarks>
        /// <para>
        /// In particular one can export on a 32-bit computer and import on a 64-bit computer, or export on a little-endian
        /// computer and import on a big-endian computer. The precision of <paramref name="op"/> and the sign bit of a NaN
        /// are stored too. 
        /// </para>
        /// <para>
        /// Note: this function is experimental and its interface might change in future versions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_out_str">mpfr_out_str</seealso>
        /// <seealso cref="mpfr_inp_str">mpfr_inp_str</seealso>
        /// <seealso cref="mpfr_fpif_import">mpfr_fpif_import</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Export op to temporary file.
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) == 0);
        /// fclose(stream.Value.Value);
        /// 
        /// // Read op from the temporary file.
        /// mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN);
        /// stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) == 0);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123456U);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123456.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Get a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName() 
        /// 
        /// ' Open temporary file for writing.
        /// Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
        ///  _wfopen_s(stream.Value.Value, pathname,"w")
        /// 
        /// ' Export op to temporary file.
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) = 0)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Read op from the temporary file.
        /// mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN)
        /// stream = New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname,"r")
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) = 0)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123456U)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fpif_export(ptr<FILE> stream, mpfr_t op)
        {
            return SafeNativeMethods.__gmpfr_fpif_export(stream.Value.Value, op.ToIntPtr());
        }

        /// <summary>
        /// Import the number <paramref name="op"/> from the stream <paramref name="stream"/> in a floating-point interchange format (see <see cref="mpfr_fpif_export"/>). 
        /// </summary>
        /// <param name="op">The imported floating-point number.</param>
        /// <param name="stream">The input stream.</param>
        /// <returns>Return 0 iff the import was successful.</returns>
        /// <remarks>
        /// <para>
        /// Note that the precision of <paramref name="op"/> is set to the one read from the stream, and the sign bit
        /// is always retrieved (even for NaN).
        /// If the stored precision is zero or greater than <see cref="mpfr_lib.MPFR_PREC_MAX"/>, the function fails
        /// (it returns non-zero) and <paramref name="op"/> is unchanged.
        /// If the function fails for another reason, <paramref name="op"/> is set to NaN and it is unspecified
        /// whether the precision of <paramref name="op"/> has changed to the one read from the file. 
        /// </para>
        /// <para>
        /// Note: this function is experimental and its interface might change in future versions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_out_str">mpfr_out_str</seealso>
        /// <seealso cref="mpfr_inp_str">mpfr_inp_str</seealso>
        /// <seealso cref="mpfr_fpif_export">mpfr_fpif_export</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Input_and_Output_Functions">Input and Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Input-and-Output-Functions">GNU MPFR - Input and Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Export op to temporary file.
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) == 0);
        /// fclose(stream.Value.Value);
        /// 
        /// // Read op from the temporary file.
        /// mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN);
        /// stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) == 0);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123456U);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123456.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// mpfr_lib.mpfr_set_ui(op, 123456U, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Get a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName() 
        /// 
        /// ' Open temporary file for writing.
        /// Dim stream As ptr(Of FILE) =  New ptr(Of FILE)()
        ///  _wfopen_s(stream.Value.Value, pathname,"w")
        /// 
        /// ' Export op to temporary file.
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_export(stream, op) = 0)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Read op from the temporary file.
        /// mpfr_lib.mpfr_set_ui(op, 0, mpfr_rnd_t.MPFR_RNDN)
        /// stream = New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname,"r")
        /// Assert.IsTrue(mpfr_lib.mpfr_fpif_import(op, stream) = 0)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123456U)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fpif_import(mpfr_t op, ptr<FILE> stream)
        {
            return SafeNativeMethods.__gmpfr_fpif_import(op.ToIntPtr(), stream.Value.Value);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to an <see cref="intmax_t">intmax_t</see> after rounding it with respect to <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
        /// If <paramref name="op"/> is too big for the return type, the function returns the maximum
        /// or the minimum of the corresponding C type, depending on the direction of the overflow;
        /// the erange flag is set too.
        /// When there is no such range error, if the return value differs from <paramref name="op"/>,
        /// i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
        /// See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -123.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_sj(op, mpfr_rnd_t.MPFR_RNDN) == -123);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -123.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_sj(op, mpfr_rnd_t.MPFR_RNDN) = -123)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static intmax_t mpfr_get_sj(mpfr_t op, mpfr_rnd_t rnd)
        {
            return SafeNativeMethods.__gmpfr_mpfr_get_sj(op.ToIntPtr(),(int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to an <see cref="uintmax_t">uintmax_t</see> after rounding it with respect to <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
        /// If <paramref name="op"/> is too big for the return type, the function returns the maximum
        /// or the minimum of the corresponding C type, depending on the direction of the overflow;
        /// the erange flag is set too.
        /// When there is no such range error, if the return value differs from <paramref name="op"/>,
        /// i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
        /// See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to 123.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_uj(op, mpfr_rnd_t.MPFR_RNDN) == 123);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to 123.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_uj(op, mpfr_rnd_t.MPFR_RNDN) = 123)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static uintmax_t mpfr_get_uj(mpfr_t op, mpfr_rnd_t rnd)
        {
            return SafeNativeMethods.__gmpfr_mpfr_get_uj(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_sj(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_sj(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_sj(mpfr_t rop, intmax_t op, mpfr_rnd_t rnd)
        {
            return SafeNativeMethods.__gmpfr_set_sj(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 128U);
        /// 
        /// // Set x to 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj(x, 100U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 100.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 128U)
        /// 
        /// ' Set x to 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj(x, 100U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 100.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_set_uj(mpfr_t rop, uintmax_t op, mpfr_rnd_t rnd)
        {
            return SafeNativeMethods.__gmpfr_set_uj(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="e"></param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_sj_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_sj_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_sj(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_sj_2exp(mpfr_t rop, intmax_t op, intmax_t e, mpfr_rnd_t rnd)
        {
            return SafeNativeMethods.__gmpfr_set_sj_2exp(rop.ToIntPtr(), op, e, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="e"></param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_uj(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_uj(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_uj_2exp(mpfr_t rop, uintmax_t op, uintmax_t e, mpfr_rnd_t rnd)
        {
            return SafeNativeMethods.__gmpfr_set_uj_2exp(rop.ToIntPtr(), op, e, (int)rnd);
        }

        /// <summary>
        /// Return the MPFR version, as a null-terminated string. 
        /// </summary>
        /// <returns>Return the MPFR version, as a null-terminated string.</returns>
        /// <seealso cref="MPFR_VERSION">MPFR_VERSION</seealso>
        /// <seealso cref="MPFR_VERSION_MAJOR">MPFR_VERSION_MAJOR</seealso>
        /// <seealso cref="MPFR_VERSION_MINOR">MPFR_VERSION_MINOR</seealso>
        /// <seealso cref="MPFR_VERSION_PATCHLEVEL">MPFR_VERSION_PATCHLEVEL</seealso>
        /// <seealso cref="MPFR_VERSION_STRING">MPFR_VERSION_STRING</seealso>
        /// <seealso cref="MPFR_VERSION_NUM">MPFR_VERSION_NUM</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert MPFR version.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_version().ToString() == "3.1.6");
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert MPFR version.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_version().ToString() = "3.1.6")
        /// </code> 
        /// </example>
        public static /*const*/ char_ptr /*char **/ mpfr_get_version(/*void*/)
        {
            return new char_ptr(SafeNativeMethods.mpfr_get_version());
        }

        /// <summary>
        /// Return a null-terminated string containing the ids of the patches applied to the MPFR library (contents of the PATCHES file), separated by spaces.
        /// </summary>
        /// <returns>Return a null-terminated string containing the ids of the patches applied to the MPFR library (contents of the PATCHES file), separated by spaces.</returns>
        /// <remarks>
        /// <para>
        /// Note: If the program has been compiled with an older MPFR version and is dynamically linked with a new MPFR library version,
        /// the identifiers of the patches applied to the old (compile-time) MPFR version are not available (however this information
        /// should not have much interest in general). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
        /// <seealso cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
        /// <seealso cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
        /// <seealso cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
        /// <seealso cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
        /// <seealso cref="mpfr_buildopt_sharedcache_p ">mpfr_buildopt_sharedcache_p </seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert no patch applied.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_patches().ToString() == "");
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert no patch applied.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_patches().ToString() = "")
        /// </code> 
        /// </example>
        public static /*const*/ char_ptr /*char **/ mpfr_get_patches(/*void*/)
        {
            return new char_ptr(SafeNativeMethods.mpfr_get_patches());
        }

        /// <summary>
        /// Return a non-zero value if MPFR was compiled as thread safe using compiler-level Thread Local Storage, return zero otherwise.
        /// </summary>
        /// <returns>Return a non-zero value if MPFR was compiled as thread safe using compiler-level Thread Local Storage, return zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return a non-zero value if MPFR was compiled with decimal float support
        /// (that is, MPFR was built with the --enable-decimal-float configure option),
        /// return zero otherwise. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_patches">mpfr_get_patches</seealso>
        /// <seealso cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
        /// <seealso cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
        /// <seealso cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
        /// <seealso cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
        /// <seealso cref="mpfr_buildopt_sharedcache_p ">mpfr_buildopt_sharedcache_p </seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert that --enable-thread-safe compile option was used.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_tls_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert that --enable-thread-safe compile option was used.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_tls_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static int mpfr_buildopt_tls_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_buildopt_tls_p();
        }

        /// <summary>
        /// Return a non-zero value if MPFR was compiled with ‘__float128’ support, return zero otherwise.
        /// </summary>
        /// <returns>Return a non-zero value if MPFR was compiled with ‘__float128’ support, return zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return a non-zero value if MPFR was compiled with ‘__float128’ support (that is, MPFR was built with the
        /// ‘--enable-float128’ configure option), return zero otherwise.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_patches">mpfr_get_patches</seealso>
        /// <seealso cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
        /// <seealso cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
        /// <seealso cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
        /// <seealso cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
        /// <seealso cref="mpfr_buildopt_sharedcache_p ">mpfr_buildopt_sharedcache_p </seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert that ‘__float128’ support is not available.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_float128_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert that ‘__float128’ support is not available.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_float128_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_buildopt_float128_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_buildopt_float128_p();
        }

        /// <summary>
        /// Return a non-zero value if MPFR was compiled with decimal float support, return zero otherwise. 
        /// </summary>
        /// <returns>Return a non-zero value if MPFR was compiled with decimal float support, return zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return a non-zero value if MPFR was compiled with decimal float support
        /// (that is, MPFR was built with the --enable-decimal-float configure option), return zero otherwise. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_patches">mpfr_get_patches</seealso>
        /// <seealso cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
        /// <seealso cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
        /// <seealso cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
        /// <seealso cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
        /// <seealso cref="mpfr_buildopt_sharedcache_p ">mpfr_buildopt_sharedcache_p </seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert that Decimal float is not available.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_decimal_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert that Decimal float is not available.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_decimal_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_buildopt_decimal_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_buildopt_decimal_p();
        }

        /// <summary>
        /// Return a non-zero value if MPFR was compiled with GMP internals, return zero otherwise. 
        /// </summary>
        /// <returns>Return a non-zero value if MPFR was compiled with GMP internals, return zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return a non-zero value if MPFR was compiled with GMP internals
        /// (that is, MPFR was built with either --with-gmp-build or --enable-gmp-internals configure option), return zero otherwise. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_patches">mpfr_get_patches</seealso>
        /// <seealso cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
        /// <seealso cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
        /// <seealso cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
        /// <seealso cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
        /// <seealso cref="mpfr_buildopt_sharedcache_p ">mpfr_buildopt_sharedcache_p </seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert that --with-gmp-build compile option was used.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_gmpinternals_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert that --with-gmp-build compile option was used.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_gmpinternals_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_buildopt_gmpinternals_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_buildopt_gmpinternals_p();
        }

        /// <summary>
        /// Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant, return zero otherwise. 
        /// </summary>
        /// <returns>Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant, return zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return a non-zero value if MPFR was compiled so that all threads share the same cache for one MPFR constant,
        /// like <see cref="mpfr_const_pi"/> or <see cref="mpfr_const_log2"/> (that is, MPFR was built with the
        /// ‘--enable-shared-cache’ configure option), return zero otherwise.
        /// If the return value is non-zero, MPFR applications may need to be compiled with the ‘-pthread’ option.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_patches">mpfr_get_patches</seealso>
        /// <seealso cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
        /// <seealso cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
        /// <seealso cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
        /// <seealso cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
        /// <seealso cref="mpfr_buildopt_tune_case">mpfr_buildopt_tune_case</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert that --enable-shared-cache compile option was used.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_sharedcache_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert that --enable-shared-cache compile option was used.
        /// Assert.IsTrue(mpfr_lib.mpfr_buildopt_sharedcache_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_buildopt_sharedcache_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_buildopt_sharedcache_p();
        }

        /// <summary>
        /// Return a string saying which thresholds file has been used at compile time.
        /// </summary>
        /// <returns>Return a string saying which thresholds file has been used at compile time.</returns>
        /// <remarks>
        /// <para>
        /// This file is normally selected from the processor type. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_patches">mpfr_get_patches</seealso>
        /// <seealso cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</seealso>
        /// <seealso cref="mpfr_buildopt_float128_p">mpfr_buildopt_float128_p</seealso>
        /// <seealso cref="mpfr_buildopt_decimal_p">mpfr_buildopt_decimal_p</seealso>
        /// <seealso cref="mpfr_buildopt_gmpinternals_p">mpfr_buildopt_gmpinternals_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// if (gmp_lib.mp_bytes_per_limb == 4)
        ///     Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() == "src/x86/mparam.h");
        /// else
        ///     Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() == "default");
        /// </code> 
        /// <code language="VB.NET">
        /// If gmp_lib.mp_bytes_per_limb = 4 Then
        ///     Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() = "src/x86/mparam.h")
        /// Else
        ///     Assert.IsTrue(mpfr_lib.mpfr_buildopt_tune_case().ToString() = "default")
        /// End If
        /// </code> 
        /// </example>
        public static /*const*/ char_ptr /*char **/ mpfr_buildopt_tune_case(/*void*/)
        {
            return new char_ptr(SafeNativeMethods.mpfr_buildopt_tune_case());
        }

        /// <summary>
        /// Return the (current) smallest exponent allowed for a floating-point variable.
        /// </summary>
        /// <returns>Return the (current) smallest exponent allowed for a floating-point variable.</returns>
        /// <remarks>
        /// <para>
        /// The smallest positive value of a floating-point variable is one half times 2 raised to the smallest exponent
        /// and the largest value has the form (1 - epsilon) times 2 raised to the largest exponent,
        /// where epsilon depends on the precision of the considered variable. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert minimum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin() == -1073741823);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert minimum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin() = -1073741823)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_emin(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_emin();
        }

        /// <summary>
        /// Set the smallest exponent allowed for a floating-point variable.
        /// </summary>
        /// <param name="exp">The exponent.</param>
        /// <returns>Return a nonzero value when <paramref name="exp"/> is not in the range accepted by the implementation (in that case the smallest exponent is not changed), and zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// For the subsequent operations, it is the user’s responsibility to check that any floating-point value used as an input is in the
        /// new exponent range (for example using <see cref="mpfr_check_range"/>).
        /// If a floating-point value outside the new exponent range is used as an input, the default behavior is undefined, in the sense of
        /// the ISO C standard; the behavior may also be explicitly documented, such as for <see cref="mpfr_check_range"/>.
        /// </para>
        /// <para>
        /// Note: Caches may still have values outside the current exponent range.
        /// This is not an issue as the user cannot use these caches directly via the API (MPFR extends the exponent range internally
        /// when need be).
        /// </para>
        /// <para>
        /// If emin &gt; emax and a floating-point value needs to be produced as output, the behavior is undefined
        /// (<see cref="mpfr_set_emin"/> and <see cref="mpfr_set_emax"/> do not check this condition as it might occur between
        /// successive calls to these two functions).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set max exponent.
        /// mpfr_lib.mpfr_set_emin(1000);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin() == 1000);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set max exponent.
        /// mpfr_lib.mpfr_set_emin(1000)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin() = 1000)
        /// </code> 
        /// </example>
        public static int mpfr_set_emin(mpfr_exp_t exp)
        {
            return SafeNativeMethods.mpfr_set_emin(exp);
        }

        /// <summary>
        /// Return the minimum exponent allowed for <see cref="mpfr_set_emin">mpfr_set_emin</see>. 
        /// </summary>
        /// <returns>Return the minimum exponent allowed for <see cref="mpfr_set_emin">mpfr_set_emin</see>.</returns>
        /// <remarks>
        /// <para>
        /// This value is implementation dependent, thus a program using <see cref="mpfr_set_emax">mpfr_set_emax</see>(<see cref="mpfr_get_emax_max">mpfr_get_emax_max</see>())
        /// or <see cref="mpfr_set_emin">mpfr_set_emin</see>(<see cref="mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert mpfr_set_emin minimum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin_min() == -1073741823);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert mpfr_set_emin minimum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin_min() = -1073741823)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_emin_min(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_emin_min();
        }

        /// <summary>
        /// Return the maximum exponent allowed for <see cref="mpfr_set_emin">mpfr_set_emin</see>. 
        /// </summary>
        /// <returns>Return the maximum of the exponent allowed for <see cref="mpfr_set_emin">mpfr_set_emin</see>.</returns>
        /// <remarks>
        /// <para>
        /// This value is implementation dependent, thus a program using <see cref="mpfr_set_emax">mpfr_set_emax</see>(<see cref="mpfr_get_emax_max">mpfr_get_emax_max</see>())
        /// or <see cref="mpfr_set_emin">mpfr_set_emin</see>(<see cref="mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert mpfr_set_emin maximum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin_max() == 1073741823);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert mpfr_set_emin maximum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emin_max() = 1073741823)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_emin_max(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_emin_max();
        }

        /// <summary>
        /// Return the (current) largest exponent allowed for a floating-point variable.
        /// </summary>
        /// <returns>Return the (current) largest exponent allowed for a floating-point variable.</returns>
        /// <remarks>
        /// <para>
        /// The smallest positive value of a floating-point variable is one half times 2 raised to the smallest exponent
        /// and the largest value has the form (1 - epsilon) times 2 raised to the largest exponent,
        /// where epsilon depends on the precision of the considered variable. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert maximum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax() == 1073741823);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert maximum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax() = 1073741823)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_emax(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_emax();
        }

        /// <summary>
        /// Set the largest exponent allowed for a floating-point variable.
        /// </summary>
        /// <param name="exp">The exponent.</param>
        /// <returns>Return a non-zero value when <paramref name="exp"/> is not in the range accepted by the implementation (in that case the largest exponent is not changed), and zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// If the user changes the exponent range, it is her/his responsibility to check that all current floating-point variables 
        /// are in the new allowed range (for example using <see cref="mpfr_check_range">mpfr_check_range</see>), otherwise the subsequent behavior will
        /// be undefined, in the sense of the ISO C standard. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set max exponent.
        /// mpfr_lib.mpfr_set_emax(1000);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax() == 1000);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set max exponent.
        /// mpfr_lib.mpfr_set_emax(1000)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax() = 1000)
        /// </code> 
        /// </example>
        public static int mpfr_set_emax(mpfr_exp_t exp)
        {
            return SafeNativeMethods.mpfr_set_emax(exp);
        }

        /// <summary>
        /// Return the minimum exponent allowed for <see cref="mpfr_set_emax">mpfr_set_emax</see>. 
        /// </summary>
        /// <returns>Return the minimum exponent allowed for <see cref="mpfr_set_emax">mpfr_set_emax</see>.</returns>
        /// <remarks>
        /// <para>
        /// This value is implementation dependent, thus a program using <see cref="mpfr_set_emax">mpfr_set_emax</see>(<see cref="mpfr_get_emax_max">mpfr_get_emax_max</see>())
        /// or <see cref="mpfr_set_emin">mpfr_set_emin</see>(<see cref="mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert mpfr_set_emax minimum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax_min() == -1073741823);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert mpfr_set_emax minimum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax_min() = -1073741823)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_emax_min(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_emax_min();
        }

        /// <summary>
        /// Return the maximum exponent allowed for <see cref="mpfr_set_emax">mpfr_set_emax</see>. 
        /// </summary>
        /// <returns>Return the maximum exponent allowed for <see cref="mpfr_set_emax">mpfr_set_emax</see>.</returns>
        /// <remarks>
        /// <para>
        /// This value is implementation dependent, thus a program using <see cref="mpfr_set_emax">mpfr_set_emax</see>(<see cref="mpfr_get_emax_max">mpfr_get_emax_max</see>())
        /// or <see cref="mpfr_set_emin">mpfr_set_emin</see>(<see cref="mpfr_get_emin_min">mpfr_get_emin_min</see>()) may not be portable. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert mpfr_set_emax maximum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax_max() == 1073741823);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert mpfr_set_emax maximum exponent.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_emax_max() = 1073741823)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_emax_max(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_emax_max();
        }

        /// <summary>
        /// Set the default rounding mode to <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rnd">The rounding direction.</param>
        /// <remarks>
        /// <para>
        /// The default rounding mode is to nearest initially. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_default_rounding_mode ">mpfr_get_default_rounding_mode </seealso>
        /// <seealso cref="mpfr_prec_round">mpfr_prec_round</seealso>
        /// <seealso cref="mpfr_can_round">mpfr_can_round</seealso>
        /// <seealso cref="mpfr_min_prec">mpfr_min_prec</seealso>
        /// <seealso cref="mpfr_print_rnd_mode">mpfr_print_rnd_mode</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default rounding mode.
        /// mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Assert default rounding mode.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() == mpfr_rnd_t.MPFR_RNDN);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default rounding mode.
        /// mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Assert default rounding mode.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() = mpfr_rnd_t.MPFR_RNDN)
        /// </code> 
        /// </example>
        public static void mpfr_set_default_rounding_mode(mpfr_rnd_t rnd)
        {
            SafeNativeMethods.mpfr_set_default_rounding_mode((int)rnd);
        }

        /// <summary>
        /// Get the default rounding mode. 
        /// </summary>
        /// <returns>The default rounding mode.</returns>
        /// <seealso cref="mpfr_set_default_rounding_mode">mpfr_set_default_rounding_mode</seealso>
        /// <seealso cref="mpfr_prec_round">mpfr_prec_round</seealso>
        /// <seealso cref="mpfr_can_round">mpfr_can_round</seealso>
        /// <seealso cref="mpfr_min_prec">mpfr_min_prec</seealso>
        /// <seealso cref="mpfr_print_rnd_mode">mpfr_print_rnd_mode</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default rounding mode.
        /// mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Assert default rounding mode.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() == mpfr_rnd_t.MPFR_RNDN);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default rounding mode.
        /// mpfr_lib.mpfr_set_default_rounding_mode(mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Assert default rounding mode.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_rounding_mode() = mpfr_rnd_t.MPFR_RNDN)
        /// </code> 
        /// </example>
        public static mpfr_rnd_t mpfr_get_default_rounding_mode(/*void*/)
        {
            return (mpfr_rnd_t)SafeNativeMethods.mpfr_get_default_rounding_mode();
        }

        /// <summary>
        /// Return a string ("MPFR_RNDD", "MPFR_RNDU", "MPFR_RNDN", "MPFR_RNDZ", "MPFR_RNDA") corresponding to the rounding mode <paramref name="rnd"/>, or a null pointer if <paramref name="rnd"/> is an invalid rounding mode. 
        /// </summary>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return a string ("MPFR_RNDD", "MPFR_RNDU", "MPFR_RNDN", "MPFR_RNDZ", "MPFR_RNDA") corresponding to the rounding mode <paramref name="rnd"/>, or a null pointer if <paramref name="rnd"/> is an invalid rounding mode. </returns>
        /// <seealso cref="mpfr_set_default_rounding_mode">mpfr_set_default_rounding_mode</seealso>
        /// <seealso cref="mpfr_get_default_rounding_mode ">mpfr_get_default_rounding_mode </seealso>
        /// <seealso cref="mpfr_prec_round">mpfr_prec_round</seealso>
        /// <seealso cref="mpfr_can_round">mpfr_can_round</seealso>
        /// <seealso cref="mpfr_min_prec">mpfr_min_prec</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDA).ToString() == "MPFR_RNDA");
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDD).ToString() == "MPFR_RNDD");
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDF) == char_ptr.Zero);
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDN).ToString() == "MPFR_RNDN");
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDU).ToString() == "MPFR_RNDU");
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDZ).ToString() == "MPFR_RNDZ");
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDNA) == char_ptr.Zero);
        /// </code> 
        /// <code language="VB.NET">
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDA).ToString() = "MPFR_RNDA")
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDD).ToString() = "MPFR_RNDD")
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDF) = char_ptr.Zero)
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDN).ToString() = "MPFR_RNDN")
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDU).ToString() = "MPFR_RNDU")
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDZ).ToString() = "MPFR_RNDZ")
        /// Assert.IsTrue(mpfr_lib.mpfr_print_rnd_mode(mpfr_rnd_t.MPFR_RNDNA) = char_ptr.Zero)
        /// </code> 
        /// </example>
        public static /*const*/ char_ptr /*char **/ mpfr_print_rnd_mode(mpfr_rnd_t rnd)
        {
            return new char_ptr(SafeNativeMethods.mpfr_print_rnd_mode((int)rnd));
        }

        /// <summary>
        /// Clear (lower) all global flags (underflow, overflow, divide-by-zero, invalid, inexact, erange). 
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: a group of flags can be cleared by using <see cref="mpfr_flags_clear"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear all flags and assert that flags are clear.
        /// mpfr_lib.mpfr_clear_flags();
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear all flags and assert that flags are clear.
        /// mpfr_lib.mpfr_clear_flags()
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_flags(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_flags();
        }

        /// <summary>
        /// Clear (lower) the underflow flag. 
        /// </summary>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_underflow();
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_underflow()
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_underflow(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_underflow();
        }

        /// <summary>
        /// Clear (lower) the overflow flag. 
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_overflow();
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_overflow()
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_overflow(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_overflow();
        }

        /// <summary>
        /// Clear (lower) the divide-by-zero flag. 
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_divby0();
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_divby0()
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_divby0(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_divby0();
        }

        /// <summary>
        /// Clear (lower) the invalid flag. 
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_nanflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_nanflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_nanflag(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_nanflag();
        }

        /// <summary>
        /// Clear (lower) the inexact flag. 
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_inexflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_inexflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_inexflag(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_inexflag();
        }

        /// <summary>
        /// Clear (lower) the erange flag. 
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_erangeflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_erangeflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_clear_erangeflag(/*void*/)
        {
            SafeNativeMethods.mpfr_clear_erangeflag();
        }

        /// <summary>
        /// Set (raised) the underflow flag.
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_underflow();
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_underflow()
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_set_underflow(/*void*/)
        {
            SafeNativeMethods.mpfr_set_underflow();
        }

        /// <summary>
        /// Set (raised) the overflow flag.
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_overflow();
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_overflow()
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_set_overflow(/*void*/)
        {
            SafeNativeMethods.mpfr_set_overflow();
        }

        /// <summary>
        /// Set (raised) the divide-by-zero flag.
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_divby0();
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_divby0()
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_set_divby0(/*void*/)
        {
            SafeNativeMethods.mpfr_set_divby0();
        }

        /// <summary>
        /// Set (raised) the invalid flag.
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_nanflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_nanflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_set_nanflag(/*void*/)
        {
            SafeNativeMethods.mpfr_set_nanflag();
        }

        /// <summary>
        /// Set (raised) the inexact flag.
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_inexflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_inexflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_set_inexflag(/*void*/)
        {
            SafeNativeMethods.mpfr_set_inexflag();
        }

        /// <summary>
        /// Set (raised) the erange flag.
        /// </summary>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_erangeflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set flag and assert that flag is set.
        /// mpfr_lib.mpfr_set_erangeflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_set_erangeflag(/*void*/)
        {
            SafeNativeMethods.mpfr_set_erangeflag();
        }

        /// <summary>
        /// Return the underflow flag, which is non-zero iff the flag is set. 
        /// </summary>
        /// <returns>Return the underflow flag, which is non-zero iff the flag is set.</returns>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_underflow();
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_underflow()
        /// Assert.IsTrue(mpfr_lib.mpfr_underflow_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_underflow_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_underflow_p();
        }

        /// <summary>
        /// Return the overflow flag, which is non-zero iff the flag is set. 
        /// </summary>
        /// <returns>Return the overflow flag, which is non-zero iff the flag is set.</returns>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_overflow();
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_overflow()
        /// Assert.IsTrue(mpfr_lib.mpfr_overflow_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_overflow_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_overflow_p();
        }

        /// <summary>
        /// Return the divide-by-zero flag, which is non-zero iff the flag is set. 
        /// </summary>
        /// <returns>Return the divide-by-zero flag, which is non-zero iff the flag is set.</returns>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_divby0();
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_divby0()
        /// Assert.IsTrue(mpfr_lib.mpfr_divby0_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_divby0_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_divby0_p();
        }

        /// <summary>
        /// Return the invalid flag, which is non-zero iff the flag is set. 
        /// </summary>
        /// <returns>Return the invalid flag, which is non-zero iff the flag is set.</returns>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_nanflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_nanflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_nanflag_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_nanflag_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_nanflag_p();
        }

        /// <summary>
        /// Return the inexact flag, which is non-zero iff the flag is set. 
        /// </summary>
        /// <returns>Return the inexact flag, which is non-zero iff the flag is set.</returns>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_inexflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_inexflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_inexflag_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_inexflag_p();
        }

        /// <summary>
        /// Return the erange flag, which is non-zero iff the flag is set. 
        /// </summary>
        /// <returns>Return the erange flag, which is non-zero iff the flag is set.</returns>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_erangeflag();
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear flag and assert that flag is clear.
        /// mpfr_lib.mpfr_clear_erangeflag()
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
        /// </code> 
        /// </example>
        public static int mpfr_erangeflag_p(/*void*/)
        {
            return SafeNativeMethods.mpfr_erangeflag_p();
        }

        /// <summary>
        /// Clear (lower) the group of flags specified by <paramref name="mask"/>.
        /// </summary>
        /// <param name="mask">The bit flags mask.</param>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_flags_set">mpfr_flags_set</seealso>
        /// <seealso cref="mpfr_flags_test">mpfr_flags_test</seealso>
        /// <seealso cref="mpfr_flags_save">mpfr_flags_save</seealso>
        /// <seealso cref="mpfr_flags_restore">mpfr_flags_restore</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Clear erange and inexact flags, and assert that they are clear.
        /// mpfr_lib.mpfr_flags_clear(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_INEXACT);
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Clear erange and inexact flags, and assert that they are clear.
        /// mpfr_lib.mpfr_flags_clear(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_INEXACT)
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() = 0)
        /// </code> 
        /// </example>
        public static void mpfr_flags_clear(mpfr_flags_t mask)
        {
            SafeNativeMethods.mpfr_flags_clear((uint)mask);
        }

        /// <summary>
        /// Set (raise) the group of flags specified by <paramref name="mask"/>.
        /// </summary>
        /// <param name="mask">The bit flags mask.</param>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_flags_clear">mpfr_flags_clear</seealso>
        /// <seealso cref="mpfr_flags_test">mpfr_flags_test</seealso>
        /// <seealso cref="mpfr_flags_save">mpfr_flags_save</seealso>
        /// <seealso cref="mpfr_flags_restore">mpfr_flags_restore</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set erange and inexact flags, and assert that they are set.
        /// mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_INEXACT);
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() != 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set erange and inexact flags, and assert that they are set.
        /// mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_INEXACT)
        /// Assert.IsTrue(mpfr_lib.mpfr_erangeflag_p() &lt;&gt; 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_inexflag_p() &lt;&gt; 0)
        /// </code> 
        /// </example>
        public static void mpfr_flags_set(mpfr_flags_t mask)
        {
            SafeNativeMethods.mpfr_flags_set((uint)mask);
        }

        /// <summary>
        /// Return the flags specified by <paramref name="mask"/>.
        /// </summary>
        /// <param name="mask">The bit flags mask.</param>
        /// <returns>Return the flags specified by <paramref name="mask"/>.</returns>
        /// <remarks>
        /// <para>
        /// To test whether any flag from <paramref name="mask"/> is set, compare the return value to 0.
        /// You can also test individual flags by AND’ing the result with the <see cref="mpfr_flags_t"/> values. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_flags_clear">mpfr_flags_clear</seealso>
        /// <seealso cref="mpfr_flags_set">mpfr_flags_set</seealso>
        /// <seealso cref="mpfr_flags_save">mpfr_flags_save</seealso>
        /// <seealso cref="mpfr_flags_restore">mpfr_flags_restore</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set erange and divby0 flags.
        /// mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_DIVBY0);
        /// 
        /// // Get the erange and inexact flags, and assert that their values.
        /// mpfr_flags_t flags = mpfr_lib.mpfr_flags_test(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_INEXACT);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) != 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set erange and divby0 flags.
        /// mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_DIVBY0)
        /// 
        /// ' Get the erange and inexact flags, and assert that their values.
        /// Dim flags As mpfr_flags_t = mpfr_lib.mpfr_flags_test(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_INEXACT)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) &lt;&gt; 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) = 0)
        /// </code> 
        /// </example>
        public static mpfr_flags_t mpfr_flags_test(mpfr_flags_t mask)
        {
            return (mpfr_flags_t)SafeNativeMethods.mpfr_flags_test((uint)mask);
        }

        /// <summary>
        /// Return all the flags.
        /// </summary>
        /// <returns>Return all the flags.</returns>
        /// <remarks>
        /// <para>
        /// It is equivalent to <see cref="mpfr_flags_test"/>(<see cref="mpfr_flags_t.MPFR_FLAGS_ALL"/>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_flags_clear">mpfr_flags_clear</seealso>
        /// <seealso cref="mpfr_flags_set">mpfr_flags_set</seealso>
        /// <seealso cref="mpfr_flags_test">mpfr_flags_test</seealso>
        /// <seealso cref="mpfr_flags_restore">mpfr_flags_restore</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set erange and divby0 flags.
        /// mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_DIVBY0);
        /// 
        /// // Get all flags, and assert their values.
        /// mpfr_flags_t flags = mpfr_lib.mpfr_flags_save();
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) != 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) != 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) == 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) == 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) == 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set erange and divby0 flags.
        /// mpfr_lib.mpfr_flags_set(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_DIVBY0)
        /// 
        /// ' Get all flags, and assert their values.
        /// Dim flags As mpfr_flags_t = mpfr_lib.mpfr_flags_save()
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) &lt;&gt; 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) &lt;&gt; 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) = 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) = 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) = 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) = 0)
        /// </code> 
        /// </example>
        public static mpfr_flags_t mpfr_flags_save(/*void*/)
        {
            return (mpfr_flags_t)SafeNativeMethods.mpfr_flags_save();
        }

        /// <summary>
        /// Restore the flags specified by <paramref name="mask"/> to their state represented in <paramref name="flags"/>.
        /// </summary>
        /// <param name="flags">The bit flags.</param>
        /// <param name="mask">The bit flags mask.</param>
        /// <seealso cref="mpfr_clear_underflow">mpfr_clear_underflow</seealso>
        /// <seealso cref="mpfr_clear_overflow">mpfr_clear_overflow</seealso>
        /// <seealso cref="mpfr_clear_divby0">mpfr_clear_divby0</seealso>
        /// <seealso cref="mpfr_clear_nanflag">mpfr_clear_nanflag</seealso>
        /// <seealso cref="mpfr_clear_inexflag">mpfr_clear_inexflag</seealso>
        /// <seealso cref="mpfr_clear_erangeflag">mpfr_clear_erangeflag</seealso>
        /// <seealso cref="mpfr_set_underflow">mpfr_set_underflow</seealso>
        /// <seealso cref="mpfr_set_overflow">mpfr_set_overflow</seealso>
        /// <seealso cref="mpfr_set_divby0">mpfr_set_divby0</seealso>
        /// <seealso cref="mpfr_set_nanflag">mpfr_set_nanflag</seealso>
        /// <seealso cref="mpfr_set_inexflag">mpfr_set_inexflag</seealso>
        /// <seealso cref="mpfr_set_erangeflag">mpfr_set_erangeflag</seealso>
        /// <seealso cref="mpfr_clear_flags">mpfr_clear_flags</seealso>
        /// <seealso cref="mpfr_underflow_p">mpfr_underflow_p</seealso>
        /// <seealso cref="mpfr_overflow_p">mpfr_overflow_p</seealso>
        /// <seealso cref="mpfr_divby0_p">mpfr_divby0_p</seealso>
        /// <seealso cref="mpfr_nanflag_p">mpfr_nanflag_p</seealso>
        /// <seealso cref="mpfr_inexflag_p">mpfr_inexflag_p</seealso>
        /// <seealso cref="mpfr_erangeflag_p">mpfr_erangeflag_p</seealso>
        /// <seealso cref="mpfr_flags_clear">mpfr_flags_clear</seealso>
        /// <seealso cref="mpfr_flags_set">mpfr_flags_set</seealso>
        /// <seealso cref="mpfr_flags_test">mpfr_flags_test</seealso>
        /// <seealso cref="mpfr_flags_save">mpfr_flags_save</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set erange and divby0 flags.
        /// mpfr_lib.mpfr_flags_restore(mpfr_flags_t.MPFR_FLAGS_ERANGE | mpfr_flags_t.MPFR_FLAGS_DIVBY0, mpfr_flags_t.MPFR_FLAGS_ALL);
        /// 
        /// // Get all flags, and assert their values.
        /// mpfr_flags_t flags = mpfr_lib.mpfr_flags_save();
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) != 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) != 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) == 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) == 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) == 0);
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) == 0);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set erange and divby0 flags.
        /// mpfr_lib.mpfr_flags_restore(mpfr_flags_t.MPFR_FLAGS_ERANGE Or mpfr_flags_t.MPFR_FLAGS_DIVBY0, mpfr_flags_t.MPFR_FLAGS_ALL)
        /// 
        /// ' Get all flags, and assert their values.
        /// Dim flags As mpfr_flags_t = mpfr_lib.mpfr_flags_save()
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_DIVBY0) &lt;&gt; 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_ERANGE) &lt;&gt; 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_INEXACT) = 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_NAN) = 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_OVERFLOW) = 0)
        /// Assert.IsTrue((flags &amp; mpfr_flags_t.MPFR_FLAGS_UNDERFLOW) = 0)
        /// </code> 
        /// </example>
        public static void mpfr_flags_restore(mpfr_flags_t flags, mpfr_flags_t mask)
        {
             SafeNativeMethods.mpfr_flags_restore((uint)flags, (uint)mask);
        }

        /// <summary>
        /// Check that <paramref name="x"/> is within the current range of acceptable values.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="t">The input <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>This function returns zero if the new value of <paramref name="x"/> equals the exact one y, a positive value if that new value is larger than y, and a negative value if it is smaller than y.</returns>
        /// <remarks>
        /// <para>
        /// This function assumes that <paramref name="x"/> is the correctly-rounded value of some real value y in the
        /// direction <paramref name="rnd"/> and some extended exponent range, and that t is the 
        /// corresponding <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>.
        /// For example, one performed t = <see cref="mpfr_log">mpfr_log</see>(<paramref name="x"/>, u, <paramref name="rnd"/>),
        /// and y is the exact logarithm of u.
        /// Thus <paramref name="t"/> is negative if <paramref name="x"/> is smaller than y, positive if <paramref name="x"/>
        /// is larger than y, and zero if <paramref name="x"/> equals y.
        /// This function modifies <paramref name="x"/> if needed to be in the current range of acceptable values:
        /// It generates an underflow or an overflow if the exponent of <paramref name="x"/> is outside the current allowed range;
        /// the value of <paramref name="t"/> may be used to avoid a double rounding.
        /// This function returns zero if the new value of <paramref name="x"/> equals the exact one y, a positive value if that
        /// new value is larger than y, and a negative value if it is smaller than y.
        /// Note that unlike most functions, the new result <paramref name="x"/> is compared to the (unknown) exact one y,
        /// not the input value <paramref name="x"/>, i.e., the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is propagated. 
        /// </para>
        /// <para>
        /// Note: If <paramref name="x"/> is an infinity and <paramref name="t"/> is different from zero (i.e., if the rounded result is an inexact infinity),
        /// then the overflow flag is set.
        /// This is useful because <see cref="mpfr_check_range">mpfr_check_range</see> is typically called (at least in MPFR functions) after restoring the flags that could
        /// have been set due to internal computations. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_subnormalize">mpfr_subnormalize</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 0.100146.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 0.100146, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that return value is -1.
        /// Assert.IsTrue(mpfr_lib.mpfr_check_range(x, -1, mpfr_rnd_t.MPFR_RNDZ) == -1);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 0.100146.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 0.100146, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that return value is -1.
        /// Assert.IsTrue(mpfr_lib.mpfr_check_range(x, -1, mpfr_rnd_t.MPFR_RNDZ) = -1)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_check_range(mpfr_t x, int t, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_check_range(x.ToIntPtr(), t, (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="x"/>, set its precision to be exactly <paramref name="prec"/> bits and its value to NaN.
        /// </summary>
        /// <param name="x">The floating-point number to initialize.</param>
        /// <param name="prec">The precision of the significand in bits.</param>
        /// <remarks>
        /// <para>
        /// (Warning: the corresponding MPF function initializes to zero instead.)
        /// </para>
        /// <para>
        /// Normally, a variable should be initialized once only or at least be cleared, using <see cref="mpfr_clear">mpfr_clear</see>, between initializations.
        /// To change the precision of a variable which has already been initialized, use <see cref="mpfr_set_prec">mpfr_set_prec</see>.
        /// The precision <paramref name="prec"/> must be an integer between <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see>
        /// and <see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see> (otherwise the behavior is undefined). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x with 64-bit precision.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// 
        /// // Assert that the value of x is NaN, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
        /// uint p = mpfr_lib.mpfr_get_prec(x);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 64U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x with 64-bit precision.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// 
        /// ' Assert that the value of x is NaN, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
        /// Dim p As System.UInt32 =  mpfr_lib.mpfr_get_prec(x)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 64U)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_init2(mpfr_t x, mpfr_prec_t prec)
        {
            if (x == null) throw new ArgumentNullException("x");
            x.Initializing();
            SafeNativeMethods.mpfr_init2(x.ToIntPtr(), prec);
            x.Initialized();
        }

        /// <summary>
        /// Initialize <paramref name="x"/>, set its precision to the default precision, and set its value to NaN.
        /// </summary>
        /// <param name="x">The floating-point number.</param>
        /// <remarks>
        /// <para>
        /// The default precision can be changed by a call to <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// <para>
        /// Warning!
        /// In a given program, some other libraries might change the default precision and not restore it.
        /// Thus it is safer to use <see cref="mpfr_init2">mpfr_init2</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// 
        /// // Assert that the value of x is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// 
        /// ' Assert that the value of x is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_init(mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            x.Initializing();
            SafeNativeMethods.mpfr_init(x.ToIntPtr());
            x.Initialized();
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_init_set(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(rop, mpfr_rnd_t.MPFR_RNDN) == 10U);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(rop, mpfr_rnd_t.MPFR_RNDN) = 10U)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_ui(mpfr_t rop, /*const*/ uint op, mpfr_rnd_t rnd)
        {
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set_ui(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_si(mpfr_t rop, /*const*/ int op, mpfr_rnd_t rnd)
        {
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set_si(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.0.
        /// mpfr_t rop = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(rop, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.0.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(rop, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_d(mpfr_t rop, /*const*/ double op, mpfr_rnd_t rnd)
        {
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set_d(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op to 1.
        /// mpz_t op = "1";
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op to 1.
        /// Dim op As mpz_t = "1" 
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_z(mpfr_t rop, /*const*/ mpz_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set_z(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational op to 1.
        /// mpq_t op = "1/1";
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational op to 1.
        /// Dim op As mpq_t = "1/1" 
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_q(mpfr_t rop, /*const*/ mpq_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set_q(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_str">mpfr_init_set_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="">GNU MPFR - </a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpf_t op = new mpf_t();
        /// gmp_lib.mpf_init_set_si(op, 1);
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpf_t = New mpf_t()
        /// gmp_lib.mpf_init_set_si(op, 1)
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_f(mpfr_t rop, /*const*/ mpf_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            mpfr_init(rop);
            return SafeNativeMethods.mpfr_set_f(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Free the space occupied by the significand of <paramref name="x"/>. 
        /// </summary>
        /// <param name="x">The floating-point number.</param>
        /// <remarks>
        /// <para>
        /// Make sure to call this function for all <see cref="mpfr_t">mpfr_t</see> variables when you are done with them.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// 
        /// // Assert that the value of x is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        ///  mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// 
        /// ' Assert that the value of x is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_clear(mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_clear(x.ToIntPtr());
            x.Clear();
        }

        /// <summary>
        /// Initialize all the <see cref="mpfr_t">mpfr_t</see> variables of the given variable argument <paramref name="x"/>, set their precision to be exactly <paramref name="prec"/> bits and their value to NaN.
        /// </summary>
        /// <param name="prec">The precision of the significand in bits.</param>
        /// <param name="x">List of floating-point numbers to initialize.</param>
        /// <remarks>
        /// <para>
        /// See <see cref="mpfr_init2">mpfr_init2</see> for more details.
        /// The list of floating-pointer numbers ends when it encounters a null pointer (whose type must also be <see cref="mpfr_t">mpfr_t</see>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new floating-point numbers x1, x2 and x3.
        /// mpfr_t x1 = new mpfr_t();
        /// mpfr_t x2 = new mpfr_t();
        /// mpfr_t x3 = new mpfr_t();
        /// 
        /// // Initialize the floating-point numbers.
        /// mpfr_lib.mpfr_inits2(64U, x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0 and precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) != 0 &amp;&amp; mpfr_lib.mpfr_get_prec(x1) == 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) != 0 &amp;&amp; mpfr_lib.mpfr_get_prec(x2) == 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) != 0 &amp;&amp; mpfr_lib.mpfr_get_prec(x3) == 64U);
        /// 
        /// // Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpfr_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new floating-point numbers x1, x2 and x3.
        /// Dim x1 As mpfr_t = New mpfr_t()
        /// Dim x2 As mpfr_t = New mpfr_t()
        /// Dim x3 As mpfr_t = New mpfr_t()
        /// 
        /// ' Initialize the floating-point numbers.
        /// mpfr_lib.mpfr_inits2(64U, x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is 0 and precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) &lt;&gt; 0 And mpfr_lib.mpfr_get_prec(x1)  =  64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) &lt;&gt; 0 And mpfr_lib.mpfr_get_prec(x2)  =  64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) &lt;&gt; 0 And mpfr_lib.mpfr_get_prec(x3)  =  64U)
        /// 
        /// ' Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpfr_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpfr_inits2(mpfr_prec_t prec, params mpfr_t[] x /*...*/)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpfr_t a in x)
            {
                if (a != null)
                {
                    a.Initializing();
                    SafeNativeMethods.mpfr_init2(a.ToIntPtr(), prec);
                    a.Initialized();
                }
            }
        }

        /// <summary>
        /// Initialize all the <see cref="mpfr_t">mpfr_t</see> variables of the given list <paramref name="x"/>, set their precision to the default precision and their value to NaN.
        /// </summary>
        /// <param name="x">The list of floating-point numbers.</param>
        /// <remarks>
        /// <para>
        /// See <see cref="mpfr_init">mpfr_init</see> for more details.
        /// The list of floating-point numbers ends when it encounters a null pointer (whose type must also be <see cref="mpfr_t">mpfr_t</see>). 
        /// </para>
        /// <para>
        /// Warning!
        /// In a given program, some other libraries might change the default precision and not restore it.
        /// Thus it is safer to use <see cref="mpfr_inits2">mpfr_inits2</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new floating-point numbers x1, x2 and x3.
        /// mpfr_t x1 = new mpfr_t();
        /// mpfr_t x2 = new mpfr_t();
        /// mpfr_t x3 = new mpfr_t();
        /// 
        /// // Initialize the floating-point numbers.
        /// mpfr_lib.mpfr_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) != 0);
        /// 
        /// // Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpfr_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new floating-point numbers x1, x2 and x3.
        /// Dim x1 As mpfr_t = New mpfr_t()
        /// Dim x2 As mpfr_t = New mpfr_t()
        /// Dim x3 As mpfr_t = New mpfr_t()
        /// 
        /// ' Initialize the floating-point numbers.
        /// mpfr_lib.mpfr_inits(x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) &lt;&gt; 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) &lt;&gt; 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for the floating-point numbers.
        /// pfr_lib.mpfr_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpfr_inits(params mpfr_t[] x /*...*/)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpfr_t a in x)
            {
                if (a != null)
                {
                    a.Initializing();
                    SafeNativeMethods.mpfr_init(a.ToIntPtr());
                    a.Initialized();
                }
            }
        }

        /// <summary>
        /// Free the space occupied by all the <see cref="mpfr_t">mpfr_t</see> variables of the given list <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The list of floating-point numbers.</param>
        /// <remarks>
        /// <para>
        /// See <see cref="mpfr_clear">mpfr_clear</see> for more details.
        /// The list of floating-point numbers ends when it encounters a null pointer (whose type must also be <see cref="mpfr_t">mpfr_t</see>). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new floating-point numbers x1, x2 and x3.
        /// mpfr_t x1 = new mpfr_t();
        /// mpfr_t x2 = new mpfr_t();
        /// mpfr_t x3 = new mpfr_t();
        /// 
        /// // Initialize the floating-point numbers.
        /// mpfr_lib.mpfr_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) != 0);
        /// 
        /// // Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpfr_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new floating-point numbers x1, x2 and x3.
        /// Dim x1 As mpfr_t = New mpfr_t()
        /// Dim x2 As mpfr_t = New mpfr_t()
        /// Dim x3 As mpfr_t = New mpfr_t()
        /// 
        /// ' Initialize the floating-point numbers.
        /// mpfr_lib.mpfr_inits(x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x1) &lt;&gt;  0)
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x2) &lt;&gt;  0)
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x3) &lt;&gt;  0)
        /// 
        /// ' Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpfr_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpfr_clears(params mpfr_t[] x /*...*/)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpfr_t a in x) { if (a != null) mpfr_clear(a); }
        }

        /// <summary>
        /// Round <paramref name="x"/> according to <paramref name="rnd"/> with precision <paramref name="prec"/>, which must be an integer between <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see> and <see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see> (otherwise the behavior is undefined).
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="prec">The precision in bits.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="x"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="prec"/> is greater or equal to the precision of <paramref name="x"/>, then new space is allocated for the
        /// significand, and it is filled with zeros.
        /// Otherwise, the significand is rounded to precision <paramref name="prec"/> with the given direction.
        /// In both cases, the precision of <paramref name="x"/> is changed to <paramref name="prec"/>. 
        /// </para>
        /// <para>
        /// Here is an example of how to use <see cref="mpfr_prec_round">mpfr_prec_round</see> to implement Newton’s algorithm to compute
        /// the inverse of a, assuming x is already an approximation to n bits: 
        /// </para>
        /// <code language="C#">
        /// mpfr_set_prec (t, 2 * n);
        /// mpfr_set(t, a, mpfr_rnd_t.MPFR_RNDN);            /* round a to 2n bits */
        /// mpfr_mul(t, t, x, mpfr_rnd_t.MPFR_RNDN);         /* t is correct to 2n bits */
        /// mpfr_ui_sub(t, 1, t, mpfr_rnd_t.MPFR_RNDN);      /* high n bits cancel with 1 */
        /// mpfr_prec_round(t, n, mpfr_rnd_t.MPFR_RNDN);     /* t is correct to n bits */
        /// mpfr_mul(t, t, x, mpfr_rnd_t.MPFR_RNDN);         /* t is correct to n bits */
        /// mpfr_prec_round(x, 2 * n, mpfr_rnd_t.MPFR_RNDN); /* exact */
        /// mpfr_add(x, x, t, mpfr_rnd_t.MPFR_RNDN);         /* x is correct to 2n bits */
        /// </code> 
        /// <para>
        /// Warning! You must not use this function if x was initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a>). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_default_rounding_mode">mpfr_set_default_rounding_mode</seealso>
        /// <seealso cref="mpfr_get_default_rounding_mode ">mpfr_get_default_rounding_mode </seealso>
        /// <seealso cref="mpfr_can_round">mpfr_can_round</seealso>
        /// <seealso cref="mpfr_min_prec">mpfr_min_prec</seealso>
        /// <seealso cref="mpfr_print_rnd_mode">mpfr_print_rnd_mode</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x with 64-bit precision.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// 
        /// // Round x to precision 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_prec_round(x, 128U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that precision has changed to 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 128U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x with 64-bit precision.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// 
        /// ' Round x to precision 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_prec_round(x, 128U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that precision has changed to 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 128U)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_prec_round(mpfr_t x, mpfr_prec_t prec, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_prec_round(x.ToIntPtr(), prec, (int)rnd);
        }

        /// <summary>
        /// Return non-zero value if one is able to round correctly x to precision <paramref name="prec"/> with the direction <paramref name="rnd2"/>, and 0 otherwise.
        /// </summary>
        /// <param name="b">Floating-point number that approximates x.</param>
        /// <param name="err">The approximation error.</param>
        /// <param name="rnd1">The rounding direction of the approximation.</param>
        /// <param name="rnd2">The rounding direction of x.</param>
        /// <param name="prec">The precision of x.</param>
        /// <returns>Return non-zero value if one is able to round correctly x to precision <paramref name="prec"/> with the direction <paramref name="rnd2"/>, and 0 otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Assuming <paramref name="b"/> is an approximation of an unknown number x in the direction <paramref name="rnd1"/>
        /// with error at most two to the power E(<paramref name="b"/>) - <paramref name="err"/> where E(<paramref name="b"/>)
        /// is the exponent of <paramref name="b"/>, return a non-zero value if one is able to round correctly x to precision
        /// <paramref name="prec"/> with the direction <paramref name="rnd2"/> assuming an unbounded exponent range,
        /// and 0 otherwise (including for NaN and Inf).
        /// In other words, if the error on <paramref name="b"/> is bounded by two to the power k ulps, and <paramref name="b"/>
        /// has precision <paramref name="prec"/>, you should give err = <paramref name="prec"/> − k. 
        /// This function <b>does not modify</b> its arguments. 
        /// </para>
        /// <para>
        /// If <paramref name="rnd1"/> is <see cref="mpfr_rnd_t.MPFR_RNDN">mpfr_rnd_t.MPFR_RNDN</see> or
        /// <see cref="mpfr_rnd_t.MPFR_RNDF">mpfr_rnd_t.MPFR_RNDF</see>, then the the error is considered to be either positive
        /// or negative, thus the possible range is twice as large as with a directed rounding for <paramref name="rnd1"/>
        /// (with the same value of err). 
        /// </para>
        /// <para>
        /// When <paramref name="rnd2"/> is <see cref="mpfr_rnd_t.MPFR_RNDF"/>, let rnd3 be the opposite direction
        /// if <paramref name="rnd1"/> is a directed rounding, and <see cref="mpfr_rnd_t.MPFR_RNDN"/> if <paramref name="rnd1"/> is
        /// <see cref="mpfr_rnd_t.MPFR_RNDN"/> or <see cref="mpfr_rnd_t.MPFR_RNDF"/>.
        /// The returned value of <see cref="mpfr_can_round"/>(<paramref name="b"/>, err, <paramref name="rnd1"/>, <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <paramref name="prec"/>) 
        /// is non-zero iff after the call <see cref="mpfr_set"/>(y, <paramref name="b"/>, rnd3) with y of
        /// precision <paramref name="prec"/>, y is guaranteed to be a faithful rounding of x.
        /// </para>
        /// <para>
        /// Note: The <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> cannot be determined
        /// in general with this function. However, if it is known that the exact value is not exactly representable in precision
        /// prec, then one can use the following trick to determine the (non-zero) ternary value in any rounding mode <paramref name="rnd2"/>
        /// (note that <see cref="mpfr_rnd_t.MPFR_RNDZ"/> below can be replaced by any directed rounding mode):
        /// </para>
        /// <code language="C#">
        /// if (mpfr_can_round(b, err, MPFR_RNDN, MPFR_RNDZ, prec + (rnd2 == mpfr_rnd_t.MPFR_RNDN)))
        /// {
        ///      /* round the approximation ’b’ to the result ’r’ of ’prec’ bits with rounding mode ’rnd2’ and get the ternary value ’inex’ */
        ///      inex = mpfr_set(r, b, rnd2);
        /// }
        /// </code> 
        /// <para>
        /// Indeed, if <paramref name="rnd2"/> is <see cref="mpfr_rnd_t.MPFR_RNDN">mpfr_rnd_t.MPFR_RNDN</see>, this will check if one can round to prec + 1 bits with a directed rounding:
        /// if so, one can surely round to nearest to prec bits, and in addition one can determine the correct <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>,
        /// which would not be the case when b is near from a value exactly representable on prec bits. 
        /// </para>
        /// <para>
        /// A detailed example is available in the examples subdirectory, file can_round.c.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_default_rounding_mode">mpfr_set_default_rounding_mode</seealso>
        /// <seealso cref="mpfr_get_default_rounding_mode ">mpfr_get_default_rounding_mode </seealso>
        /// <seealso cref="mpfr_prec_round">mpfr_prec_round</seealso>
        /// <seealso cref="mpfr_min_prec">mpfr_min_prec</seealso>
        /// <seealso cref="mpfr_print_rnd_mode">mpfr_print_rnd_mode</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 0.100146.
        /// mpfr_t b = new mpfr_t();
        /// mpfr_lib.mpfr_init2(b, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(b, 0.100146, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// mpfr_exp_t err = 63;
        /// mpfr_rnd_t rnd1 = mpfr_rnd_t.MPFR_RNDN;
        /// mpfr_rnd_t rnd2 = mpfr_rnd_t.MPFR_RNDN;
        /// mpfr_prec_t prec = 53;
        /// 
        /// // Assert that we can round to 53 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_can_round(b, err, rnd1, rnd2, prec) != 0);
        /// 
        /// // Release unmanaged memory allocated for b.
        /// mpfr_lib.mpfr_clear(b);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 0.100146.
        /// Dim b As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(b, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(b, 0.100146, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// Dim err As mpfr_exp_t = 63
        /// Dim rnd1 As mpfr_rnd_t = mpfr_rnd_t.MPFR_RNDN
        /// Dim rnd2 As mpfr_rnd_t = mpfr_rnd_t.MPFR_RNDN
        /// Dim prec As mpfr_prec_t = 53 
        /// 
        /// ' Assert that we can round to 53 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_can_round(b,err,rnd1,rnd2,prec) &lt;&gt;  0)
        /// 
        /// ' Release unmanaged memory allocated for b.
        /// mpfr_lib.mpfr_clear(b)
        /// </code> 
        /// </example>
        public static int mpfr_can_round(/*const*/ mpfr_t b, mpfr_exp_t err, mpfr_rnd_t rnd1, mpfr_rnd_t rnd2, mpfr_prec_t prec)
        {
            if (b == null) throw new ArgumentNullException("b");
            return SafeNativeMethods.mpfr_can_round(b.ToIntPtr(), err, (int)rnd1, (int)rnd2, prec);
        }

        /// <summary>
        /// Return the minimal number of bits required to store the significand of <paramref name="x"/>, and 0 for special values, including 0.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <returns>Return the minimal number of bits required to store the significand of <paramref name="x"/>, and 0 for special values, including 0.</returns>
        /// <seealso cref="mpfr_set_default_rounding_mode">mpfr_set_default_rounding_mode</seealso>
        /// <seealso cref="mpfr_get_default_rounding_mode ">mpfr_get_default_rounding_mode </seealso>
        /// <seealso cref="mpfr_prec_round">mpfr_prec_round</seealso>
        /// <seealso cref="mpfr_can_round">mpfr_can_round</seealso>
        /// <seealso cref="mpfr_print_rnd_mode">mpfr_print_rnd_mode</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Rounding_Related_Functions">Rounding Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Related-Functions">GNU MPFR - Rounding Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the minimum precision in bits to store the value of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_min_prec(x) == 3);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the minimum precision in bits to store the value of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_min_prec(x) = 3)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static mpfr_prec_t mpfr_min_prec(/*const*/ mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_min_prec(x.ToIntPtr());
        }

        /// <summary>
        /// Return the exponent of <paramref name="x"/>, assuming that <paramref name="x"/> is a non-zero ordinary number and the significand is considered in [1/2,1).
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <returns>Return the exponent of <paramref name="x"/>, assuming that <paramref name="x"/> is a non-zero ordinary number and the significand is considered in [1/2,1).</returns>
        /// <remarks>
        /// <para>
        /// The behavior for NaN, infinity or zero is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert exp of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) == 7);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert exp of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) = 7)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_exp(/*const*/ mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_get_exp(x.ToIntPtr());
        }

        /// <summary>
        /// Set the exponent of <paramref name="x"/> if <paramref name="e"/> is in the current exponent range.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="e">The exponent value.</param>
        /// <returns>Return 0 (even if <paramref name="x"/> is not a non-zero ordinary number); otherwise, return a non-zero value.</returns>
        /// <remarks>
        /// <para>
        /// Set the exponent of <paramref name="x"/> to <paramref name="e"/> if x is a non-zero ordinary number and <paramref name="e"/>
        /// is in the current exponent range, and return 0; otherwise, return a non-zero value (<paramref name="x"/> is not changed). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_exp">mpfr_get_exp</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert exp of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) == 7);
        /// 
        /// // Set exponent of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_exp(x, 5) == 0);
        /// 
        /// // Assert x and its exp.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) == 5);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 25.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert exp of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) = 7)
        /// 
        /// ' Set exponent of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_exp(x, 5) = 0)
        /// 
        /// ' Assert x and its exp.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_exp(x) = 5)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 25.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_set_exp(mpfr_t x, mpfr_exp_t e)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_set_exp(x.ToIntPtr(), e);
        }

        /// <summary>
        /// Return the precision of <paramref name="x"/>, i.e., the number of bits used to store its significand. 
        /// </summary>
        /// <param name="x">The floating-point number.</param>
        /// <returns>The precision of <paramref name="x"/>, i.e., the number of bits used to store its significand.</returns>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x with 64-bit precision.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// 
        /// // Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 64U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x with 64-bit precision.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// 
        /// ' Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 64U)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static mpfr_prec_t mpfr_get_prec(/*const*/ mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_get_prec(x.ToIntPtr());
        }

        /// <summary>
        /// Reset the precision of <paramref name="x"/> to be exactly <paramref name="prec"/> bits, and set its value to NaN.
        /// </summary>
        /// <param name="x">The floating-point number.</param>
        /// <param name="prec">The precision of the significand in bits.</param>
        /// <remarks>
        /// <para>
        /// The previous value stored in <paramref name="x"/> is lost.
        /// It is equivalent to a call to <see cref="mpfr_clear">mpfr_clear</see>(x) followed by a call to <see cref="mpfr_init2">mpfr_init2</see>(x, prec),
        /// but more efficient as no allocation is done in case the current allocated space for the significand of
        /// <paramref name="x"/> is enough.
        /// The precision <paramref name="prec"/> can be any integer between <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see> and <see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see>.
        /// In case you want to keep the previous value stored in <paramref name="x"/>, use <see cref="mpfr_prec_round">mpfr_prec_round</see> instead. 
        /// </para>
        /// <para>
        /// Warning!
        /// You must not use this function if <paramref name="x"/> was initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Custom Interface</a>).
        /// </para>
        /// <para>
        /// The function is useful for changing the precision during a calculation.
        /// A typical use would be for adjusting the precision gradually in iterative algorithms like Newton-Raphson, making the
        /// computation precision closely match the actual accurate part of the numbers. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init(x);
        /// 
        /// // Set its precision to 64 bits.
        /// mpfr_lib.mpfr_set_prec(x, 64U);
        /// 
        /// // Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) == 64U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init(x)
        /// 
        /// ' Set its precision to 64 bits.
        /// mpfr_lib.mpfr_set_prec(x, 64U)
        /// 
        /// ' Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_prec(x) = 64U)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_set_prec(mpfr_t x, mpfr_prec_t prec)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_set_prec(x.ToIntPtr(), prec);
        }

        /// <summary>
        /// Reset the precision of <paramref name="x"/> to be exactly <paramref name="prec"/> bits.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="prec">The precision in bits.</param>
        /// <remarks>
        /// <para>
        /// The only difference with <see cref="mpfr_set_prec">mpfr_set_prec</see> is that <paramref name="prec"/> is assumed to be small enough
        /// so that the significand fits into the current allocated memory space for <paramref name="x"/>.
        /// Otherwise the behavior is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_eq">mpfr_eq</seealso>
        /// <seealso cref="mpfr_reldiff">mpfr_reldiff</seealso>
        /// <seealso cref="mpfr_mul_2exp">mpfr_mul_2exp</seealso>
        /// <seealso cref="mpfr_div_2exp">mpfr_div_2exp</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational y to 200 / 3.
        /// mpq_t y = new mpq_t();
        /// gmp_lib.mpq_init(y);
        /// gmp_lib.mpq_set_ui(y, 200, 3U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to y.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 128U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// Assert.IsTrue(x.ToString() == "0.6666666666666666666666666666666666666654e2");
        /// 
        /// // Change precision of x, and set its value to 10000 / 3.
        /// mpfr_lib.mpfr_set_prec_raw(x, 8U);
        /// gmp_lib.mpq_set_ui(y, 10000, 3U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// Assert.IsTrue(x.ToString() == "0.3328e4");
        /// 
        /// // Restore precision of x.
        /// mpfr_lib.mpfr_set_prec_raw(x, 128U);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpfr_clear(x);
        /// gmp_lib.mpq_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational y to 200 / 3.
        /// Dim y As mpq_t = New mpq_t()
        /// gmp_lib.mpq_init(y)
        /// gmp_lib.mpq_set_ui(y, 200, 3U)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to y.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 128U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// Assert.IsTrue(x.ToString() = "0.6666666666666666666666666666666666666654e2")
        /// 
        /// ' Change precision of x, and set its value to 10000 / 3.
        /// mpfr_lib.mpfr_set_prec_raw(x, 8U)
        /// gmp_lib.mpq_set_ui(y, 10000, 3U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_q(x, y, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// Assert.IsTrue(x.ToString() = "0.3328e4")
        /// 
        /// ' Restore precision of x.
        /// mpfr_lib.mpfr_set_prec_raw(x, 128U)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpfr_clear(x)
        /// gmp_lib.mpq_clear(y)
        /// </code> 
        /// </example>
        public static void mpfr_set_prec_raw(mpfr_t x, mpfr_prec_t prec)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_set_prec_raw(x.ToIntPtr(), prec);
        }

        /// <summary>
        /// Set the default precision to be exactly <paramref name="prec"/> bits, where <paramref name="prec"/> can be any integer between <see cref="MPFR_PREC_MIN">MPFR_PREC_MIN</see>and <see cref="MPFR_PREC_MAX">MPFR_PREC_MAX</see>.
        /// </summary>
        /// <param name="prec">The new default precision in bits.</param>
        /// <remarks>
        /// <para>
        /// The precision of a variable means the number of bits used to store its significand.
        /// All subsequent calls to <see cref="mpfr_init">mpfr_init</see> or <see cref="mpfr_inits">mpfr_inits</see> will use this precision,
        /// but previously initialized variables are unaffected.
        /// The default precision is set to 53 bits initially. 
        /// </para>
        /// <para>
        /// Note: when MPFR is built with the --enable-thread-safe configure option (<see cref="mpfr_buildopt_tls_p">mpfr_buildopt_tls_p</see>), the default precision is local to each thread.
        /// See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>, for more information. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_get_default_prec">mpfr_get_default_prec</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 128 bits.
        /// mpfr_lib.mpfr_set_default_prec(128U);
        /// 
        /// // Assert that the value of x is 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() == 128U);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 128 bits.
        /// mpfr_lib.mpfr_set_default_prec(128U)
        /// 
        /// ' Assert that the value of x is 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() = 128U)
        /// </code> 
        /// </example>
        public static void mpfr_set_default_prec(mpfr_prec_t prec)
        {
            SafeNativeMethods.mpfr_set_default_prec(prec);
        }

        /// <summary>
        /// Return the current default MPFR precision in bits.
        /// </summary>
        /// <returns>The current default MPFR precision in bits.</returns>
        /// <remarks>
        /// <para>
        /// See the documentation of <see cref="mpfr_set_default_prec">mpfr_set_default_prec</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init2(mpfr_t, mpfr_prec_t)">mpfr_init2(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_inits2(mpfr_prec_t, mpfr_t[])">mpfr_inits2(mpfr_prec_t, mpfr_t[])</seealso>
        /// <seealso cref="mpfr_clear(mpfr_t)">mpfr_clear(mpfr_t)</seealso>
        /// <seealso cref="mpfr_clears(mpfr_t[])">mpfr_clears(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_init(mpfr_t)">mpfr_init(mpfr_t)</seealso>
        /// <seealso cref="mpfr_inits(mpfr_t[])">mpfr_inits(mpfr_t[])</seealso>
        /// <seealso cref="mpfr_set_default_prec(mpfr_prec_t)">mpfr_set_default_prec(mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_set_prec(mpfr_t, mpfr_prec_t)">mpfr_set_prec(mpfr_t, mpfr_prec_t)</seealso>
        /// <seealso cref="mpfr_get_prec(mpfr_t)">mpfr_get_prec(mpfr_t)</seealso>
        /// <seealso cref="mpfr_lib"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Initialization_Functions">Initialization Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Assert that default precision is 53 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() == 53U);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Assert that default precision is 53 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_default_prec() = 53U)
        /// </code> 
        /// </example>
        public static mpfr_prec_t mpfr_get_default_prec(/*void*/)
        {
            return SafeNativeMethods.mpfr_get_default_prec();
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If the system does not support the IEEE 754 standard, <see cref="mpfr_set_d">mpfr_set_d</see> might not preserve the signed zeros.
        /// </para>
        /// <para>
        /// Note: If you want to store a floating-point constant to a <see cref="mpfr_t">mpfr_t</see>, you should use <see cref="mpfr_set_str">mpfr_set_str</see>
        /// (or one of the MPFR constant functions, such as <see cref="mpfr_const_pi">mpfr_const_pi</see> for Pi) instead of <see cref="mpfr_set_d">mpfr_set_d</see>.
        /// Otherwise the floating-point constant will be first converted into a reduced-precision (e.g., 53-bit) binary number before MPFR can work with it. 
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 128U);
        /// 
        /// // Set rop to -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(rop, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 128U)
        /// 
        /// ' Set rop to -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(rop, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_d(mpfr_t rop, double op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_d(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If the system does not support the IEEE 754 standard, <see cref="mpfr_set_flt">mpfr_set_flt</see> might not preserve the signed zeros.
        /// </para>
        /// <para>
        /// Note: If you want to store a floating-point constant to a <see cref="mpfr_t">mpfr_t</see>, you should use <see cref="mpfr_set_str">mpfr_set_str</see>
        /// (or one of the MPFR constant functions, such as <see cref="mpfr_const_pi">mpfr_const_pi</see> for Pi) instead of <see cref="mpfr_set_flt">mpfr_set_flt</see>.
        /// Otherwise the floating-point constant will be first converted into a reduced-precision (e.g., 53-bit) binary number before MPFR can work with it. 
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.0.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_flt(rop, (float)10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.0.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_flt(rop, (single)10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_flt(mpfr_t rop, float op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_flt(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op to 200.
        /// mpz_t op = new mpz_t();
        /// gmp_lib.mpz_init(op);
        /// gmp_lib.mpz_set_ui(op, 200U);
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that rop is 200.
        /// Assert.IsTrue(rop.ToString() == "0.200000000000000000000e3");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op to 200.
        /// Dim op As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init(op)
        /// gmp_lib.mpz_set_ui(op, 200U)
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_z(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that rop is 200.
        /// Assert.IsTrue(rop.ToString() = "0.200000000000000000000e3")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_set_z(mpfr_t rop, /*const*/ mpz_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_set_z(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="e"></param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op to 200.
        /// mpz_t op = new mpz_t();
        /// gmp_lib.mpz_init(op);
        /// gmp_lib.mpz_set_ui(op, 200U);
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_z_2exp(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that rop is 200.
        /// Assert.IsTrue(rop.ToString() == "0.640000000000000000000e4");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op to 200.
        /// Dim op As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init(op)
        /// gmp_lib.mpz_set_ui(op, 200U)
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_z_2exp(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that rop is 200.
        /// Assert.IsTrue(rop.ToString() = "0.640000000000000000000e4")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_set_z_2exp(mpfr_t rop, /*const*/ mpz_t op, mpfr_exp_t e, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_set_z_2exp(rop.ToIntPtr(), op.ToIntPtr(), e, (int)rnd);
        }

        /// <summary>
        /// Set the variable <paramref name="x"/> to NaN (Not-a-Number).
        /// </summary>
        /// <param name="x">The result floating-point number.</param>
        /// <remarks>
        /// <para>
        /// In <see cref="mpfr_set_nan">mpfr_set_nan</see>, the sign bit of the result is unspecified. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to NaN.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// mpfr_lib.mpfr_set_nan(x);
        /// 
        /// // Assert x is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) != 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to NaN.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// mpfr_lib.mpfr_set_nan(x)
        /// 
        /// ' Assert x is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(x) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_set_nan(mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_set_nan(x.ToIntPtr());
        }

        /// <summary>
        /// Set the variable <paramref name="x"/> to infinity.
        /// </summary>
        /// <param name="x">The result floating-point number.</param>
        /// <param name="sign">The sign of the result.</param>
        /// <remarks>
        /// <para>
        /// In <see cref="mpfr_set_inf">mpfr_set_inf</see>, <paramref name="x"/> is set to plus infinity iff <paramref name="sign"/> is nonnegative.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to -infinity.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// mpfr_lib.mpfr_set_inf(x, -1);
        /// 
        /// // Assert x is infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_inf_p(x) != 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to -infinity.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// mpfr_lib.mpfr_set_inf(x, -1)
        /// 
        /// ' Assert x is infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_inf_p(x) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_set_inf(mpfr_t x, int sign)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_set_inf(x.ToIntPtr(), sign);
        }

        /// <summary>
        /// Set the variable <paramref name="x"/> to zero.
        /// </summary>
        /// <param name="x">The result floating-point number.</param>
        /// <param name="sign">The sign of the result.</param>
        /// <remarks>
        /// <para>
        /// In<see cref="mpfr_set_zero">mpfr_set_zero</see>, <paramref name="x"/> is set to plus zero iff <paramref name="sign"/> is nonnegative.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to +0.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// mpfr_lib.mpfr_set_zero(x, 1);
        /// 
        /// // Assert x is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_zero_p(x) != 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to +0.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// mpfr_lib.mpfr_set_zero(x, 1)
        /// 
        /// ' Assert x is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_zero_p(x) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_set_zero(mpfr_t x, int sign)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_set_zero(x.ToIntPtr(), sign);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpf_t op = new mpf_t();
        /// gmp_lib.mpf_init_set_si(op, 1);
        /// 
        /// // Create and initialize new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpf_t = New mpf_t()
        /// gmp_lib.mpf_init_set_si(op, 1)
        /// 
        /// ' Create and initialize new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_f(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_set_f(mpfr_t rop, /*const*/ mpf_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_set_f(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/37c88d6c-8d02-2330-ad77-f20fb73d1677.htm">mpf_t</a>, after rounding it with respect to <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The erange flag is set if <paramref name="op"/> is NaN or an infinity, which do not exist in MPF.
        /// If <paramref name="op"/> is NaN, then <paramref name="rop"/> is undefined.
        /// If <paramref name="op"/> is +Inf (resp. -Inf), then <paramref name="rop"/> is set to the maximum (resp. minimum) value in the precision of the MPF number;
        /// if a future MPF version supports infinities, this behavior will be considered incorrect and will change (portable programs should assume that <paramref name="rop"/>
        /// is set either to this finite number or to an infinite number).
        /// Note that since MPFR currently has the same exponent type as MPF (but not with the same radix), the range of values is much larger in MPF than in MPFR, so that an
        /// overflow or underflow is not possible. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpf_t rop = new mpf_t();
        /// gmp_lib.mpf_init(rop);
        /// 
        /// // Set rop = op.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_f(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.4.
        /// Assert.IsTrue(gmp_lib.mpf_get_d(rop) == 10.4);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpf_clear(rop);
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpf_t = New mpf_t()
        /// gmp_lib.mpf_init(rop)
        /// 
        /// ' Set rop = op.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_f(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 10.4.
        /// Assert.IsTrue(gmp_lib.mpf_get_d(rop) = 10.4)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpf_clear(rop)
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_get_f(mpf_t /*mpf_ptr*/ rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_f(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_si(mpfr_t rop, int /*long*/ op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_si(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 128U);
        /// 
        /// // Set x to 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(x, 100U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 100.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 128U)
        /// 
        /// ' Set x to 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(x, 100U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 100.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_set_ui(mpfr_t rop, uint /*unsigned long*/ op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_ui(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="e"></param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si_2exp(rop, 10, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_si_2exp(mpfr_t rop, int /*long*/ op, mpfr_exp_t e, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_si_2exp(rop.ToIntPtr(), op, e, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> multiplied by two to the power <paramref name="e"/>, rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="e"></param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 320);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10 * 2^5.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui_2exp(rop, 10U, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 320.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 320)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_set_ui_2exp(mpfr_t rop, uint /*unsigned long*/ op, mpfr_exp_t e, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_ui_2exp(rop.ToIntPtr(), op, e, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that the input 0 is converted to +0 regardless of the rounding mode.
        /// <see cref="mpfr_set_q">mpfr_set_q</see> might fail if the numerator (or the denominator) can not be represented as a <see cref="mpfr_t">mpfr_t</see>. 
        /// </para>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational op to 1.
        /// mpq_t op = "1/1";
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational op to 1.
        /// Dim op As mpq_t = "1/1" 
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_q(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_set_q(mpfr_t rop, mpq_t /*mpq_srcptr*/ op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_q(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the string <paramref name="s"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="s"></param>
        /// <param name="base"></param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Retturn 0 if the entire string up to the final null character is a valid number in base <paramref name="base"/>; otherwise it is -1.</returns>
        /// <remarks>
        /// <para>
        /// See the documentation of <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> for a detailed description of the valid string formats.
        /// Contrary to <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see>,<see cref="mpfr_set_str">mpfr_set_str</see> requires the whole string to represent a valid floating-point number. 
        /// </para>
        /// <para>
        /// The meaning of the return value differs from other MPFR functions:
        /// it is 0 if the entire string up to the final null character is a valid number in base <paramref name="base"/>; otherwise it is -1,
        /// and <paramref name="rop"/> may have changed (users interested in the 
        /// <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> should use <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> instead). 
        /// </para>
        /// <para>
        /// Note: it is preferable to use <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr">O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr</see> if one wants to distinguish between an infinite <paramref name="rop"/> value
        /// coming from an infinite <paramref name="s"/> or from an overflow. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 0.0234.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// char_ptr value = new char_ptr("0.234e-4");
        /// Assert.IsTrue(mpfr_lib.mpfr_set_str(x, value, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that x is 0.0234.
        /// Assert.IsTrue(x.ToString() == "0.233999999999999999999e-4");
        /// 
        /// // Release unmanaged memory allocated for x and value.
        /// mpfr_lib.mpfr_clear(x);
        /// gmp_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 0.0234.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Dim value As char_ptr = New char_ptr("0.234e-4")
        /// Assert.IsTrue(mpfr_lib.mpfr_set_str(x, value, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that x is 0.0234.
        /// Assert.IsTrue(x.ToString() = "0.233999999999999999999e-4")
        /// 
        /// ' Release unmanaged memory allocated for x and value.
        /// mpfr_lib.mpfr_clear(x)
        /// gmp_lib.free(value)
        /// </code> 
        /// </example>
        public static int mpfr_set_str(mpfr_t rop, /*const*/ char_ptr /*char **/ s, int @base, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_set_str(rop.ToIntPtr(), s.ToIntPtr(), @base, (int)rnd);
        }

        /// <summary>
        /// Initialize <paramref name="x"/> and set its value from the string <paramref name="s"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="x">The result floating-point number.</param>
        /// <param name="s">String containing a floating-point number.</param>
        /// <param name="base">The base.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="x"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// See <see cref="mpfr_set_str">mpfr_set_str</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_init_set">mpfr_init_set</seealso>
        /// <seealso cref="mpfr_init_set_ui">mpfr_init_set_ui</seealso>
        /// <seealso cref="mpfr_init_set_si">mpfr_init_set_si</seealso>
        /// <seealso cref="mpfr_init_set_d">mpfr_init_set_d</seealso>
        /// <seealso cref="mpfr_init_set_z">mpfr_init_set_z</seealso>
        /// <seealso cref="mpfr_init_set_q">mpfr_init_set_q</seealso>
        /// <seealso cref="mpfr_init_set_f">mpfr_init_set_f</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Combined_Initialization_and_Assignment_Functions">Combined Initialization and Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Combined-Initialization-and-Assignment-Functions">GNU MPFR - Combined Initialization and Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t x = new mpfr_t();
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_str(x, "10.4", 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(x, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim x As mpfr_t = New mpfr_t()
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_str(x, "10.4", 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(x, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_init_set_str(mpfr_t x, /*const*/ string /*char **/ s, int @base, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            x.Initializing();
            char_ptr str = new char_ptr(s);
            int result = SafeNativeMethods.mpfr_init_set_str(x.ToIntPtr(), str.ToIntPtr(), @base, (int)rnd);
            x.Initialized();
            gmp_lib.free(str);
            return result;
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the absolute value of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Just changes or adjusts the sign if <paramref name="rop"/> and <paramref name="op"/> are the same variable,
        /// otherwise a rounding might occur if the precision of <paramref name="rop"/> is less than that of <paramref name="op"/>. 
        /// </para>
        /// <para>
        /// The sign rule also applies to NaN in order to mimic the IEEE 754 negate and abs operations, i.e.,
        /// for <see cref="mpfr_neg"/>, the sign is reversed, and for <see cref="mpfr_abs"/>, the sign is set
        /// to positive. But contrary to IEEE 754, the NaN flag is set as usual.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to -10.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = |op|.
        /// Assert.IsTrue(mpfr_lib.mpfr_abs(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 10) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to -10.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = |op|.
        /// Assert.IsTrue(mpfr_lib.mpfr_abs(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 10) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_abs(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_abs(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/> rounded toward the given direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function assigns new values to already initialized floats
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Initialization-Functions">GNU MPFR - Initialization Functions</a>).
        /// </para>
        /// <para>
        /// For <see cref="mpfr_set"/>, the sign of a NaN is propagated in order to mimic the IEEE 754 copy operation.
        /// But contrary to IEEE 754, the NaN flag is set as usual.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number rop to 10.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 128U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op to -210.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 128U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assign the value of op to rop.
        /// Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -210.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number rop to 10.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 128U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(rop, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op to -210.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 128U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assign the value of op to rop.
        /// Assert.IsTrue(mpfr_lib.mpfr_set(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -210.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_set(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_set(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to -<paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Just changes or adjusts the sign if <paramref name="rop"/> and <paramref name="op"/> are the same variable,
        /// otherwise a rounding might occur if the precision of <paramref name="rop"/> is less than that of <paramref name="op"/>. 
        /// </para>
        /// <para>
        /// The sign rule also applies to NaN in order to mimic the IEEE 754 negate and abs operations, i.e.,
        /// for <see cref="mpfr_neg"/>, the sign is reversed, and for <see cref="mpfr_abs"/>, the sign is set
        /// to positive. But contrary to IEEE 754, the NaN flag is set as usual.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number  to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = -op1.
        /// Assert.IsTrue(mpfr_lib.mpfr_neg(rop, op1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of z is -10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -10.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number  to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = -op1.
        /// Assert.IsTrue(mpfr_lib.mpfr_neg(rop, op1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of z is -10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_neg(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_neg(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return a non-zero value iff <paramref name="op"/> has its sign bit set (i.e., if it is negative, -0, or a NaN whose representation has its sign bit set). 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return a non-zero value iff <paramref name="op"/> has its sign bit set (i.e., if it is negative, -0, or a NaN whose representation has its sign bit set).</returns>
        /// <seealso cref="mpfr_setsign">mpfr_setsign</seealso>
        /// <seealso cref="mpfr_copysign">mpfr_copysign</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op to 200.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert sign of op..
        /// Assert.IsTrue(mpfr_lib.mpfr_signbit(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op to 200.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert sign of op..
        /// Assert.IsTrue(mpfr_lib.mpfr_signbit(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_signbit(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_signbit(op.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>, rounded toward the given direction <paramref name="rnd"/>, then set (resp. clear) its sign bit if <paramref name="s"/> is non-zero (resp. zero), even when <paramref name="op"/> is a NaN. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="s">The sign bit.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_signbit">mpfr_signbit</seealso>
        /// <seealso cref="mpfr_copysign">mpfr_copysign</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op to 200.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number rop to op.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init(rop);
        /// 
        /// // Set rop = -op.
        /// Assert.IsTrue(mpfr_lib.mpfr_setsign(rop, op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that rop is -200.
        /// Assert.IsTrue(rop.ToString() == "-0.20000000000000000e3");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op to 200.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number rop to op.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init(rop)
        /// 
        /// ' Set rop = -op.
        /// Assert.IsTrue(mpfr_lib.mpfr_setsign(rop, op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that rop is -200.
        /// Assert.IsTrue(rop.ToString() = "-0.20000000000000000e3")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_setsign(mpfr_t rop, /*const*/ mpfr_t op, int s, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_setsign(rop.ToIntPtr(), op.ToIntPtr(), s, (int)rnd);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op1"/>, rounded toward the given direction <paramref name="rnd"/>, then set its sign bit to that of <paramref name="op2"/> (even when <paramref name="op1"/> or <paramref name="op2"/> is a NaN). 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function is equivalent to <see cref="mpfr_setsign">mpfr_setsign</see>(<paramref name="rop"/>, <paramref name="op1"/>, <see cref="mpfr_signbit">mpfr_signbit</see>(<paramref name="op2"/>), <paramref name="rnd"/>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_signbit">mpfr_signbit</seealso>
        /// <seealso cref="mpfr_setsign">mpfr_setsign</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to -5.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Assert that rop = -512.
        /// Assert.IsTrue(mpfr_lib.mpfr_copysign(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -512) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to -5.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Assert that rop = -512.
        /// Assert.IsTrue(mpfr_lib.mpfr_copysign(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -512) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_copysign(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_copysign(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Put the scaled significand of <paramref name="op"/> (regarded as an integer, with the precision of <paramref name="op"/>) into <paramref name="rop"/>, and return the exponent exp (which may be outside the current exponent range) such that <paramref name="op"/> = <paramref name="rop"/> * 2^exp.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return the exponent exp (which may be outside the current exponent range) such that <paramref name="op"/> = <paramref name="rop"/> * 2^exp.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is zero, the minimal exponent emin is returned.
        /// If <paramref name="op"/> is NaN or an infinity, the erange flag is set, <paramref name="rop"/> is set to 0, and the the minimal exponent emin is returned.
        /// The returned exponent may be less than the minimal exponent emin of MPFR numbers in the current exponent range;
        /// in case the exponent is not representable in the <see cref="mpfr_exp_t">mpfr_exp_t</see> type, the erange flag is set and the minimal value of the <see cref="mpfr_exp_t">mpfr_exp_t</see> type is returned. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 8.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new integer rop.
        /// mpz_t rop = new mpz_t();
        /// gmp_lib.mpz_init(rop);
        /// 
        /// // Set rop such that op = rop * 2^exp.
        /// mpfr_exp_t exp = mpfr_lib.mpfr_get_z_2exp(rop, op);
        /// 
        /// // Assert rop and exp.
        /// Assert.IsTrue(rop.ToString() == "9223372036854775808" &amp;&amp; exp == -60);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpz_clear(rop);
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 8.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new integer rop.
        /// Dim rop As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init(rop)
        /// 
        /// ' Set rop such that op = rop * 2^exp.
        /// Dim exp As mpfr_exp_t = mpfr_lib.mpfr_get_z_2exp(rop, op) 
        /// 
        /// ' Assert rop and exp.
        /// Assert.IsTrue(rop.ToString() = "9223372036854775808" AndAlso exp = -60)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpz_clear(rop)
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_get_z_2exp(mpz_t /*mpz_ptr*/ rop, /*const*/ mpfr_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_z_2exp(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a float, using the rounding mode <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN, some fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is returned.
        /// If <paramref name="op"/> is ±Inf, an infinity of the same sign or the result of ±1.0/0.0 is returned.
        /// If <paramref name="op"/> is zero, the function returns a zero, trying to preserve its sign, if possible.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -123.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_flt(op, mpfr_rnd_t.MPFR_RNDN) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -123.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_flt(op, mpfr_rnd_t.MPFR_RNDN) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static float mpfr_get_flt(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_flt(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a double, using the rounding mode <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN, some fixed NaN (either quiet or signaling) or the result of 0.0/0.0 is returned.
        /// If <paramref name="op"/> is ±Inf, an infinity of the same sign or the result of ±1.0/0.0 is returned.
        /// If <paramref name="op"/> is zero, the function returns a zero, trying to preserve its sign, if possible.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -123.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(op, mpfr_rnd_t.MPFR_RNDN) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -123.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(op, mpfr_rnd_t.MPFR_RNDN) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static double mpfr_get_d(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_d(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return d and set <paramref name="exp"/> such that 0.5 &#8804; abs(d) &lt;1 and d * 2^<paramref name="exp"/> = <paramref name="op"/> rounded to double precision, using the given rounding mode. 
        /// </summary>
        /// <param name="exp">Pointer to returned exponent.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is zero, then a zero of the same sign (or an unsigned zero, if the implementation does
        /// not have signed zeros) is returned, and <paramref name="exp"/> is set to 0.
        /// If <paramref name="op"/> is NaN or an infinity, then the corresponding double precision value is returned,
        /// and <paramref name="exp"/> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="mpfr_get_d_2exp(ptr{int}, mpfr_t, mpfr_rnd_t)">mpfr_get_d_2exp(ptr{int}, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the absolute value of op is 0.5 * 2^4.
        /// int exp = 0;
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp(ref exp, op, mpfr_rnd_t.MPFR_RNDN) == -0.5);
        /// Assert.IsTrue(exp == 4);
        /// 
        /// // Release unmanaged memory allocated for x and exp.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the absolute value of op is 0.5 * 2^4.
        /// Dim exp As Integer = 0
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp( exp,op,mpfr_rnd_t.MPFR_RNDN)  =  -0.5)
        /// Assert.IsTrue(exp = 4)
        /// 
        /// ' Release unmanaged memory allocated for x and exp.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static double mpfr_get_d_2exp(ref int /*long **/ exp, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_d_2exp(ref exp, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return d and set <paramref name="exp"/> such that 0.5 &#8804; abs(d) &lt;1 and d * 2^<paramref name="exp"/> = <paramref name="op"/> rounded to double precision, using the given rounding mode. 
        /// </summary>
        /// <param name="exp">Pointer to returned exponent.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is zero, then a zero of the same sign (or an unsigned zero, if the implementation does
        /// not have signed zeros) is returned, and <paramref name="exp"/> is set to 0.
        /// If <paramref name="op"/> is NaN or an infinity, then the corresponding double precision value is returned,
        /// and <paramref name="exp"/> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="mpfr_get_d_2exp(ref int, mpfr_t, mpfr_rnd_t)">mpfr_get_d_2exp(ref int, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the absolute value of op is 0.5 * 2^4.
        /// ptr&lt;int&gt; exp = new ptr&lt;int&gt;(0);
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp(exp, op, mpfr_rnd_t.MPFR_RNDN) == -0.5);
        /// Assert.IsTrue(exp.Value == 4);
        /// 
        /// // Release unmanaged memory allocated for x and exp.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the absolute value of op is 0.5 * 2^4.
        /// Dim exp As ptr(Of int) =  New ptr(Of int)(0)
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d_2exp(exp, op, mpfr_rnd_t.MPFR_RNDN) = -0.5)
        /// Assert.IsTrue(exp.Value = 4)
        /// 
        /// ' Release unmanaged memory allocated for x and exp.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static double mpfr_get_d_2exp(ptr<int> /*long **/ exp, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (exp == null) throw new ArgumentNullException("exp");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_d_2exp(ref exp.Value, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="exp"/> and <paramref name="y"/> such that 0.5 &#8804; abs(<paramref name="y"/>) &lt; 1 and <paramref name="y"/> * 2^<paramref name="exp"/> = <paramref name="x"/> rounded to the precision of <paramref name="y"/>, using the given rounding mode.
        /// </summary>
        /// <param name="exp">The returned exponent.</param>
        /// <param name="y">The returned significand.</param>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="y"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="x"/> is zero, then <paramref name="y"/> is set to a zero of the same sign and <paramref name="exp"/> is set to 0.
        /// If <paramref name="x"/> is NaN or an infinity, then <paramref name="y"/> is set to the same value and <paramref name="exp"/> is undefined.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="mpfr_frexp(ptr{mpfr_exp_t}, mpfr_t, mpfr_t, mpfr_rnd_t)">mpfr_frexp(ptr{mpfr_exp_t}, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// 
        /// // Initialize exponent.
        /// mpfr_exp_t exp = 0;
        /// 
        /// // Find y and exp such that x = y * 2^exp where y in [0.5, 1).
        /// Assert.IsTrue(mpfr_lib.mpfr_frexp(ref exp, y, x, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of exp and y.
        /// Assert.IsTrue(y.ToString() == "0.781250000000000000000e0" &amp;&amp; exp == 7);
        /// 
        /// // Release unmanaged memory allocated for x, and y.
        /// mpfr_lib.mpfr_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// 
        /// ' Initialize exponent.
        /// Dim exp As mpfr_exp_t = 0 
        /// 
        /// ' Find y and exp such that x = y * 2^exp where y in [0.5, 1).
        /// Assert.IsTrue(mpfr_lib.mpfr_frexp( exp,y,x,mpfr_rnd_t.MPFR_RNDN)  =  0)
        /// 
        /// ' Assert the value of exp and y.
        /// Assert.IsTrue(y.ToString() = "0.781250000000000000000e0" AndAlso exp = 7)
        /// 
        /// ' Release unmanaged memory allocated for x, and y.
        /// mpfr_lib.mpfr_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_frexp(ref mpfr_exp_t /*mpfr_exp_t **/ exp, mpfr_t y, /*const*/ mpfr_t x, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_frexp(ref exp.Value, y.ToIntPtr(), x.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="exp"/> and <paramref name="y"/> such that 0.5 &#8804; abs(<paramref name="y"/>) &lt; 1 and <paramref name="y"/> * 2^<paramref name="exp"/> = <paramref name="x"/> rounded to the precision of <paramref name="y"/>, using the given rounding mode.
        /// </summary>
        /// <param name="exp">The returned exponent.</param>
        /// <param name="y">The returned significand.</param>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="y"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="x"/> is zero, then <paramref name="y"/> is set to a zero of the same sign and <paramref name="exp"/> is set to 0.
        /// If <paramref name="x"/> is NaN or an infinity, then <paramref name="y"/> is set to the same value and <paramref name="exp"/> is undefined.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="mpfr_frexp(ref mpfr_exp_t, mpfr_t, mpfr_t, mpfr_rnd_t)">mpfr_frexp(ref mpfr_exp_t, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// 
        /// // Initialize exponent.
        /// ptr&lt;mpfr_exp_t&gt; exp = new ptr&lt;mpfr_exp_t&gt;(0);
        /// 
        /// // Find y and exp such that x = y * 2^exp where y in [0.5, 1).
        /// Assert.IsTrue(mpfr_lib.mpfr_frexp(exp, y, x, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of exp and y.
        /// Assert.IsTrue(y.ToString() == "0.781250000000000000000e0" &amp;&amp; exp.Value == 7);
        /// 
        /// // Release unmanaged memory allocated for x, and y.
        /// mpfr_lib.mpfr_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// 
        /// ' Initialize exponent.
        /// Dim exp As ptr(Of mpfr_exp_t) =  New ptr(Of mpfr_exp_t)(0)
        /// 
        /// ' Find y and exp such that x = y * 2^exp where y in [0.5, 1).
        /// Assert.IsTrue(mpfr_lib.mpfr_frexp(exp, y, x, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of exp and y.
        /// Assert.IsTrue(y.ToString() = "0.781250000000000000000e0" AndAlso exp.Value = 7)
        /// 
        /// ' Release unmanaged memory allocated for x, and y.
        /// mpfr_lib.mpfr_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_frexp(ptr<mpfr_exp_t> /*mpfr_exp_t **/ exp, mpfr_t y, /*const*/ mpfr_t x, mpfr_rnd_t rnd)
        {
            if (exp == null) throw new ArgumentNullException("exp");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_frexp(ref exp.Value.Value, y.ToIntPtr(), x.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a long after rounding it with respect to <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
        /// If <paramref name="op"/> is too big for the return type, the function returns the maximum
        /// or the minimum of the corresponding C type, depending on the direction of the overflow;
        /// the erange flag is set too.
        /// When there is no such range error, if the return value differs from <paramref name="op"/>,
        /// i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
        /// See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -123.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(op, mpfr_rnd_t.MPFR_RNDN) == -123);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -123.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_si(op, mpfr_rnd_t.MPFR_RNDN) = -123)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int /*long*/ mpfr_get_si(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_si(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to an unsigned long after rounding it with respect to <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The converted floating-point number.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN, 0 is returned and the erange flag is set.
        /// If <paramref name="op"/> is too big for the return type, the function returns the maximum
        /// or the minimum of the corresponding C type, depending on the direction of the overflow;
        /// the erange flag is set too.
        /// When there is no such range error, if the return value differs from <paramref name="op"/>,
        /// i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
        /// See also mpfr_fits_slong_p, mpfr_fits_ulong_p, mpfr_fits_intmax_p and mpfr_fits_uintmax_p.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to 123.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) == 123);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to 123.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 123.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_ui(op, mpfr_rnd_t.MPFR_RNDN) = 123)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static uint /*unsigned long*/ mpfr_get_ui(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_ui(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a string of digits in base <paramref name="b"/>, with rounding in the direction <paramref name="rnd"/>, where <paramref name="n"/> is either zero (see below) or the number of significant digits output in the string; in the latter case, <paramref name="n"/> must be greater or equal to 2. 
        /// </summary>
        /// <param name="str">The result string.</param>
        /// <param name="expptr">The returned exponent.</param>
        /// <param name="b">The base.</param>
        /// <param name="n">The number of digits in the result string.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return the converted string of digits.</returns>
        /// <remarks>
        /// <para>
        /// The base may vary from 2 to 62; otherwise the function does nothing and immediately returns a null pointer.
        /// </para>
        /// <para>
        /// If the input is NaN, then the returned string is ‘@NaN@’ and the NaN flag is set.
        /// If the input is +Inf (resp. −Inf), then the returned string is ‘@Inf@’ (resp. ‘-@Inf@’).
        /// </para>
        /// <para>
        /// If the input number is a finite number, the exponent is written through the pointer <paramref name="expptr"/>
        /// (for input 0, the current minimal exponent is written); the type <see cref="mpfr_exp_t">mpfr_exp_t</see> is large enough to hold the exponent in all cases.
        /// </para>
        /// <para>
        /// The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
        /// For example, the number -3.1416 would be returned as "-31416" in the string and 1 written at <paramref name="expptr"/>.
        /// If <paramref name="rnd"/> is to nearest, and <paramref name="op"/> is exactly in the middle of two consecutive possible outputs,
        /// the one with an even significand is chosen, where both significands are considered with the exponent of <paramref name="op"/>.
        /// Note that for an odd base, this may not correspond to an even last digit: for example with 2 digits in base 7, (14) and a half is rounded to (15) which is 12 in decimal,
        /// (16) and a half is rounded to (20) which is 14 in decimal, and (26) and a half is rounded to (26) which is 20 in decimal. 
        /// </para>
        /// <para>
        /// If <paramref name="n"/> is zero, the number of digits of the significand is chosen large enough so that re-reading the printed value with the same precision,
        /// assuming both output and input use rounding to nearest, will recover the original value of <paramref name="op"/>.
        /// More precisely, in most cases, the chosen precision of <paramref name="str"/> is the minimal precision m depending only on p = PREC(<paramref name="op"/>)
        /// and <paramref name="b"/> that satisfies the above property, i.e., m = 1 + ceil(p * log(2) / log(<paramref name="b"/>)), with p replaced by p - 1 if <paramref name="b"/>
        /// is a power of 2, but in some very rare cases, it might be m + 1 (the smallest case for bases up to 62 is when p equals 186564318007 for bases 7 and 49).
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is a null pointer, space for the significand is allocated using the allocation function
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>)
        /// and a pointer to the string is returned (unless the base is invalid).
        /// To free the returned string, you must use <see cref="mpfr_free_str">mpfr_free_str</see>. 
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is not a null pointer, it should point to a block of storage large enough for the significand.
        /// A safe block size (sufficient for any value) is max(<paramref name="n"/> + 2, 7) if <paramref name="n"/> is not zero;
        /// if <paramref name="n"/> is zero, replace it by m + 1, as discussed above. 
        /// The extra two bytes are for a possible minus sign, and for the terminating null character, and the value 7 accounts
        /// for -@Inf@ plus the terminating null character.
        /// The pointer to the string <paramref name="str"/> is returned (unless the base is invalid). 
        /// </para>
        /// <para>
        /// Like in usual functions, the inexact flag is set iff the result is inexact.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="mpfr_get_str(char_ptr, ptr{mpfr_exp_t}, int, size_t, mpfr_t, mpfr_rnd_t)">mpfr_get_str(char_ptr, ptr{mpfr_exp_t}, int, size_t, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -8.
        /// mpfr_exp_t exp = 0;
        /// char_ptr value = mpfr_lib.mpfr_get_str(char_ptr.Zero, ref exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN);
        /// Assert.IsTrue(value.ToString() == "-800000000000000000000");
        /// Assert.IsTrue(exp == 1);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// gmp_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -8.
        /// Dim exp As mpfr_exp_t = 0
        /// Dim value As char_ptr = mpfr_lib.mpfr_get_str(char_ptr.Zero, ref exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN)
        /// Assert.IsTrue(value.ToString() = "-800000000000000000000")
        /// Assert.IsTrue(exp = 1)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// gmp_lib.free(value)
        /// </code> 
        /// </example>
        public static char_ptr /*char **/ mpfr_get_str(char_ptr /*char **/ str, ref mpfr_exp_t /*mpfr_exp_t **/ expptr, int b, size_t n, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new char_ptr(SafeNativeMethods.mpfr_get_str_x86(str.ToIntPtr(), ref expptr.Value, b, (uint)n, op.ToIntPtr(), (int)rnd));
            else
                return new char_ptr(SafeNativeMethods.mpfr_get_str_x64(str.ToIntPtr(), ref expptr.Value, b, n, op.ToIntPtr(), (int)rnd));
        }
        /// <summary>
        /// Convert <paramref name="op"/> to a string of digits in base <paramref name="b"/>, with rounding in the direction <paramref name="rnd"/>, where <paramref name="n"/> is either zero (see below) or the number of significant digits output in the string; in the latter case, <paramref name="n"/> must be greater or equal to 2. 
        /// </summary>
        /// <param name="str">The result string.</param>
        /// <param name="expptr">The returned exponent.</param>
        /// <param name="b">The base.</param>
        /// <param name="n">The number of digits in the result string.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return the converted string of digits.</returns>
        /// <remarks>
        /// <para>
        /// The base may vary from 2 to 62; otherwise the function does nothing and immediately returns a null pointer.
        /// </para>
        /// <para>
        /// If the input is NaN, then the returned string is ‘@NaN@’ and the NaN flag is set.
        /// If the input is +Inf (resp. −Inf), then the returned string is ‘@Inf@’ (resp. ‘-@Inf@’).
        /// </para>
        /// <para>
        /// If the input number is a finite number, the exponent is written through the pointer <paramref name="expptr"/>
        /// (for input 0, the current minimal exponent is written); the type <see cref="mpfr_exp_t">mpfr_exp_t</see> is large enough to hold the exponent in all cases.
        /// </para>
        /// <para>
        /// The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
        /// For example, the number -3.1416 would be returned as "-31416" in the string and 1 written at <paramref name="expptr"/>.
        /// If <paramref name="rnd"/> is to nearest, and <paramref name="op"/> is exactly in the middle of two consecutive possible outputs,
        /// the one with an even significand is chosen, where both significands are considered with the exponent of <paramref name="op"/>.
        /// Note that for an odd base, this may not correspond to an even last digit: for example with 2 digits in base 7, (14) and a half is rounded to (15) which is 12 in decimal,
        /// (16) and a half is rounded to (20) which is 14 in decimal, and (26) and a half is rounded to (26) which is 20 in decimal. 
        /// </para>
        /// <para>
        /// If <paramref name="n"/> is zero, the number of digits of the significand is chosen large enough so that re-reading the printed value with the same precision,
        /// assuming both output and input use rounding to nearest, will recover the original value of <paramref name="op"/>.
        /// More precisely, in most cases, the chosen precision of <paramref name="str"/> is the minimal precision m depending only on p = PREC(<paramref name="op"/>)
        /// and <paramref name="b"/> that satisfies the above property, i.e., m = 1 + ceil(p * log(2) / log(<paramref name="b"/>)), with p replaced by p - 1 if <paramref name="b"/>
        /// is a power of 2, but in some very rare cases, it might be m + 1 (the smallest case for bases up to 62 is when p equals 186564318007 for bases 7 and 49).
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is a null pointer, space for the significand is allocated using the allocation function
        /// (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>)
        /// and a pointer to the string is returned (unless the base is invalid).
        /// To free the returned string, you must use <see cref="mpfr_free_str">mpfr_free_str</see>. 
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is not a null pointer, it should point to a block of storage large enough for the significand.
        /// A safe block size (sufficient for any value) is max(<paramref name="n"/> + 2, 7) if <paramref name="n"/> is not zero;
        /// if <paramref name="n"/> is zero, replace it by m + 1, as discussed above. 
        /// The extra two bytes are for a possible minus sign, and for the terminating null character, and the value 7 accounts
        /// for -@Inf@ plus the terminating null character.
        /// The pointer to the string <paramref name="str"/> is returned (unless the base is invalid). 
        /// </para>
        /// <para>
        /// Like in usual functions, the inexact flag is set iff the result is inexact.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="mpfr_get_str(char_ptr, ref mpfr_exp_t, int, size_t, mpfr_t, mpfr_rnd_t)">mpfr_get_str(char_ptr, ref mpfr_exp_t, int, size_t, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of op is -8.
        /// ptr&lt;mpfr_exp_t&gt; exp = new ptr&lt;mpfr_exp_t&gt;(0);
        /// char_ptr value = mpfr_lib.mpfr_get_str(char_ptr.Zero, exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN);
        /// Assert.IsTrue(value.ToString() == "-800000000000000000000");
        /// Assert.IsTrue(exp.Value == 1);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// gmp_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, -8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of op is -8.
        /// Dim exp As ptr(Of mpfr_exp_t) =  New ptr(Of mpfr_exp_t)(0)
        /// Dim value As char_ptr = mpfr_lib.mpfr_get_str(char_ptr.Zero, exp, 10, 0, op, mpfr_rnd_t.MPFR_RNDN)
        /// Assert.IsTrue(value.ToString() = "-800000000000000000000")
        /// Assert.IsTrue(exp.Value = 1)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// gmp_lib.free(value)
        /// </code> 
        /// </example>
        public static char_ptr /*char **/ mpfr_get_str(char_ptr /*char **/ str, ptr<mpfr_exp_t> /*mpfr_exp_t **/ expptr, int b, size_t n, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (expptr == null) throw new ArgumentNullException("expptr");
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new char_ptr(SafeNativeMethods.mpfr_get_str_x86(str.ToIntPtr(), ref expptr.Value.Value, b, (uint)n, op.ToIntPtr(), (int)rnd));
            else
                return new char_ptr(SafeNativeMethods.mpfr_get_str_x64(str.ToIntPtr(), ref expptr.Value.Value, b, n, op.ToIntPtr(), (int)rnd));
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a <see cref="mpz_t"/>, after rounding it with respect to <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN or an infinity, the erange flag is set, <paramref name="rop"/> is set to 0, and 0 is returned.
        /// Otherwise the return value is zero when rop is equal to op (i.e., when <paramref name="op"/> is an integer), positive when it
        /// is greater than <paramref name="op"/>, and negative when it is smaller than <paramref name="op"/>; moreover, if <paramref name="rop"/>
        /// differs from <paramref name="op"/>, i.e., if <paramref name="op"/> is not an integer, the inexact flag is set.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.6.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new integer rop.
        /// mpz_t rop = new mpz_t();
        /// gmp_lib.mpz_init(rop);
        /// 
        /// // Set rop = op.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_z(rop, op, mpfr_rnd_t.MPFR_RNDN) == 2);
        /// 
        /// // Assert that the value of rop is 11.
        /// Assert.IsTrue(gmp_lib.mpz_get_ui(rop) == 11);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpz_clear(rop);
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.6.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new integer rop.
        /// Dim rop As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init(rop)
        /// 
        /// ' Set rop = op.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_z(rop, op, mpfr_rnd_t.MPFR_RNDN) = 2)
        /// 
        /// ' Assert that the value of rop is 11.
        /// Assert.IsTrue(gmp_lib.mpz_get_ui(rop) = 11)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpz_clear(rop)
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_get_z(mpz_t /*mpz_ptr*/ rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_get_z(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a <see cref="mpq_t"/>. 
        /// </summary>
        /// <param name="rop">The result rational number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is NaN or an infinity, the erange flag is set, <paramref name="rop"/> is set to 0, and 0 is returned.
        /// Otherwise the conversion is always exact.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_free_str">mpfr_free_str</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.6.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new rational rop.
        /// mpq_t rop = new mpq_t();
        /// gmp_lib.mpq_init(rop);
        /// 
        /// // Set rop = op.
        /// mpfr_lib.mpfr_get_q(rop, op);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "5967269506265907/562949953421312");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpq_clear(rop);
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.6.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.6, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new rational rop.
        /// Dim rop As mpq_t = New mpq_t()
        /// gmp_lib.mpq_init(rop)
        /// 
        /// ' Set rop = op.
        /// mpfr_lib.mpfr_get_q(rop, op)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "5967269506265907/562949953421312")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// gmp_lib.mpq_clear(rop)
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static void mpfr_get_q(mpq_t /*mpz_ptr*/ rop, /*const*/ mpfr_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.mpfr_get_q(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Free a string allocated by <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str">O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str</see> using the unallocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
        /// </summary>
        /// <param name="str">Pointer to string.</param>
        /// <remarks>
        /// <para>
        /// The block is assumed to be strlen(<paramref name="str"/>) + 1 bytes.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_flt">mpfr_get_flt</seealso>
        /// <seealso cref="mpfr_get_d">mpfr_get_d</seealso>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_d_2exp"/>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_frexp"/>
        /// <seealso cref="mpfr_get_z_2exp">mpfr_get_z_2exp</seealso>
        /// <seealso cref="mpfr_get_z">mpfr_get_z</seealso>
        /// <seealso cref="mpfr_get_q">mpfr_get_q</seealso>
        /// <seealso cref="mpfr_get_f">mpfr_get_f</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create pointer to unmanaged character string pointer.
        /// ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
        /// mpfr_t r = "12345e6";
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) == 10);
        /// Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
        /// mpfr_lib.mpfr_free_str(str.Value);
        /// 
        /// // Release unmanaged memory allocated for r.
        /// mpfr_lib.mpfr_clear(r);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create pointer to unmanaged character string pointer.
        /// Dim str As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
        /// Dim r As mpfr_t = "12345e6"
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) = 10)
        /// Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
        /// mpfr_lib.mpfr_free_str(str.Value)
        /// 
        /// ' Release unmanaged memory allocated for r.
        /// mpfr_lib.mpfr_clear(r)
        /// </code> 
        /// </example>
        public static void mpfr_free_str(char_ptr /*char **/ str)
        {
            if (str == null) throw new ArgumentNullException("str");
            SafeNativeMethods.mpfr_free_str(str.ToIntPtr());
        }

        /// <summary>
        /// Generate a uniformly distributed random float.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="state">The state of the random number generator.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The floating-point number <paramref name="rop"/> can be seen as if a random real number is generated according to the continuous
        /// uniform distribution on the interval [0, 1] and then rounded in the direction <paramref name="rnd"/>. 
        /// </para>
        /// <para>
        /// The second argument is a <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/f7e5846d-548d-3bf3-74ac-219fde42a041.htm">gmp_randstate_t</a>
        /// structure which should be created using the GMP gmp_randinit function (see the GMP manual). 
        /// </para>
        /// <para>
        /// Note: the note for <see cref="mpfr_urandomb">mpfr_urandomb</see> holds too.
        /// Moreover, the exact number (the random value to be rounded) and the next random state do not depend on the current exponent
        /// range and the rounding mode.
        /// However, they depend on the target precision: from the same state of the random generator, if the precision of the destination
        /// is changed, then the value may be completely different (and the state of the random generator is different too).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_urandomb">mpfr_urandomb</seealso>
        /// <seealso cref="mpfr_nrandom">mpfr_nrandom</seealso>
        /// <seealso cref="mpfr_grandom">mpfr_grandom</seealso>
        /// <seealso cref="mpfr_erandom">mpfr_erandom</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// gmp_randstate_t state = new gmp_randstate_t();
        /// gmp_lib.gmp_randinit_mt(state);
        /// gmp_lib.gmp_randseed_ui(state, 100000U);
        /// 
        /// // Create, initialize, and set the value of rop to NaN.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Generate a random integer in the range [0, 1].
        /// Assert.IsTrue(mpfr_lib.mpfr_urandom(rop, state, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state);
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As gmp_randstate_t = New gmp_randstate_t()
        /// gmp_lib.gmp_randinit_mt(state)
        /// gmp_lib.gmp_randseed_ui(state, 100000U)
        /// 
        /// ' Create, initialize, and set the value of rop to NaN.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Generate a random integer in the range [0, 1].
        /// Assert.IsTrue(mpfr_lib.mpfr_urandom(rop, state, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state)
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_urandom(mpfr_t rop, gmp_randstate_t state, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.mpfr_urandom(rop.ToIntPtr(), state.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Generate one random float according to a standard normal gaussian distribution (with mean zero and variance one).
        /// </summary>
        /// <param name="rop">The first result operand floating-point number.</param>
        /// <param name="state">The state of the random number generator.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="rop"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The floating-point number <paramref name="rop"/> can be seen as if a random real number were
        /// generated according to the standard normal gaussian distribution and then rounded in the direction <paramref name="rnd"/>. 
        /// </para>
        /// <para>
        /// The <see cref="gmp_randstate_t"/> argument should be created using the GMP gmp_randinit function (see the GMP manual). 
        /// </para>
        /// <para>
        /// Note: the note for <see cref="mpfr_urandomb">mpfr_urandomb</see> holds too.
        /// In addition, the exponent range and the rounding mode might have a side effect on the next random state. 
        /// </para>
        /// <para>
        /// Note: <see cref="mpfr_nrandom"/> is much more efficient than <see cref="mpfr_grandom"/>, especially for large precision.
        /// Thus <see cref="mpfr_grandom"/> is marked as deprecated and will be removed in a future release.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_urandomb">mpfr_urandomb</seealso>
        /// <seealso cref="mpfr_urandom">mpfr_urandom</seealso>
        /// <seealso cref="mpfr_erandom">mpfr_erandom</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// gmp_randstate_t state = new gmp_randstate_t();
        /// gmp_lib.gmp_randinit_mt(state);
        /// gmp_lib.gmp_randseed_ui(state, 100000U);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Generate one Gaussian random floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_nrandom(rop, state, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state);
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As gmp_randstate_t = New gmp_randstate_t()
        /// gmp_lib.gmp_randinit_mt(state)
        /// gmp_lib.gmp_randseed_ui(state, 100000U)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Generate one Gaussian random floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_grandom(rop, state, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state)
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_nrandom(mpfr_t rop, gmp_randstate_t state, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.mpfr_nrandom(rop.ToIntPtr(), state.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Generate one random float according to an exponential distribution, with mean one.
        /// </summary>
        /// <param name="rop">The first result operand floating-point number.</param>
        /// <param name="state">The state of the random number generator.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="rop"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Generate one random floating-point number according to an exponential distribution, with mean one.
        /// Other characteristics are identical to <see cref="mpfr_nrandom"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_urandomb">mpfr_urandomb</seealso>
        /// <seealso cref="mpfr_urandom">mpfr_urandom</seealso>
        /// <seealso cref="mpfr_nrandom">mpfr_erandom</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// gmp_randstate_t state = new gmp_randstate_t();
        /// gmp_lib.gmp_randinit_mt(state);
        /// gmp_lib.gmp_randseed_ui(state, 100000U);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Generate one exponential random floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_erandom(rop, state, mpfr_rnd_t.MPFR_RNDN) &lt; 0);
        /// 
        /// // Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state);
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As gmp_randstate_t = New gmp_randstate_t()
        /// gmp_lib.gmp_randinit_mt(state)
        /// gmp_lib.gmp_randseed_ui(state, 100000U)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Generate one exponential random floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_erandom(rop, state, mpfr_rnd_t.MPFR_RNDN) &lt; 0)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state)
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_erandom(mpfr_t rop, gmp_randstate_t state, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.mpfr_erandom(rop.ToIntPtr(), state.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Generate two random floats according to a standard normal gaussian distribution (with mean zero and variance one).
        /// </summary>
        /// <param name="rop1">The first result operand floating-point number.</param>
        /// <param name="rop2">The second result operand floating-point number.</param>
        /// <param name="state">The state of the random number generator.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The combination of the ternary values is returned like with <see cref="mpfr_sin_cos">mpfr_sin_cos</see>. If <paramref name="rop2"/> is a null pointer, the second ternary value is assumed to be 0 (note that the encoding of the only ternary value is not the same as the usual encoding for functions that return only one result). Otherwise the ternary value of a random number is always non-zero.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="rop2"/> is a null pointer, then only one value is generated and stored in <paramref name="rop1"/>. 
        /// </para>
        /// <para>
        /// The floating-point number <paramref name="rop1"/> (and <paramref name="rop2"/>) can be seen as if a random real number were
        /// generated according to the standard normal Gaussian distribution and then rounded
        /// in the direction <paramref name="rnd"/>. 
        /// </para>
        /// <para>
        /// The <see cref="gmp_randstate_t"/> argument should be created using the GMP gmp_randinit function (see the GMP manual). 
        /// </para>
        /// <para>
        /// Note: the note for <see cref="mpfr_urandomb">mpfr_urandomb</see> holds too.
        /// In addition, the exponent range and the rounding mode might have a side effect on the next random state. 
        /// </para>
        /// <para>
        /// Note: <see cref="mpfr_nrandom"/> is much more efficient than <see cref="mpfr_grandom"/>, especially for large precision.
        /// Thus <see cref="mpfr_grandom"/> is marked as deprecated and will be removed in a future release.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_urandomb">mpfr_urandomb</seealso>
        /// <seealso cref="mpfr_urandom">mpfr_urandom</seealso>
        /// <seealso cref="mpfr_nrandom">mpfr_nrandom</seealso>
        /// <seealso cref="mpfr_erandom">mpfr_erandom</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// gmp_randstate_t state = new gmp_randstate_t();
        /// gmp_lib.gmp_randinit_mt(state);
        /// gmp_lib.gmp_randseed_ui(state, 100000U);
        /// 
        /// // Create and initialize a new floating-point number rop1.
        /// mpfr_t rop1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop1, 64U);
        /// 
        /// // Create and initialize a new floating-point number rop2.
        /// mpfr_t rop2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop2, 64U);
        /// 
        /// // Generate two Gaussian random floating-point numbers.
        /// Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, rop2, state, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Generate one Gaussian random floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, null, state, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Free all memory occupied by state, rop1, and rop2.
        /// gmp_lib.gmp_randclear(state);
        /// mpfr_lib.mpfr_clears(rop1, rop2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As gmp_randstate_t = New gmp_randstate_t()
        /// gmp_lib.gmp_randinit_mt(state)
        /// gmp_lib.gmp_randseed_ui(state, 100000U)
        /// 
        /// ' Create and initialize a new floating-point number rop1.
        /// Dim rop1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop1, 64U)
        /// 
        /// ' Create and initialize a new floating-point number rop2.
        /// Dim rop2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop2, 64U)
        /// 
        /// ' Generate two Gaussian random floating-point numbers.
        /// Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, rop2, state, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Generate one Gaussian random floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_grandom(rop1, Nothing, state, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Free all memory occupied by state, rop1, and rop2.
        /// gmp_lib.gmp_randclear(state)
        /// mpfr_lib.mpfr_clears(rop1, rop2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_grandom(mpfr_t rop1, mpfr_t rop2, gmp_randstate_t state, mpfr_rnd_t rnd)
        {
            if (rop1 == null) throw new ArgumentNullException("rop1");
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.mpfr_grandom(rop1.ToIntPtr(), rop2 == null ? IntPtr.Zero : rop2.ToIntPtr(), state.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Generate a uniformly distributed random float in the interval 0 &#8804; <paramref name="rop"/> &lt; 1.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="state">The state of the random number generator.</param>
        /// <returns>Return 0, unless the exponent is not in the current exponent range, in which case <paramref name="rop"/> is set to NaN and a non-zero value is returned (this should never happen in practice, except in very specific cases).</returns>
        /// <remarks>
        /// <para>
        /// More precisely, the number can be seen as a float with a random non-normalized significand and exponent 0,
        /// which is then normalized (thus if e denotes the exponent after normalization, then the least -e significant bits of the significand are always 0).
        /// </para>
        /// <para>
        /// The second argument is a <a href="https://machinecognitis.github.io/Math.Gmp.Native/html/f7e5846d-548d-3bf3-74ac-219fde42a041.htm">gmp_randstate_t</a> structure
        /// which should be created using the GMP gmp_randinit function (see the GMP manual).
        /// </para>
        /// <para>
        /// Note: for a given version of MPFR, the returned value of rop and the new value of state (which controls further random values) do not depend on the machine word size.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_urandom">mpfr_urandom</seealso>
        /// <seealso cref="mpfr_nrandom">mpfr_nrandom</seealso>
        /// <seealso cref="mpfr_grandom">mpfr_grandom</seealso>
        /// <seealso cref="mpfr_erandom">mpfr_erandom</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// gmp_randstate_t state = new gmp_randstate_t();
        /// gmp_lib.gmp_randinit_mt(state);
        /// gmp_lib.gmp_randseed_ui(state, 100000U);
        /// 
        /// // Create, initialize, and set the value of rop to NaN.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Generate a random integer in the range [0, 1).
        /// Assert.IsTrue(mpfr_lib.mpfr_urandomb(rop, state) == 0);
        /// 
        /// // Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state);
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As gmp_randstate_t = New gmp_randstate_t()
        /// gmp_lib.gmp_randinit_mt(state)
        /// gmp_lib.gmp_randseed_ui(state, 100000U)
        /// 
        /// ' Create, initialize, and set the value of rop to NaN.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Generate a random integer in the range [0, 1).
        /// Assert.IsTrue(mpfr_lib.mpfr_urandomb(rop, state) = 0)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// gmp_lib.gmp_randclear(state)
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_urandomb(mpfr_t rop, gmp_randstate_t state)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.mpfr_urandomb(rop.ToIntPtr(), state.ToIntPtr());
        }

        /// <summary>
        /// Equivalent to <see cref="mpfr_nexttoward">mpfr_nexttoward</see> where y is plus infinity. 
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <seealso cref="mpfr_nexttoward">mpfr_nexttoward</seealso>
        /// <seealso cref="mpfr_nextbelow">mpfr_nextbelow</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Move x to next above and then next below.
        /// mpfr_lib.mpfr_nextabove(x);
        /// mpfr_lib.mpfr_nextbelow(x);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Move x to next above and then next below.
        /// mpfr_lib.mpfr_nextabove(x)
        /// mpfr_lib.mpfr_nextbelow(x)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_nextabove(mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_nextabove(x.ToIntPtr());
        }

        /// <summary>
        /// Equivalent to <see cref="mpfr_nexttoward">mpfr_nexttoward</see> where y is minus infinity. 
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <seealso cref="mpfr_nexttoward">mpfr_nexttoward</seealso>
        /// <seealso cref="mpfr_nextabove">mpfr_nextabove</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Move x to next above and then next below.
        /// mpfr_lib.mpfr_nextabove(x);
        /// mpfr_lib.mpfr_nextbelow(x);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Move x to next above and then next below.
        /// mpfr_lib.mpfr_nextabove(x)
        /// mpfr_lib.mpfr_nextbelow(x)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static void mpfr_nextbelow(mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_nextbelow(x.ToIntPtr());
        }

        /// <summary>
        /// Replace <paramref name="x"/> by the next floating-point number in the direction of <paramref name="y"/>. 
        /// </summary>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <remarks>
        /// <para>
        /// If <paramref name="x"/> or <paramref name="y"/> is NaN, set <paramref name="x"/> to NaN; note that the NaN flag is set as usual.
        /// If <paramref name="x"/> and <paramref name="y"/> are equal, <paramref name="x"/> is unchanged.
        /// Otherwise, if <paramref name="x"/> is different from <paramref name="y"/>, replace <paramref name="x"/>
        /// by the next floating-point number (with the precision of <paramref name="x"/> and the current exponent range)
        /// in the direction of <paramref name="y"/> (the infinite values are seen as the smallest and largest
        /// floating-point numbers).
        /// If the result is zero, it keeps the same sign.
        /// No underflow, overflow, or inexact exception is raised. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_nextabove">mpfr_nextabove</seealso>
        /// <seealso cref="mpfr_nextbelow">mpfr_nextbelow</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// mpfr_t y1 = "11.0";
        /// mpfr_t y2 = "12.0";
        /// 
        /// // Move x toward y1 then y2.
        /// mpfr_lib.mpfr_nexttoward(x, y1);
        /// mpfr_lib.mpfr_nexttoward(x, y2);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x, y1, and y2.
        /// mpfr_lib.mpfr_clears(x, y1, y2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// Dim y1 As mpfr_t = "11.0"
        /// Dim y2 As mpfr_t = "12.0" 
        /// 
        /// ' Move x toward y1 then y2.
        /// mpfr_lib.mpfr_nexttoward(x, y1)
        /// mpfr_lib.mpfr_nexttoward(x, y2)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x, y1, and y2.
        /// mpfr_lib.mpfr_clears(x, y1, y2, Nothing)
        /// </code> 
        /// </example>
        public static void mpfr_nexttoward(mpfr_t x, /*const*/ mpfr_t y)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            SafeNativeMethods.mpfr_nexttoward(x.ToIntPtr(), y.ToIntPtr());
        }

        /// <summary>
        /// Print to stdout the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
        /// </summary>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters written or a negative value if an error occurred.</returns>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpfr_printf(/*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            return mpfr_vprintf(template, arguments);
        }

        /// <summary>
        /// Print to stdout the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
        /// </summary>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters written or a negative value if an error occurred.</returns>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpfr_vprintf(/*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            va_list va_args = new va_list(arguments);
            char_ptr format = new char_ptr(template);
            int result = SafeNativeMethods.mpfr_vprintf(format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            gmp_lib.free(format);
            return result;
        }

        /// <summary>
        /// Print to the stream <paramref name="stream"/> the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
        /// </summary>
        /// <param name="stream">The output stream.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters written or a negative value if an error occurred.</returns>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpfr_fprintf(ptr<FILE> /*FILE **/ stream, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            return mpfr_vfprintf(stream, template, arguments);
        }

        /// <summary>
        /// Print to the stream <paramref name="stream"/> the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>.
        /// </summary>
        /// <param name="stream">The output stream.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters written or a negative value if an error occurred.</returns>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpfr_vfprintf(ptr<FILE> /*FILE **/ stream, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            va_list va_args = new va_list(arguments);
            char_ptr format = new char_ptr(template);
            int result = SafeNativeMethods.mpfr_vfprintf(stream.Value.Value, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            gmp_lib.free(format);
            return result;
        }

        /// <summary>
        /// Write output as a null terminated string in a block of memory allocated using the allocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
        /// </summary>
        /// <param name="str">The output string.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>The return value is the number of characters written in the string, excluding the null-terminator, or a negative value if an error occurred, in which case the contents of <paramref name="str"/> are undefined.</returns>
        /// <remarks>
        /// <para>
        /// A pointer to the block is stored in <paramref name="str"/>. The block of memory must be freed using <see cref="mpfr_free_str">mpfr_free_str</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create pointer to unmanaged character string pointer.
        /// ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
        /// mpfr_t r = "12345e6";
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) == 10);
        /// Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
        /// gmp_lib.free(str.Value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create pointer to unmanaged character string pointer.
        /// Dim str As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
        /// Dim r As mpfr_t = "12345e6"
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Re", r) = 10)
        /// Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
        /// gmp_lib.free(str.Value)
        /// </code> 
        /// </example>
        public static int mpfr_asprintf(ptr<char_ptr> /*char ***/ str, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            return mpfr_vasprintf(str, template, arguments);
        }

        /// <summary>
        /// Write output as a null terminated string in a block of memory allocated using the allocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
        /// </summary>
        /// <param name="str">The output string.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>The return value is the number of characters written in the string, excluding the null-terminator, or a negative value if an error occurred, in which case the contents of <paramref name="str"/> are undefined.</returns>
        /// <remarks>
        /// <para>
        /// A pointer to the block is stored in <paramref name="str"/>. The block of memory must be freed using <see cref="mpfr_free_str">mpfr_free_str</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="mpfr_vasprintf(ptr{char_ptr}, string, object[])">mpfr_vasprintf(ptr{char_ptr}, string, object[])</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// char_ptr str = new char_ptr();
        /// 
        /// mpfr_t r = "12345e6";
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Re", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// gmp_lib.free(str);
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Rf", r) == 18);
        /// Assert.IsTrue(str.ToString() == "12345000000.000000");
        /// gmp_lib.free(str);
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Rg", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// gmp_lib.free(str);
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(ref str, "%Ra", r) == 15);
        /// Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
        /// gmp_lib.free(str);
        /// mpfr_lib.mpfr_clear(r);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim str As char_ptr = New char_ptr()
        /// 
        /// Dim r As mpfr_t = "12345e6"
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Re",r)  =  10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// gmp_lib.free(str)
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Rf",r)  =  18)
        /// Assert.IsTrue(str.ToString() = "12345000000.000000")
        /// gmp_lib.free(str)
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Rg",r)  =  10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// gmp_lib.free(str)
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf( str,"%Ra",r)  =  15)
        /// Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
        /// gmp_lib.free(str)
        /// mpfr_lib.mpfr_clear(r)
        /// </code> 
        /// </example>
        public static int mpfr_vasprintf(ref char_ptr /*char ***/ str, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            va_list va_args = new va_list(arguments);
            char_ptr format = new char_ptr(template);
            int result = SafeNativeMethods.mpfr_vasprintf(ref str.Pointer, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            gmp_lib.free(format);
            return result;
        }

        /// <summary>
        /// Write output as a null terminated string in a block of memory allocated using the allocation function (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>).
        /// </summary>
        /// <param name="str">The output string.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>The return value is the number of characters written in the string, excluding the null-terminator, or a negative value if an error occurred, in which case the contents of <paramref name="str"/> are undefined.</returns>
        /// <remarks>
        /// <para>
        /// A pointer to the block is stored in <paramref name="str"/>. The block of memory must be freed using <see cref="mpfr_free_str">mpfr_free_str</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="mpfr_vasprintf(ref char_ptr, string, object[])">mpfr_vasprintf(ref char_ptr, string, object[])</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
        /// 
        /// mpfr_t r = "12345e6";
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Re", r) == 10);
        /// Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
        /// gmp_lib.free(str.Value);
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rf", r) == 18);
        /// Assert.IsTrue(str.Value.ToString() == "12345000000.000000");
        /// gmp_lib.free(str.Value);
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rg", r) == 10);
        /// Assert.IsTrue(str.Value.ToString() == "1.2345e+10");
        /// gmp_lib.free(str.Value);
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Ra", r) == 15);
        /// Assert.IsTrue(str.Value.ToString() == "0x2.dfd1c04p+32");
        /// gmp_lib.free(str.Value);
        ///  mpfr_lib.mpfr_clear(r);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim str As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
        /// 
        /// Dim r As mpfr_t = "12345e6"
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Re", r) = 10)
        /// Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
        /// gmp_lib.free(str.Value)
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rf", r) = 18)
        /// Assert.IsTrue(str.Value.ToString() = "12345000000.000000")
        /// gmp_lib.free(str.Value)
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Rg", r) = 10)
        /// Assert.IsTrue(str.Value.ToString() = "1.2345e+10")
        /// gmp_lib.free(str.Value)
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Ra", r) = 15)
        ///  Assert.IsTrue(str.Value.ToString() = "0x2.dfd1c04p+32")
        /// gmp_lib.free(str.Value)
        /// mpfr_lib.mpfr_clear(r)
        /// </code> 
        /// </example>
        public static int mpfr_vasprintf(ptr<char_ptr> /*char ***/ str, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            if (str == null) throw new ArgumentNullException("str");
            va_list va_args = new va_list(arguments);
            char_ptr format = new char_ptr(template);
            int result = SafeNativeMethods.mpfr_vasprintf(ref str.Value.Pointer, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            gmp_lib.free(format);
            return result;
        }

        /// <summary>
        /// Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The output buffer.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters written in the array buf not counting the terminating null character or a negative value if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// No overlap is permitted between buf and the other arguments.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Allocate unmanaged string with 50 characters.
        /// char_ptr str = new char_ptr(".................................................");
        /// mpfr_t r = "12345e6";
        /// 
        /// // Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Re", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rf", r) == 18);
        /// Assert.IsTrue(str.ToString() == "12345000000.000000");
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rg", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Ra", r) == 15);
        /// Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
        /// mpfr_lib.mpfr_clear(r);
        /// gmp_lib.free(str);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Allocate unmanaged string with 50 characters.
        /// Dim str As char_ptr = New char_ptr(".................................................")
        /// Dim r As mpfr_t = "12345e6" 
        /// 
        /// ' Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Re", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rf", r) = 18)
        /// Assert.IsTrue(str.ToString() = "12345000000.000000")
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Rg", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Ra", r) = 15)
        /// Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
        /// mpfr_lib.mpfr_clear(r)
        /// gmp_lib.free(str)
        /// </code> 
        /// </example>
        public static int mpfr_sprintf(char_ptr /*char **/ buf, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            return mpfr_vsprintf(buf, template, arguments);
        }

        /// <summary>
        /// Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The output buffer.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters written in the array buf not counting the terminating null character or a negative value if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// No overlap is permitted between buf and the other arguments.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create string.
        /// char_ptr str = new char_ptr(".........................................");
        /// 
        /// mpfr_t r = "12345e6";
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Re", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rf", r) == 18);
        /// Assert.IsTrue(str.ToString() == "12345000000.000000");
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rg", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Ra", r) == 15);
        /// Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
        /// mpfr_lib.mpfr_clear(r);
        /// 
        /// // Free allocated unmanaged memory.
        /// gmp_lib.free(str);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create string.
        /// Dim str As char_ptr = New char_ptr(".........................................")
        /// 
        /// Dim r As mpfr_t = "12345e6"
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Re", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rf", r) = 18)
        /// Assert.IsTrue(str.ToString() = "12345000000.000000")
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Rg", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Ra", r) = 15)
        /// Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
        /// mpfr_lib.mpfr_clear(r)
        /// 
        /// ' Free allocated unmanaged memory.
        /// gmp_lib.free(str)
        /// </code> 
        /// </example>
        public static int mpfr_vsprintf(char_ptr /*char **/ buf, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            va_list va_args = new va_list(arguments);
            char_ptr format = new char_ptr(template);
            int result = SafeNativeMethods.mpfr_vsprintf(buf.ToIntPtr(), format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            gmp_lib.free(format);
            return result;
        }

        /// <summary>
        /// Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The output buffer.</param>
        /// <param name="n">The number of characters written to the output buffer.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters that would have been written had n been sufficiently large, not counting the terminating null character, or a negative value if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="n"/> is zero, nothing is written and <paramref name="buf"/> may be a null pointer,
        /// otherwise, the <paramref name="n"/> - 1 first characters are written in <paramref name="buf"/> and
        /// the <paramref name="n"/>-th is a null character.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_vsnprintf">mpfr_vsnprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Allocate unmanaged string with 50 characters.
        /// char_ptr str = new char_ptr(".................................................");
        /// mpfr_t r = "12345e6";
        /// 
        /// // Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Re", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rf", r) == 18);
        /// Assert.IsTrue(str.ToString() == "12345000000.000000");
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rg", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Ra", r) == 15);
        /// Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
        /// mpfr_lib.mpfr_clear(r);
        /// gmp_lib.free(str);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Allocate unmanaged string with 50 characters.
        /// Dim str As char_ptr = New char_ptr(".................................................")
        /// Dim r As mpfr_t = "12345e6" 
        /// 
        /// ' Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Re", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rf", r) = 18)
        /// Assert.IsTrue(str.ToString() = "12345000000.000000")
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Rg", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 41, "%Ra", r) = 15)
        /// Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
        /// mpfr_lib.mpfr_clear(r)
        /// gmp_lib.free(str)
        /// </code> 
        /// </example>
        public static int mpfr_snprintf(char_ptr /*char **/ buf, size_t n, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            return mpfr_vsnprintf(buf, n, template, arguments);
        }

        /// <summary>
        /// Form a null-terminated string corresponding to the optional <paramref name="arguments"/> under the control of the template string <paramref name="template"/>, and print it in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The output buffer.</param>
        /// <param name="n">The number of characters written to the output buffer.</param>
        /// <param name="template">Format string. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">Formatted Output Functions</a>.</param>
        /// <param name="arguments">Arguments.</param>
        /// <returns>Return the number of characters that would have been written had n been sufficiently large, not counting the terminating null character, or a negative value if an error occurred.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="n"/> is zero, nothing is written and <paramref name="buf"/> may be a null pointer,
        /// otherwise, the <paramref name="n"/> - 1 first characters are written in <paramref name="buf"/> and
        /// the <paramref name="n"/>-th is a null character.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fprintf">mpfr_fprintf</seealso>
        /// <seealso cref="mpfr_vfprintf">mpfr_vfprintf</seealso>
        /// <seealso cref="mpfr_printf">mpfr_printf</seealso>
        /// <seealso cref="mpfr_vprintf">mpfr_vprintf</seealso>
        /// <seealso cref="mpfr_sprintf">mpfr_sprintf</seealso>
        /// <seealso cref="mpfr_vsprintf">mpfr_vsprintf</seealso>
        /// <seealso cref="mpfr_snprintf">mpfr_snprintf</seealso>
        /// <seealso cref="mpfr_asprintf">mpfr_asprintf</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Formatted_Output_Functions">Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// char_ptr str = new char_ptr(".........................................");
        /// 
        /// mpfr_t r = "12345e6";
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Re", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rf", r) == 18);
        /// Assert.IsTrue(str.ToString() == "12345000000.000000");
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rg", r) == 10);
        /// Assert.IsTrue(str.ToString() == "1.2345e+10");
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Ra", r) == 15);
        /// Assert.IsTrue(str.ToString() == "0x2.dfd1c04p+32");
        /// mpfr_lib.mpfr_clear(r);
        /// 
        /// gmp_lib.free(str);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim str As char_ptr = New char_ptr(".........................................")
        /// 
        /// Dim r As mpfr_t = "12345e6"
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Re", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rf", r) = 18)
        /// Assert.IsTrue(str.ToString() = "12345000000.000000")
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Rg", r) = 10)
        /// Assert.IsTrue(str.ToString() = "1.2345e+10")
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 41, "%Ra", r) = 15)
        /// Assert.IsTrue(str.ToString() = "0x2.dfd1c04p+32")
        /// mpfr_lib.mpfr_clear(r)
        /// 
        /// gmp_lib.free(str)
        /// </code> 
        /// </example>
        public static int mpfr_vsnprintf(char_ptr /*char **/ buf, size_t n, /*const*/ string /*char **/ template, params object[] arguments /*...*/)
        {
            int result;
            va_list va_args = new va_list(arguments);
            char_ptr format = new char_ptr(template);
            if (IntPtr.Size == 4)
                result = SafeNativeMethods.mpfr_vsnprintf_x86(buf.ToIntPtr(), (uint)n, format.ToIntPtr(), va_args.ToIntPtr());
            else
                result = SafeNativeMethods.mpfr_vsnprintf_x64(buf.ToIntPtr(), n, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            gmp_lib.free(format);
            return result;
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus infinity for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus zero for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus zero for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-1, ±Inf) returns 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+1, y) returns 1 for any y, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, ±0) returns 1 for any x, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, y) returns NaN for finite negative x and finite non-integer y. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus zero for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus infinity for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// Note: When 0 is of integer type, it is regarded as +0 by these functions.
        /// We do not use the usual limit rules in this case, as these rules are not used for pow.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_pow_ui">mpfr_pow_ui</seealso>
        /// <seealso cref="mpfr_pow_si">mpfr_pow_si</seealso>
        /// <seealso cref="mpfr_pow_z">mpfr_pow_z</seealso>
        /// <seealso cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</seealso>
        /// <seealso cref="mpfr_ui_pow">mpfr_ui_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 3.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1^op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 3.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1^op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_pow(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_pow(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus infinity for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus zero for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus zero for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-1, ±Inf) returns 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+1, y) returns 1 for any y, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, ±0) returns 1 for any x, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, y) returns NaN for finite negative x and finite non-integer y. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus zero for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus infinity for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// Note: When 0 is of integer type, it is regarded as +0 by these functions.
        /// We do not use the usual limit rules in this case, as these rules are not used for pow.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_pow_ui">mpfr_pow_ui</seealso>
        /// <seealso cref="mpfr_pow_si">mpfr_pow_si</seealso>
        /// <seealso cref="mpfr_pow_z">mpfr_pow_z</seealso>
        /// <seealso cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</seealso>
        /// <seealso cref="mpfr_ui_pow">mpfr_ui_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1^3.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow_si(rop, op1, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1^3.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow_si(rop, op1, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_pow_si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_pow_si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus infinity for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus zero for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus zero for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-1, ±Inf) returns 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+1, y) returns 1 for any y, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, ±0) returns 1 for any x, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, y) returns NaN for finite negative x and finite non-integer y. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus zero for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus infinity for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// Note: When 0 is of integer type, it is regarded as +0 by these functions.
        /// We do not use the usual limit rules in this case, as these rules are not used for pow.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_pow_ui">mpfr_pow_ui</seealso>
        /// <seealso cref="mpfr_pow_si">mpfr_pow_si</seealso>
        /// <seealso cref="mpfr_pow_z">mpfr_pow_z</seealso>
        /// <seealso cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</seealso>
        /// <seealso cref="mpfr_ui_pow">mpfr_ui_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1^3.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow_ui(rop, op1, 3U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1^3.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow_ui(rop, op1, 3U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_pow_ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_pow_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus infinity for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus zero for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus zero for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-1, ±Inf) returns 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+1, y) returns 1 for any y, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, ±0) returns 1 for any x, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, y) returns NaN for finite negative x and finite non-integer y. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus zero for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus infinity for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// Note: When 0 is of integer type, it is regarded as +0 by these functions.
        /// We do not use the usual limit rules in this case, as these rules are not used for pow.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_pow_ui">mpfr_pow_ui</seealso>
        /// <seealso cref="mpfr_pow_si">mpfr_pow_si</seealso>
        /// <seealso cref="mpfr_pow_z">mpfr_pow_z</seealso>
        /// <seealso cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</seealso>
        /// <seealso cref="mpfr_ui_pow">mpfr_ui_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 2^10.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_pow_ui(rop, 2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1024.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1024.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 2^10.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_pow_ui(rop, 2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1024.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1024.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_ui_pow_ui(mpfr_t rop, uint /*unsigned long int*/ op1, uint /*unsigned long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_ui_pow_ui(rop.ToIntPtr(), op1, op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus infinity for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus zero for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus zero for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-1, ±Inf) returns 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+1, y) returns 1 for any y, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, ±0) returns 1 for any x, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, y) returns NaN for finite negative x and finite non-integer y. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus zero for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus infinity for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// Note: When 0 is of integer type, it is regarded as +0 by these functions.
        /// We do not use the usual limit rules in this case, as these rules are not used for pow.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_pow_ui">mpfr_pow_ui</seealso>
        /// <seealso cref="mpfr_pow_si">mpfr_pow_si</seealso>
        /// <seealso cref="mpfr_pow_z">mpfr_pow_z</seealso>
        /// <seealso cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</seealso>
        /// <seealso cref="mpfr_ui_pow">mpfr_ui_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 2^op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_pow(rop, 2, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1024.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1024.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 2^op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_pow(rop, 2, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1024.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1024.0)
        /// 
        ///  ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_ui_pow(mpfr_t rop, uint /*unsigned long int*/ op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_ui_pow(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> raised to <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the pow function: 
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus infinity for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus infinity for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus or minus zero for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(±0, y) returns plus zero for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-1, ±Inf) returns 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+1, y) returns 1 for any y, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, ±0) returns 1 for any x, even a NaN. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, y) returns NaN for finite negative x and finite non-integer y. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, -Inf) returns plus infinity for 0 &lt; abs(x) &lt; 1, and plus zero for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(x, +Inf) returns plus zero for 0 &lt; abs(x) &lt; 1, and plus infinity for abs(x) &gt; 1. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus zero for y a negative odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus zero for y negative and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns minus infinity for y a positive odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(-Inf, y) returns plus infinity for y positive and not an odd integer. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// pow(+Inf, y) returns plus zero for y negative, and plus infinity for y positive. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// Note: When 0 is of integer type, it is regarded as +0 by these functions.
        /// We do not use the usual limit rules in this case, as these rules are not used for pow.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_pow_ui">mpfr_pow_ui</seealso>
        /// <seealso cref="mpfr_pow_si">mpfr_pow_si</seealso>
        /// <seealso cref="mpfr_pow_z">mpfr_pow_z</seealso>
        /// <seealso cref="mpfr_ui_pow_ui">mpfr_ui_pow_ui</seealso>
        /// <seealso cref="mpfr_ui_pow">mpfr_ui_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new integer op2 to -210.
        /// mpz_t op2 = "3";
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1^op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 1000.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new integer op2 to -210.
        /// Dim op2 As mpz_t = "3" 
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1^op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_pow_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1000.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 1000.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_pow_z(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpz_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_pow_z(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the square root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to -0 if <paramref name="op"/> is -0, to be consistent with the IEEE 754 standard.
        /// Set <paramref name="rop"/> to NaN if <paramref name="op"/> is negative. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_sqrt_ui">mpfr_sqrt_ui</seealso>
        /// <seealso cref="mpfr_rec_sqrt">mpfr_rec_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 100.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = sqrt(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 100.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// ' Set rop = sqrt(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sqrt(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sqrt(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the square root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to -0 if <paramref name="op"/> is -0, to be consistent with the IEEE 754 standard.
        /// Set <paramref name="rop"/> to NaN if <paramref name="op"/> is negative. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_sqrt_ui">mpfr_sqrt_ui</seealso>
        /// <seealso cref="mpfr_rec_sqrt">mpfr_rec_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = sqrt(100).
        /// Assert.IsTrue(mpfr_lib.mpfr_sqrt_ui(rop, 100U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = sqrt(100).
        /// Assert.IsTrue(mpfr_lib.mpfr_sqrt_ui(rop, 100U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_sqrt_ui(mpfr_t rop, uint /*unsigned long*/ op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_sqrt_ui(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the reciprocal square root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to +Inf if <paramref name="op"/> is ±0, +0 if <paramref name="op"/> is +Inf,
        /// and NaN if <paramref name="op"/> is negative.
        /// Warning!
        /// Therefore the result on -0 is different from the one of the rSqrt function recommended by the IEEE 754-2008 standard (Section 9.2.1), which is -Inf instead of +Inf. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_sqrt_ui">mpfr_sqrt_ui</seealso>
        /// <seealso cref="mpfr_rec_sqrt">mpfr_rec_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 1 / sqrt(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rec_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.200000000000000000003e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 1 / sqrt(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rec_sqrt(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.200000000000000000003e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rec_sqrt(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_rec_sqrt(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_sum">mpfr_sum</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to -210.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        ///  mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 + op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_add(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -200.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -200.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to -210.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 + op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_add(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -200.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -200.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_add(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_add(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to -210.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to -210.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sub(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_sub(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands
        /// (for types having no signed zeros, 0 is considered positive).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to -210.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 * op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2100.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to -210.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 * op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2100.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_mul(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_div(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_div(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_div(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_sum">mpfr_sum</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 + 210.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_ui(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 + 210.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_ui(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_add_ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_add_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 - 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 92.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 92.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 - 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 92.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 92.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sub_ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_sub_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op2 to -210.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10 - y.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_sub(rop, 10U, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop, and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op2 to -210.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// im rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10 - y.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_sub(rop, 10U, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_ui_sub(mpfr_t rop, uint /*unsigned long*/ op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_ui_sub(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands
        /// (for types having no signed zeros, 0 is considered positive).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 * 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 800.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 800.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 * 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 800.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 800.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul_ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_mul_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_ui(rop, op1, 10U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_ui(rop, op1, 10U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div_ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_div_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 210 / op.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_div(rop, 210U, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 21.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 210 / op.
        /// Assert.IsTrue(mpfr_lib.mpfr_ui_div(rop, 210U, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_ui_div(mpfr_t rop, uint /*unsigned long*/ op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_ui_div(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_sum">mpfr_sum</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 + 210.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 + 210.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(rop, op1, 210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_add_si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_add_si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 - 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 92.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 92.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 - 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 92.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 92.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sub_si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_sub_si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op2 to 4.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = 100 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_si_sub(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 96.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 96.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op2 to 4.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = 100 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_si_sub(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 96.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 96.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_si_sub(mpfr_t rop, int /*long int*/ op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_si_sub(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands
        /// (for types having no signed zeros, 0 is considered positive).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 * 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 800.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 800.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 * 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 800.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 800.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul_si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_mul_si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_si(rop, op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_si(rop, op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div_si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long int*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_div_si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op2 to 4.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = 100 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_si_div(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 25.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op2 to 4.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = 100 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_si_div(rop, 100, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 25.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_si_div(mpfr_t rop, int /*long int*/ op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_si_div(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
        /// The <see cref="mpfr_add_d">mpfr_add_d</see> function assumes that the radix of the double type is a power of 2,
        /// with a precision at most that declared by the C implementation
        /// (macro IEEE_DBL_MANT_DIG, and if not defined 53 bits). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_sum">mpfr_sum</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 + 210.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_d(rop, op1, 210.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 + 210.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_d(rop, op1, 210.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_add_d(mpfr_t rop, /*const*/ mpfr_t op1, double op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_add_d(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// The same restrictions than for <see cref="mpfr_add_d">mpfr_add_d</see> apply to <see cref="mpfr_sub_d">mpfr_sub_d</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 - 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 92.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 92.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 - 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 92.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 92.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sub_d(mpfr_t rop, /*const*/ mpfr_t op1, double op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_sub_d(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// The same restrictions than for <see cref="mpfr_add_d">mpfr_add_d</see> apply to <see cref="mpfr_d_sub">mpfr_d_sub</see> and <see cref="mpfr_sub_d">mpfr_sub_d</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op2 to -210.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10.0 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_d_sub(rop, 10.0, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op2 to -210.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10.0 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_d_sub(rop, 10.0, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_d_sub(mpfr_t rop, double op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_d_sub(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands
        /// (for types having no signed zeros, 0 is considered positive).
        /// The same restrictions than for <see cref="mpfr_add_d">mpfr_add_d</see> apply to <see cref="mpfr_mul_d">mpfr_mul_d</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 * 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 800.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 800.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 * 8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_d(rop, op1, 8.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 800.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 800.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul_d(mpfr_t rop, /*const*/ mpfr_t op1, double op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_mul_d(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// The same restrictions than for <see cref="mpfr_add_d">mpfr_add_d</see> apply to <see cref="mpfr_d_div">mpfr_d_div</see> and <see cref="mpfr_div_d">mpfr_div_d</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / 10.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_d(rop, op1, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / 10.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_d(rop, op1, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div_d(mpfr_t rop, /*const*/ mpfr_t op1, double op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_div_d(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// The same restrictions than for <see cref="mpfr_add_d">mpfr_add_d</see> apply to <see cref="mpfr_d_div">mpfr_d_div</see> and <see cref="mpfr_div_d">mpfr_div_d</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = -210.0 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_d_div(rop, -210.0, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = -210.0 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_d_div(rop, -210.0, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_d_div(mpfr_t rop, double op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_d_div(rop.ToIntPtr(), op1, op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the square of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op^2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sqr(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.100000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op^2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sqr(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.100000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sqr(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_sqr(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of Pi rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
        /// To free the cache, use <see cref="mpfr_free_cache">mpfr_free_cache</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache</seealso>
        /// <seealso cref="mpfr_free_cache2">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_free_pool">mpfr_free_pool</seealso>
        /// <seealso cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(rop.ToString() == "0.314159265358979323851e1");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(rop.ToString() = "0.314159265358979323851e1")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_const_pi(mpfr_t rop, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_const_pi(rop.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the logarithm of 2 rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
        /// To free the cache, use <see cref="mpfr_free_cache">mpfr_free_cache</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache</seealso>
        /// <seealso cref="mpfr_free_cache2">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_free_pool">mpfr_free_pool</seealso>
        /// <seealso cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Assert that rop is log(2).
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(rop.ToString() == "0.693147180559945309429e0");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Assert that rop is log(2).
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(rop.ToString() = "0.693147180559945309429e0")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_const_log2(mpfr_t rop, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_const_log2(rop.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of Euler’s constant 0.577… rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
        /// To free the cache, use <see cref="mpfr_free_cache">mpfr_free_cache</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache</seealso>
        /// <seealso cref="mpfr_free_cache2">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_free_pool">mpfr_free_pool</seealso>
        /// <seealso cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Assert that rop is the Euler's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_euler(rop, mpfr_rnd_t.MPFR_RNDN) == 1);
        ///  Assert.IsTrue(rop.ToString() == "0.577215664901532860616e0");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Assert that rop is the Euler's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_euler(rop, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(rop.ToString() = "0.577215664901532860616e0")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_const_euler(mpfr_t rop, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_const_euler(rop.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of Catalan’s constant 0.915… rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function caches the computed values to avoid other calculations if a lower or equal precision is requested.
        /// To free the cache, use <see cref="mpfr_free_cache">mpfr_free_cache</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache</seealso>
        /// <seealso cref="mpfr_free_cache2">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_free_pool">mpfr_free_pool</seealso>
        /// <seealso cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Assert that rop is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_catalan(rop, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// Assert.IsTrue(rop.ToString() == "0.915965594177219015048e0");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Assert that rop is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_catalan(rop, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// Assert.IsTrue(rop.ToString() = "0.915965594177219015048e0")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_const_catalan(mpfr_t rop, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_const_catalan(rop.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the arithmetic-geometric mean of <paramref name="op1"/> and <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The arithmetic-geometric mean is the common limit of the sequences u(n) and v(n), where u(0) = <paramref name="op1"/>, v(0) = <paramref name="op2"/>,
        /// u(n + 1) is the arithmetic mean of u(n) and v(n), and v(n + 1) is the geometric mean of u(n) and v(n).
        /// If any operand is negative and the other one is not zero, set <paramref name="rop"/> to NaN.
        /// If any operand is zero and the other one is finite (resp. infinite), set <paramref name="rop"/> to +0 (resp. NaN).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 24.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 24, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 6.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 6, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = agm(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_agm(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 13.458171481725615420766813156);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 24.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 24, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 6.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_si(op2, 6, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = agm(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_agm(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 13.458171481725615420766813156)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_agm(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_agm(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the natural logarithm of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
        /// Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.234180580614732701452e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.234180580614732701452e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_log(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_log(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the natural logarithm of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand integer number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
        /// Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log(10).
        /// Assert.IsTrue(mpfr_lib.mpfr_log_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.230258509299404568404e1");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log(10).
        /// Assert.IsTrue(mpfr_lib.mpfr_log_ui(rop, 10U, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.230258509299404568404e1")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_log_ui(mpfr_t rop, uint /*unsigned long*/ op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_log_ui(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to log2(<paramref name="op"/>) rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
        /// Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log10(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log2(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.337851162325372986173e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log10(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log2(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.337851162325372986173e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_log2(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_log2(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to log10(<paramref name="op"/>) rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to +0 if <paramref name="op"/> is 1 (in all rounding modes), for consistency with the ISO C99 and IEEE 754-2008 standards.
        /// Set <paramref name="rop"/> to -Inf if <paramref name="op"/> is ±0 (i.e., the sign of the zero has no influence on the result). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log10(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log10(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.101703333929878036968e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log10(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log10(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.101703333929878036968e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_log10(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_log10(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the logarithm of one plus <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Set <paramref name="rop"/> to −Inf if <paramref name="op"/> is −1.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log(1 + op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log1p(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.243361335540044980788e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log(1 + op).
        /// Assert.IsTrue(mpfr_lib.mpfr_log1p(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.243361335540044980788e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_log1p(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_log1p(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the exponential of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = e^op.
        /// Assert.IsTrue(mpfr_lib.mpfr_exp(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.271828182845904523543e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = e^op.
        /// Assert.IsTrue(mpfr_lib.mpfr_exp(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.271828182845904523543e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_exp(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_exp(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to 2^<paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 2^op.
        /// Assert.IsTrue(mpfr_lib.mpfr_exp2(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.200000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 2^op.
        /// Assert.IsTrue(mpfr_lib.mpfr_exp2(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.200000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_exp2(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_exp2(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to 10^<paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_expm1">mpfr_expm1</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 10^op.
        /// Assert.IsTrue(mpfr_lib.mpfr_exp10(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.100000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 10^op.
        /// Assert.IsTrue(mpfr_lib.mpfr_exp10(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.100000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_exp10(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_exp10(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the e^<paramref name="op"/> - 1, rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_log">mpfr_log</seealso>
        /// <seealso cref="mpfr_log_ui">mpfr_log_ui</seealso>
        /// <seealso cref="mpfr_log2">mpfr_log2</seealso>
        /// <seealso cref="mpfr_log10">mpfr_log10</seealso>
        /// <seealso cref="mpfr_log1p">mpfr_log1p</seealso>
        /// <seealso cref="mpfr_exp">mpfr_exp</seealso>
        /// <seealso cref="mpfr_exp2">mpfr_exp2</seealso>
        /// <seealso cref="mpfr_exp10">mpfr_exp10</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = e^op - 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_expm1(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.171828182845904523532e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        ///  Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = e^op - 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_expm1(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.171828182845904523532e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_expm1(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_expm1(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the exponential integral of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This is the sum of Euler’s constant, of the logarithm of the absolute value of <paramref name="op"/>,
        /// and of the sum for k from 1 to infinity of (op^k)/(k · k!).
        /// For positive <paramref name="op"/>, it corresponds to the Ei function at op (see formula 5.1.10 from
        /// the Handbook of Mathematical Functions from Abramowitz and Stegun), and for negative <paramref name="op"/>,
        /// to the opposite of the E1 function (sometimes called eint1) at −op (formula 5.1.1 from the same reference).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to exponential integral of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_eint(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.189511781635593675550e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to exponential integral of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_eint(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.189511781635593675550e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_eint(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_eint(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to real part of the dilogarithm of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// MPFR defines the dilogarithm function as the integral of -log(1 - t) / t from 0 to <paramref name="op"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to Re(Dilog(op)).
        /// Assert.IsTrue(mpfr_lib.mpfr_li2(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.449271207859561792596e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        ///  mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to Re(Dilog(op)).
        /// Assert.IsTrue(mpfr_lib.mpfr_li2(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.449271207859561792596e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_li2(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_li2(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number op2.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 > op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(op1, op2) > 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number op2.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(op1, op2) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_cmp(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_cmp(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 &gt; 128.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_d(op1, 128.0) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &gt; 128.0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_d(op1, 128.0) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_d(/*const*/ mpfr_t op1, double op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_cmp_d(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare |<paramref name="op1"/>| and |<paramref name="op2"/>|.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if |<paramref name="op1"/>| &gt; |<paramref name="op2"/>|, zero if |<paramref name="op1"/>| = |<paramref name="op2"/>|, and a negative value if |<paramref name="op1"/>| &lt; |<paramref name="op2"/>|.</returns>
        /// <remarks>
        /// <para>
        /// If one of the operands is NaN, set the erange flag and return zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number op2.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that |op1| &gt; |op2|.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmpabs(op1, op2) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number op2.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 128, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that |op1| &gt; |op2|.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmpabs(op1, op2) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_cmpabs(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_cmpabs(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 &gt; 128.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_ui(op1, 128) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &gt; 128.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_ui(op1, 128) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_ui(/*const*/ mpfr_t op1, uint /*unsigned long*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_cmp_ui(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 &gt; 128.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(op1, 128) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &gt; 128.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(op1, 128) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_si(/*const*/ mpfr_t op1, int /*long*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_cmp_si(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/> * 2^<paramref name="e"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="e">The exponent.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/> * 2^<paramref name="e"/>, zero if <paramref name="op1"/> = <paramref name="op2"/> * 2^<paramref name="e"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/> * 2^<paramref name="e"/>.</returns>
        /// <remarks>
        /// <para>
        /// Similar as <see cref="mpfr_cmp">mpfr_cmp</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 = 128 * 2^2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_ui_2exp(op1, 128, 2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 = 128 * 2^2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_ui_2exp(op1, 128, 2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_ui_2exp(/*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_exp_t e)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_cmp_ui_2exp(op1.ToIntPtr(), op2, e);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/> * 2^<paramref name="e"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="e">The exponent.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/> * 2^<paramref name="e"/>, zero if <paramref name="op1"/> = <paramref name="op2"/> * 2^<paramref name="e"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/> * 2^<paramref name="e"/>.</returns>
        /// <remarks>
        /// <para>
        /// Similar as <see cref="mpfr_cmp">mpfr_cmp</see>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 = 128 * 2^2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si_2exp(op1, 128, 2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 = 128 * 2^2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si_2exp(op1, 128, 2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpfr_clear(op1)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_si_2exp(/*const*/ mpfr_t op1, int /*long*/ op2, mpfr_exp_t e)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_cmp_si_2exp(op1.ToIntPtr(), op2, e);
        }

        /// <summary>
        /// Compute the relative difference between <paramref name="op1"/> and <paramref name="op2"/> and store the result in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <remarks>
        /// <para>
        /// This function does not guarantee the correct rounding on the relative difference;
        /// it just computes |<paramref name="op1"/> - <paramref name="op2"/>| / <paramref name="op1"/>,
        /// using the precision of <paramref name="rop"/> and the rounding mode <paramref name="rnd"/> for all operations. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_prec_raw">mpfr_set_prec_raw</seealso>
        /// <seealso cref="mpfr_eq">mpfr_eq</seealso>
        /// <seealso cref="mpfr_mul_2exp">mpfr_mul_2exp</seealso>
        /// <seealso cref="mpfr_div_2exp">mpfr_div_2exp</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to -210.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = |op1 - op2| / op1.
        /// mpfr_lib.mpfr_reldiff(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Assert that the value of z is 22.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 22.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to -210.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = |op1 - op2| / op1.
        /// mpfr_lib.mpfr_reldiff(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Assert that the value of z is 22.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 22.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static void mpfr_reldiff(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.mpfr_reldiff(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are both non-zero ordinary numbers with the same exponent and the same first <paramref name="op3"/> bits.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="op3">The third operand integer.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are both non-zero ordinary numbers with the same exponent and the same first <paramref name="op3"/> bits, both zero, or both infinities of the same sign. Return zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// This function is defined for compatibility with MPF, we do not recommend to use it otherwise.
        /// Do not use it either if you want to know whether two numbers are close to each other;
        /// for instance, 1.011111 and 1.100000 are regarded as different for any value of <paramref name="op3"/> larger than 1. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_prec_raw">mpfr_set_prec_raw</seealso>
        /// <seealso cref="mpfr_reldiff">mpfr_reldiff</seealso>
        /// <seealso cref="mpfr_mul_2exp">mpfr_mul_2exp</seealso>
        /// <seealso cref="mpfr_div_2exp">mpfr_div_2exp</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 = op2 to 10 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_eq(op1, op2, 10U) != 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 = op2 to 10 bits.
        /// Assert.IsTrue(mpfr_lib.mpfr_eq(op1,op2,10U) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_eq(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2, uint /*unsigned long*/ op3)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_eq(op1.ToIntPtr(), op2.ToIntPtr(), op3);
        }

        /// <summary>
        /// Return a positive value if <paramref name="op"/> &gt; 0, zero if <paramref name="op"/> = 0, and a negative value if <paramref name="op"/> &lt; 0.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op"/> &gt; 0, zero if <paramref name="op"/> = 0, and a negative value if <paramref name="op"/> &lt; 0.</returns>
        /// <remarks>
        /// <para>
        /// If the operand is NaN, set the erange flag and return zero.
        /// This is equivalent to <see cref="mpfr_cmp_ui">mpfr_cmp_ui</see>(<paramref name="op"/>, 0), but more efficient. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op to 200.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert sign of op..
        /// Assert.IsTrue(mpfr_lib.mpfr_sgn(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op to 200.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, 200U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert sign of op..
        /// Assert.IsTrue(mpfr_lib.mpfr_sgn(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_sgn(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sgn(op.ToIntPtr());
        }

        /// <summary>
        /// This function is identical to <see cref="mpfr_mul_2ui">mpfr_mul_2ui</see>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function is only kept for compatibility with MPF, one should prefer <see cref="mpfr_mul_2ui">mpfr_mul_2ui</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_prec_raw">mpfr_set_prec_raw</seealso>
        /// <seealso cref="mpfr_eq">mpfr_eq</seealso>
        /// <seealso cref="mpfr_reldiff">mpfr_reldiff</seealso>
        /// <seealso cref="mpfr_div_2exp">mpfr_div_2exp</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 * 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_2exp(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 25600.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25600.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 * 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_2exp(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 25600.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25600.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul_2exp(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_mul_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// This function is identical to <see cref="mpfr_div_2ui">mpfr_div_2ui</see>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function is only kept for compatibility with MPF, one should prefer <see cref="mpfr_div_2ui">mpfr_div_2ui</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set_prec_raw">mpfr_set_prec_raw</seealso>
        /// <seealso cref="mpfr_eq">mpfr_eq</seealso>
        /// <seealso cref="mpfr_reldiff">mpfr_reldiff</seealso>
        /// <seealso cref="mpfr_mul_2exp">mpfr_mul_2exp</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Compatibility_With_MPF">Compatibility With MPF</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Compatibility-with-MPF">GNU MPFR - Compatibility With MPF</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_2exp(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 2.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_2exp(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 2.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div_2exp(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_div_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Just increases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 * 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 25600.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25600.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 * 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 25600.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25600.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul_2ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_mul_2ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> divided by 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Just decreases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 2.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_2ui(rop, op1, 8U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 2.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div_2ui(mpfr_t rop, /*const*/ mpfr_t op1, uint /*unsigned long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_div_2ui(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Just increases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 100.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set z = op1 * 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 25600.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 25600.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 100.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set z = op1 * 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 25600.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 25600.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_mul_2si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_mul_2si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> divided by 2^<paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Just decreases the exponent by <paramref name="op2"/> when <paramref name="rop"/> and <paramref name="op1"/> are identical. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 2.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / 2^8.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_2si(rop, op1, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 2.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op1.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_div_2si(mpfr_t rop, /*const*/ mpfr_t op1, int /*long*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.mpfr_div_2si(rop.ToIntPtr(), op1.ToIntPtr(), op2, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the nearest representable integer in the given direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, the NaN flag is set as usual.
        /// In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
        /// If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
        /// mathematical function, you should use one the mpfr_rint_* functions instead (however it is not possible to round to nearest with the even rounding rule yet). 
        /// </para>
        /// <para>
        /// Note that <see cref="mpfr_round">mpfr_round</see> is different from <see cref="mpfr_rint">mpfr_rint</see> called with the rounding to nearest mode (where halfway cases are rounded to an
        /// even integer or significand).
        /// Note also that no double rounding is performed; for instance, 10.5 (1010.1 in binary) is rounded by <see cref="mpfr_rint">mpfr_rint</see> with rounding to nearest
        /// to 12 (1100 in binary) in 2-bit precision, because the two enclosing numbers representable on two bits are 8 and 12, and the closest is 12.
        /// (If one first rounded to an integer, one would round 10.5 to 10 with even rounding, and then 10 would be rounded to 8 again with even rounding.) 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint(rop, op, mpfr_rnd_t.MPFR_RNDN) == -2);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint(rop, op, mpfr_rnd_t.MPFR_RNDN) = -2)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rint(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_rint(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the nearest representable integer, rounding halfway cases away from zero (as in the roundTiesToAway mode of IEEE 754-2008). 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// When <paramref name="op"/> is NaN, the NaN flag is set as usual.
        /// In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
        /// If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
        /// mathematical function, you should use one the mpfr_rint_* functions instead (however it is not possible to round to nearest with the even rounding rule yet). 
        /// </para>
        /// <para>
        /// Note that no double rounding is performed; for instance, 10.5 (1010.1 in binary) is rounded by <see cref="mpfr_rint">mpfr_rint</see> with rounding to nearest
        /// to 12 (1100 in binary) in 2-bit precision, because the two enclosing numbers representable on two bits are 8 and 12, and the closest is 12.
        /// (If one first rounded to an integer, one would round 10.5 to 10 with even rounding, and then 10 would be rounded to 8 again with even rounding.) 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_roundeven</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_round(rop, op) == -2);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_round(rop, op) = -2)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_round(mpfr_t rop, /*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_round(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <i>rop</i> to <i>op</i> rounded to the nearest representable integer, rounding halfway cases with the even-rounding rule zero (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDN"/>).
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// When <paramref name="op"/> is NaN, the NaN flag is set as usual.
        /// In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
        /// If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
        /// mathematical function, you should use one the mpfr_rint_* functions instead. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_roundeven(rop, op) == -2);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_roundeven(rop, op) = -2)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_roundeven(mpfr_t rop, /*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_roundeven(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next representable integer toward zero (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDZ"/>).
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// When <paramref name="op"/> is NaN, the NaN flag is set as usual.
        /// In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
        /// If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
        /// mathematical function, you should use one the mpfr_rint_* functions instead. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = trunc(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_trunc(rop, op) == -2);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = trunc(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_trunc(rop, op) = -2)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_trunc(mpfr_t rop, /*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_trunc(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next higher or equal representable integer (like <see cref="mpfr_rint"/> with <see cref="mpfr_rnd_t.MPFR_RNDU"/>).
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// When <paramref name="op"/> is NaN, the NaN flag is set as usual.
        /// In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
        /// If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
        /// mathematical function, you should use one the mpfr_rint_* functions instead. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = ceil(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_ceil(rop, op) == 2);
        /// 
        /// // Assert that the value of rop is 11.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 11.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = ceil(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_ceil(rop, op) = 2)
        /// 
        /// ' Assert that the value of rop is 11.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 11.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_ceil(mpfr_t rop, /*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_ceil(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next lower or equal representable integer. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>The return value is zero when the result is exact, positive when it is greater than the original value of <paramref name="op"/>, and negative when it is smaller. More precisely, the returned value is 0 when <paramref name="op"/> is an integer representable in <paramref name="rop"/>, 1 or -1 when <paramref name="op"/> is an integer that is not representable in <paramref name="rop"/>, 2 or -2 when <paramref name="op"/> is not an integer.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// When <paramref name="op"/> is NaN, the NaN flag is set as usual.
        /// In the other cases, the inexact flag is set when <paramref name="rop"/> differs from <paramref name="op"/>, following the ISO C99 rule for the rint function.
        /// If you want the behavior to be more like IEEE 754 / ISO TS 18661-1, i.e., the usual behavior where the round-to-integer function is regarded as any other
        /// mathematical function, you should use one the mpfr_rint_* functions instead. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = floor(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_floor(rop, op) == -2);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = floor(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_floor(rop, op) = -2)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_floor(mpfr_t rop, /*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_floor(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the nearest integer, rounding halfway cases away from zero.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
        /// <remarks>
        /// <para>
        /// If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// Contrary to <see cref="mpfr_rint">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
        /// in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
        /// Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
        /// exact result of the function in the real numbers. 
        /// </para>
        /// <para>
        /// For example, <see cref="mpfr_rint_round">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
        /// then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_round(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_round(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rint_round(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_rint_round(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <i>rop</i> to <i>op</i> rounded to the nearest integer, rounding halfway cases to the nearest even integer.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
        /// <remarks>
        /// <para>
        /// If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// Contrary to <see cref="mpfr_rint">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
        /// in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
        /// Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
        /// exact result of the function in the real numbers. 
        /// </para>
        /// <para>
        /// For example, <see cref="mpfr_rint_round">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
        /// then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_roundeven(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_init_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_roundeven(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rint_roundeven(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_rint_roundeven(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next integer toward zero.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
        /// <remarks>
        /// <para>
        /// If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// Contrary to <see cref="mpfr_rint">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
        /// in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
        /// Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
        /// exact result of the function in the real numbers. 
        /// </para>
        /// <para>
        /// For example, <see cref="mpfr_rint_round">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
        /// then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_trunc(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_trunc(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rint_trunc(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_rint_trunc(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next higher or equal integer.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
        /// <remarks>
        /// <para>
        /// If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// Contrary to <see cref="mpfr_rint">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
        /// in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
        /// Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
        /// exact result of the function in the real numbers. 
        /// </para>
        /// <para>
        /// For example, <see cref="mpfr_rint_round">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
        /// then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_ceil(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.260000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_ceil(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.260000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rint_ceil(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_rint_ceil(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next lower or equal integer.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> associated with the considered round-to-integer function (regarded in the same way as any other mathematical function).</returns>
        /// <remarks>
        /// <para>
        /// If the result is not representable, it is rounded in the direction <paramref name="rnd"/>. 
        /// When <paramref name="op"/> is a zero or an infinity, set <paramref name="rop"/> to the same value (with the same sign).
        /// </para>
        /// <para>
        /// Contrary to <see cref="mpfr_rint">mpfr_rint</see>, this function does perform a double rounding: first <paramref name="op"/> is rounded to the nearest integer
        /// in the direction given by the function name, then this nearest integer (if not representable) is rounded in the given direction <paramref name="rnd"/>.
        /// Thus these round-to-integer functions behave more like the other mathematical functions, i.e., the returned result is the correct rounding of the
        /// exact result of the function in the real numbers. 
        /// </para>
        /// <para>
        /// For example, <see cref="mpfr_rint_round">mpfr_rint_round</see> with rounding to nearest and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero),
        /// then 7 is rounded to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is closer to 6.5 than 8.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 25.2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_floor(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.250000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 25.2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 25.2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = round(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_rint_floor(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.250000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rint_floor(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_rint_floor(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the fractional part of <paramref name="op"/>, having the same sign as <paramref name="op"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Unlike in <see cref="mpfr_rint">mpfr_rint</see>, <paramref name="rnd"/> affects only how the exact fractional part is rounded, not how the fractional part is generated. 
        /// When <paramref name="op"/> is an integer or an infinity, set <paramref name="rop"/> to zero with the same sign as op.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = fraction(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_frac(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = fraction(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_frac(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_frac(mpfr_t rop,/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_frac(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set simultaneously <paramref name="iop"/> to the integral part of <paramref name="op"/> and <paramref name="fop"/> to the fractional part of <paramref name="op"/>, rounded in the direction <paramref name="rnd"/> with the corresponding precision of <paramref name="iop"/> and <paramref name="fop"/>. 
        /// </summary>
        /// <param name="iop">The result integral part.</param>
        /// <param name="fop">The result frational part.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return 0 iff both results are exact (see <see cref="mpfr_sin_cos">mpfr_sin_cos</see> for a more detailed description of the return value.</returns>
        /// <remarks>
        /// <para>
        /// Equivalent to <see cref="mpfr_trunc">mpfr_trunc</see>(<paramref name="iop"/>, <paramref name="op"/>, <paramref name="rnd"/>)
        /// and <see cref="mpfr_frac">mpfr_frac</see>(<paramref name="fop"/>, <paramref name="op"/>, <paramref name="rnd"/>). 
        /// </para>
        /// <para>
        /// The variables <paramref name="iop"/> and <paramref name="fop"/> must be different.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number iop.
        /// mpfr_t iop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(iop, 64U);
        /// 
        /// // Create and initialize a new floating-point number fop.
        /// mpfr_t fop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(fop, 64U);
        /// 
        /// // Set rop to log10(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_modf(iop, fop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of iop and fop.
        /// Assert.IsTrue(iop.ToString() == "0.100000000000000000000e2");
        /// Assert.IsTrue(fop.ToString() == "0.400000000000000355271e0");
        /// 
        /// // Release unmanaged memory allocated for iop, fop, and op.
        /// mpfr_lib.mpfr_clears(iop, fop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number iop.
        /// Dim iop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(iop, 64U)
        /// 
        /// ' Create and initialize a new floating-point number fop.
        /// Dim fop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(fop, 64U)
        /// 
        /// ' Set rop to log10(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_modf(iop, fop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of iop and fop.
        /// Assert.IsTrue(iop.ToString() = "0.100000000000000000000e2")
        /// Assert.IsTrue(fop.ToString() = "0.400000000000000355271e0")
        /// 
        /// ' Release unmanaged memory allocated for iop, fop, and op.
        /// mpfr_lib.mpfr_clears(iop, fop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_modf(mpfr_t iop, mpfr_t fop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (iop == null) throw new ArgumentNullException("iop");
            if (fop == null) throw new ArgumentNullException("fop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_modf(iop.ToIntPtr(), fop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded to the nearest integer (ties rounded to even). 
        /// </summary>
        /// <param name="r">The result remainder floating-point number.</param>
        /// <param name="q">Low significant bits of quotient.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
        /// If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
        /// If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
        /// If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
        /// </para>
        /// <para>
        /// Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
        /// (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
        /// (except if those low bits are all zero, in which case zero is returned).
        /// Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
        /// is not practical.
        /// The <see cref="mpfr_remainder">mpfr_remainder</see> and <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> functions are useful for additive argument reduction. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="mpfr_remquo(mpfr_t, ptr{int}, mpfr_t, mpfr_t, mpfr_rnd_t)">mpfr_remquo(mpfr_t, ptr{int}, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 7.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number r.
        /// mpfr_t r = new mpfr_t();
        /// mpfr_lib.mpfr_init2(r, 64U);
        /// 
        /// // Set r = x - n * y where n = trunc(x / y).
        /// int q = 0;
        /// Assert.IsTrue(mpfr_lib.mpfr_remquo(r, ref q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() == "0.200000000000000000000e1" &amp;&amp; q == 14);
        /// 
        /// // Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 7.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number r.
        /// Dim r As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(r, 64U)
        /// 
        /// ' Set r = x - n * y where n = trunc(x / y).
        /// Dim q As Integer = 0
        /// Assert.IsTrue(mpfr_lib.mpfr_remquo(r,ref q,x,y,mpfr_rnd_t.MPFR_RNDN)  =  0)
        /// 
        /// ' Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() = "0.200000000000000000000e1" AndAlso q = 14)
        /// 
        /// ' Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_remquo(mpfr_t r, ref int /*long **/ q, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_remquo(r.ToIntPtr(), ref q, x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded to the nearest integer (ties rounded to even). 
        /// </summary>
        /// <param name="r">The result remainder floating-point number.</param>
        /// <param name="q">Low significant bits of quotient.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
        /// If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
        /// If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
        /// If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
        /// </para>
        /// <para>
        /// Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
        /// (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
        /// (except if those low bits are all zero, in which case zero is returned).
        /// Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
        /// is not practical.
        /// The <see cref="mpfr_remainder">mpfr_remainder</see> and <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> functions are useful for additive argument reduction. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="mpfr_remquo(mpfr_t, ref int, mpfr_t, mpfr_t, mpfr_rnd_t)">mpfr_remquo(mpfr_t, ref int, mpfr_t, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 7.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number r.
        /// mpfr_t r = new mpfr_t();
        /// mpfr_lib.mpfr_init2(r, 64U);
        /// 
        /// // Set r = x - n * y where n = trunc(x / y).
        /// ptr&lt;int&gt; q = new ptr&lt;int&gt;(0);
        /// Assert.IsTrue(mpfr_lib.mpfr_remquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() == "0.200000000000000000000e1" &amp;&amp; q.Value == 14);
        /// 
        /// // Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 7.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 7, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number r.
        /// Dim r As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(r, 64U)
        /// 
        /// ' Set r = x - n * y where n = trunc(x / y).
        /// Dim q As ptr(Of int) =  New ptr(Of int)(0)
        /// Assert.IsTrue(mpfr_lib.mpfr_remquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() = "0.200000000000000000000e1" AndAlso q.Value = 14)
        /// 
        /// ' Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_remquo(mpfr_t r, ptr<int> /*long **/ q, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (q == null) throw new ArgumentNullException("q");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_remquo(r.ToIntPtr(), ref q.Value, x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded to the nearest integer (ties rounded to even). 
        /// </summary>
        /// <param name="r">The result remainder floating-point number.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the ternary value corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
        /// If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
        /// If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
        /// If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
        /// </para>
        /// <para>
        /// The <see cref="mpfr_remainder">mpfr_remainder</see> and <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo</see> functions are useful for additive argument reduction. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 3.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number r.
        /// mpfr_t r = new mpfr_t();
        /// mpfr_lib.mpfr_init2(r, 64U);
        /// 
        /// // Set r = x - n * y where n = trunc(x / y).
        /// Assert.IsTrue(mpfr_lib.mpfr_remainder(r, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of z.
        /// Assert.IsTrue(r.ToString() == "0.100000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 3.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number r.
        /// Dim r As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(r, 64U)
        /// 
        /// ' Set r = x - n * y where n = trunc(x / y).
        /// Assert.IsTrue(mpfr_lib.mpfr_remainder(r, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of z.
        /// Assert.IsTrue(r.ToString() = "0.100000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_remainder(mpfr_t r, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_remainder(r.ToIntPtr(), x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded toward zero. 
        /// </summary>
        /// <param name="r">The result remainder floating-point number.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the ternary value corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
        /// If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
        /// If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
        /// If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 3.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number r.
        /// mpfr_t r = new mpfr_t();
        /// mpfr_lib.mpfr_init2(r, 64U);
        /// 
        /// // Set r = x - n * y where n = trunc(x / y).
        /// Assert.IsTrue(mpfr_lib.mpfr_fmod(r, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of z.
        /// Assert.IsTrue(r.ToString() == "0.100000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 3.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number r.
        /// Dim r As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(r, 64U)
        /// 
        /// ' Set r = x - n * y where n = trunc(x / y).
        /// Assert.IsTrue(mpfr_lib.mpfr_fmod(r, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of z.
        /// Assert.IsTrue(r.ToString() = "0.100000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fmod(mpfr_t r, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_fmod(r.ToIntPtr(), x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded  toward zero. 
        /// </summary>
        /// <param name="r">The result remainder floating-point number.</param>
        /// <param name="q">Low significant bits of quotient.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
        /// If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
        /// If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
        /// If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
        /// </para>
        /// <para>
        /// Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
        /// (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
        /// (except if those low bits are all zero, in which case zero is returned).
        /// Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
        /// is not practical. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 3.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number r.
        /// mpfr_t r = new mpfr_t();
        /// mpfr_lib.mpfr_init2(r, 64U);
        /// 
        /// // Set r = x - n * y where n = trunc(x / y).
        /// int q = 0;
        /// Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, ref q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() == "0.100000000000000000000e1" &amp;&amp; q == 33);
        /// 
        /// // Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 3.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number r.
        /// Dim r As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(r, 64U)
        /// 
        /// ' Set r = x - n * y where n = trunc(x / y).
        /// Dim q As Integer = 0
        /// Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() = "0.100000000000000000000e1" AndAlso q = 33)
        /// 
        /// ' Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fmodquo(mpfr_t r, ref int /*long **/ q, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_fmodquo(r.ToIntPtr(), ref q, x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="r"/> to the value of <paramref name="x"/> - n * <paramref name="y"/>, rounded according to the direction <paramref name="rnd"/>, where n is the integer quotient of <paramref name="x"/> divided by <paramref name="y"/>, rounded toward zero. 
        /// </summary>
        /// <param name="r">The result remainder floating-point number.</param>
        /// <param name="q">Low significant bits of quotient.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The return value is the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> corresponding to <paramref name="r"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in Section F.9.7.1 of the ISO C99 standard:
        /// If <paramref name="x"/> is infinite or <paramref name="y"/> is zero, <paramref name="r"/> is NaN.
        /// If <paramref name="y"/> is infinite and <paramref name="x"/> is finite, <paramref name="r"/> is <paramref name="x"/> rounded to the precision of <paramref name="r"/>.
        /// If <paramref name="r"/> is zero, it has the sign of <paramref name="x"/>.
        /// </para>
        /// <para>
        /// Additionally, <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo</see> stores the low significant bits from the quotient n in <paramref name="q"/>
        /// (more precisely the number of bits in a long minus one), with the sign of <paramref name="x"/> divided by <paramref name="y"/>
        /// (except if those low bits are all zero, in which case zero is returned).
        /// Note that <paramref name="x"/> may be so large in magnitude relative to <paramref name="y"/> that an exact representation of the quotient
        /// is not practical. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_integer_p">mpfr_integer_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 3.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number r.
        /// mpfr_t r = new mpfr_t();
        /// mpfr_lib.mpfr_init2(r, 64U);
        /// 
        /// // Set r = x - n * y where n = trunc(x / y).
        /// ptr&lt;int&gt; q = new ptr&lt;int&gt;(0);
        /// Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() == "0.100000000000000000000e1" &amp;&amp; q.Value == 33);
        /// 
        /// // Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 100, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 3.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number r.
        /// Dim r As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(r, 64U)
        /// 
        /// ' Set r = x - n * y where n = trunc(x / y).
        /// Dim q As ptr(Of int) =  New ptr(Of int)(0)
        /// Assert.IsTrue(mpfr_lib.mpfr_fmodquo(r, q, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of z and q.
        /// Assert.IsTrue(r.ToString() = "0.100000000000000000000e1" AndAlso q.Value = 33)
        /// 
        /// ' Release unmanaged memory allocated for r, x, and y.
        /// mpfr_lib.mpfr_clears(r, x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fmodquo(mpfr_t r, ptr<int> /*long **/ q, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (q == null) throw new ArgumentNullException("q");
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            return SafeNativeMethods.mpfr_fmodquo(r.ToIntPtr(), ref q.Value, x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_ulong_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_ulong_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op does not fit in long.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_slong_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op does not fit in long.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_slong_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_slong_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_slong_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_get_uj">mpfr_get_uj</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op UInt64.MaxValue.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, UInt64.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op fits in uintmax_t.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_uintmax_p(op, mpfr_rnd_t.MPFR_RNDN) != 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op UInt64.MaxValue.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, UInt64.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op fits in uintmax_t.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_uintmax_p(op,mpfr_rnd_t.MPFR_RNDN) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_uintmax_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_uintmax_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) long when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_get_sj">mpfr_get_sj</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op Int64.MaxValue.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, Int64.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op fits in intmax_t.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_intmax_p(op, mpfr_rnd_t.MPFR_RNDN) != 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op Int64.MaxValue.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_uj(op, Int64.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op fits in intmax_t.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_intmax_p(op,mpfr_rnd_t.MPFR_RNDN) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_intmax_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_intmax_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned int when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) unsigned int when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op does not fit in uint.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_uint_p(op, mpfr_rnd_t.MPFR_RNDN) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op does not fit in uint.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_uint_p(op, mpfr_rnd_t.MPFR_RNDN) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_uint_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_uint_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) int when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (32-bit) int when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_sint_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_sint_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_sint_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) unsigned short when rounded to an integer in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) unsigned short when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_ui">mpfr_get_ui</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_sshort_p">mpfr_fits_sshort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op does not fit in ushort.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_ushort_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op does not fit in ushort.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_ushort_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_ushort_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_ushort_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) short when rounded to an integer in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return non-zero if <paramref name="op"/> would fit in the C data type (16-bit) short when rounded to an integer in the direction <paramref name="rnd"/>.</returns>
        /// <remarks>
        /// <para>
        /// For instance, with the <see cref="mpfr_rnd_t.MPFR_RNDU"/> rounding mode on −0.5, the result will be non-zero for all mpfr_fits_* functions.
        /// For <see cref="mpfr_rnd_t.MPFR_RNDF"/>, those functions return non-zero when it is guaranteed that the corresponding conversion function
        /// (for example <see cref="mpfr_get_ui"/> for <see cref="mpfr_fits_ulong_p"/>), when called with faithful rounding, will always return a number
        /// that is representable in the corresponding type.
        /// As a consequence, for <see cref="mpfr_rnd_t.MPFR_RNDF"/>, <see cref="mpfr_fits_ulong_p"/> will return non-zero for a non-negative number
        /// less or equal to ULONG_MAX.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_get_si">mpfr_get_si</seealso>
        /// <seealso cref="mpfr_fits_ulong_p">mpfr_fits_ulong_p</seealso>
        /// <seealso cref="mpfr_fits_slong_p">mpfr_fits_slong_p</seealso>
        /// <seealso cref="mpfr_fits_uint_p">mpfr_fits_uint_p</seealso>
        /// <seealso cref="mpfr_fits_sint_p">mpfr_fits_sint_p</seealso>
        /// <seealso cref="mpfr_fits_ushort_p">mpfr_fits_ushort_p</seealso>
        /// <seealso cref="mpfr_fits_uintmax_p">mpfr_fits_uintmax_p</seealso>
        /// <seealso cref="mpfr_fits_intmax_p">mpfr_fits_intmax_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Conversion_Functions">Conversion Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Conversion-Functions">GNU MPFR - Conversion Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uint.MaxValue, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op does not fit in short.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_sshort_p(op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_ui(op, uInteger.MaxValue, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op does not fit in short.
        /// Assert.IsTrue(mpfr_lib.mpfr_fits_sshort_p(op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_fits_sshort_p(/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_fits_sshort_p(op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Swap the structures pointed to by <paramref name="x"/> and <paramref name="y"/>.
        /// </summary>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <remarks>
        /// <para>
        /// In particular, the values are exchanged without rounding (this may be different from three <see cref="mpfr_set">mpfr_set</see> calls using a third auxiliary variable).
        /// </para>
        /// <para>
        /// Warning! Since the precisions are exchanged, this will affect future assignments.
        /// Moreover, since the significand pointers are also exchanged, you must not use this function if the allocation
        /// method used for <paramref name="x"/> and/or <paramref name="y"/> does not permit it.
        /// This is the case when <paramref name="x"/> and/or <paramref name="y"/> were declared and initialized
        /// with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> (see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a>). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_str">mpfr_set_str</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_strtofr"/>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 128U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 128U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Swap the values of x and y.
        /// mpfr_lib.mpfr_swap(x, y);
        /// 
        /// // Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) == -210.0);
        /// 
        /// // Assert that the value of y is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(y, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpfr_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 128U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 128U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Swap the values of x and y.
        /// mpfr_lib.mpfr_swap(x, y)
        /// 
        /// ' Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(x, mpfr_rnd_t.MPFR_RNDN) = -210.0)
        /// 
        /// ' Assert that the value of y is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(y, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpfr_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpfr_swap(mpfr_t x, mpfr_t y)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            SafeNativeMethods.mpfr_swap(x.ToIntPtr(), y.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is NaN. Return zero otherwise.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op"/> is NaN. Return zero otherwise.</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number op.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// 
        /// // Assert that op is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(op) != 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number op.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// 
        /// ' Assert that op is NaN.
        /// Assert.IsTrue(mpfr_lib.mpfr_nan_p(op) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_nan_p(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_nan_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is an infinity. Return zero otherwise.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op"/> is an infinity. Return zero otherwise.</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_inf_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is not infinity.
        /// Assert.IsTrue(mpfr_lib.mpfr_inf_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_inf_p(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_inf_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is an ordinary number (i.e., neither NaN nor an infinity). Return zero otherwise.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op"/> is an ordinary number (i.e., neither NaN nor an infinity). Return zero otherwise.</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is an integer.
        /// Assert.IsTrue(mpfr_lib.mpfr_number_p(op) != 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is an integer.
        /// Assert.IsTrue(mpfr_lib.mpfr_number_p(op) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_number_p(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_number_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero iff <paramref name="op"/> is an integer.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return non-zero iff <paramref name="op"/> is an integer.</returns>
        /// <seealso cref="mpfr_rint">mpfr_rint</seealso>
        /// <seealso cref="mpfr_ceil">mpfr_ceil</seealso>
        /// <seealso cref="mpfr_floor">mpfr_floor</seealso>
        /// <seealso cref="mpfr_round">mpfr_round</seealso>
        /// <seealso cref="mpfr_roundeven">mpfr_round</seealso>
        /// <seealso cref="mpfr_trunc">mpfr_trunc</seealso>
        /// <seealso cref="mpfr_rint_ceil">mpfr_rint_ceil</seealso>
        /// <seealso cref="mpfr_rint_floor">mpfr_rint_floor</seealso>
        /// <seealso cref="mpfr_rint_round">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_roundeven">mpfr_rint_round</seealso>
        /// <seealso cref="mpfr_rint_trunc">mpfr_rint_trunc</seealso>
        /// <seealso cref="mpfr_frac">mpfr_frac</seealso>
        /// <seealso cref="mpfr_modf">mpfr_modf</seealso>
        /// <seealso cref="mpfr_fmod">mpfr_fmod</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_fmodquo">mpfr_fmod</seealso>
        /// <seealso cref="mpfr_remainder">mpfr_remainder</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_remquo"/>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Integer_and_Remainder_Related_Functions">Integer and Remainder Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Integer-Related-Functions">GNU MPFR - Integer and Remainder Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is an integer.
        /// Assert.IsTrue(mpfr_lib.mpfr_integer_p(op) != 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is an integer.
        /// Assert.IsTrue(mpfr_lib.mpfr_integer_p(op) &lt;&gt;  0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_integer_p(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_integer_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is zero. Return zero otherwise.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op"/> is zero. Return zero otherwise.</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is nopt zero.
        /// Assert.IsTrue(mpfr_lib.mpfr_zero_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is nopt zero.
        /// Assert.IsTrue(mpfr_lib.mpfr_zero_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_zero_p(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_zero_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is a regular number (i.e., neither NaN, nor an infinity nor zero). Return zero otherwise.
        /// </summary>
        /// <param name="op">The operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op"/> is a regular number (i.e., neither NaN, nor an infinity nor zero). Return zero otherwise.</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op is an integer.
        /// Assert.IsTrue(mpfr_lib.mpfr_regular_p(op) != 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op is an integer.
        /// Assert.IsTrue(mpfr_lib.mpfr_regular_p(op) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpfr_clear(op)
        /// </code> 
        /// </example>
        public static int mpfr_regular_p(/*const*/ mpfr_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_regular_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> &gt; <paramref name="op2"/>, and zero otherwise.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> &gt; <paramref name="op2"/>, and zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 > op2 is false.
        /// Assert.IsTrue(mpfr_lib.mpfr_greater_p(op1, op2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 > op2 is false.
        /// Assert.IsTrue(mpfr_lib.mpfr_greater_p(op1, op2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_greater_p(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_greater_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> &#8805; <paramref name="op2"/>, and zero otherwise.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> &#8805; <paramref name="op2"/>, and zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 >= op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_greaterequal_p(op1, op2) != 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 >= op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_greaterequal_p(op1,op2) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_greaterequal_p(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_greaterequal_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/>, and zero otherwise.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/>, and zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 &lt; op2 is false.
        /// Assert.IsTrue(mpfr_lib.mpfr_less_p(op1, op2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &lt; op2 is false.
        /// Assert.IsTrue(mpfr_lib.mpfr_less_p(op1, op2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_less_p(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_less_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> &#8804; <paramref name="op2"/>, and zero otherwise.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN.</returns>
        /// <remarks>
        /// <para>
        /// Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 &lt;= op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_lessequal_p(op1, op2) != 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &lt;= op2.
        ///  Assert.IsTrue(mpfr_lib.mpfr_lessequal_p(op1,op2) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_lessequal_p(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_lessequal_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/> or <paramref name="op1"/> &gt; <paramref name="op2"/> (i.e., neither <paramref name="op1"/>, nor <paramref name="op2"/> is NaN, and <paramref name="op1"/> &#8800; <paramref name="op2"/>), zero otherwise (i.e., <paramref name="op1"/> and/or <paramref name="op2"/> is NaN, or <paramref name="op1"/> = <paramref name="op2"/>).
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> &lt; <paramref name="op2"/> or <paramref name="op1"/> &gt; <paramref name="op2"/> (i.e., neither <paramref name="op1"/>, nor <paramref name="op2"/> is NaN, and <paramref name="op1"/> &#8800; <paramref name="op2"/>), zero otherwise (i.e., <paramref name="op1"/> and/or <paramref name="op2"/> is NaN, or <paramref name="op1"/> = <paramref name="op2"/>).</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 &lt; op2 is false.
        /// Assert.IsTrue(mpfr_lib.mpfr_lessgreater_p(op1, op2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 &lt; op2 is false.
        /// Assert.IsTrue(mpfr_lib.mpfr_lessgreater_p(op1, op2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_lessgreater_p(/*const*/ mpfr_t op1,/*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_lessgreater_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> = <paramref name="op2"/>, and zero otherwise.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> = <paramref name="op2"/>, and zero otherwise.</returns>
        /// <remarks>
        /// <para>
        /// Return zero whenever <paramref name="op1"/> and/or <paramref name="op2"/> is NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that op1 = op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_equal_p(op1, op2) != 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that op1 = op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_equal_p(op1,op2) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_equal_p(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_equal_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> or <paramref name="op2"/> is a NaN (i.e., they cannot be compared), zero otherwise. 
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> or <paramref name="op2"/> is a NaN (i.e., they cannot be compared), zero otherwise.</returns>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 1.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 1.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Assert that op1 and op2 are ordered.
        /// Assert.IsTrue(mpfr_lib.mpfr_unordered_p(op1, op2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 1.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// mpfr_lib.mpfr_set_si(op1, 1, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 1.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// mpfr_lib.mpfr_set_si(op2, 1, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Assert that op1 and op2 are ordered.
        /// Assert.IsTrue(mpfr_lib.mpfr_unordered_p(op1, op2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_unordered_p(/*const*/ mpfr_t op1, /*const*/ mpfr_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_unordered_p(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the inverse hyperbolic tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = atanh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_atanh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = atanh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_atanh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_atanh(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_atanh(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the inverse hyperbolic cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = acosh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_acosh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = acosh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_acosh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_acosh(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_acosh(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the inverse hyperbolic sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = asinh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_asinh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = asinh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_asinh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 0) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_asinh(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_asinh(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the hyperbolic cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = cosh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cosh(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = cosh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cosh(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_cosh(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_cosh(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the hyperbolic sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = sinh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sinh(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.117520119364380145688e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = sinh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sinh(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.117520119364380145688e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sinh(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sinh(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the hyperbolic tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = tanh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_tanh(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.761594155955764888109e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = tanh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_tanh(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.761594155955764888109e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_tanh(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_tanh(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set simultaneously <paramref name="sop"/> to the hyperbolic sine of <paramref name="op"/> and <paramref name="cop"/> to the hyperbolic cosine of <paramref name="op"/>, rounded in the direction <paramref name="rnd"/> with the corresponding precision of <paramref name="sop"/> and <paramref name="cop"/>, which must be different variables.
        /// </summary>
        /// <param name="sop">The result hyperbolic sine.</param>
        /// <param name="cop">The result hyperbolic cosine.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return 0 iff both results are exact (see <see cref="mpfr_sin_cos">mpfr_sin_cos</see> for a more detailed description of the return value).</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number sop.
        /// mpfr_t sop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(sop, 64U);
        /// 
        /// // Create and initialize a new floating-point number cop.
        /// mpfr_t cop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(cop, 64U);
        /// 
        /// // Set sop = sinh(op), cop = cosh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sinh_cosh(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) == 10);
        /// 
        /// // Assert the value of sop and cop.
        /// Assert.IsTrue(sop.ToString() == "0.117520119364380145688e1");
        /// Assert.IsTrue(cop.ToString() == "0.154308063481524377844e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(sop, cop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number sop.
        /// Dim sop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(sop, 64U)
        /// 
        /// ' Create and initialize a new floating-point number cop.
        /// Dim cop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(cop, 64U)
        /// 
        /// ' Set sop = sinh(op), cop = cosh(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sinh_cosh(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) = 10)
        /// 
        /// ' Assert the value of sop and cop.
        /// Assert.IsTrue(sop.ToString() = "0.117520119364380145688e1")
        /// Assert.IsTrue(cop.ToString() = "0.154308063481524377844e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(sop, cop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sinh_cosh(mpfr_t sop, mpfr_t cop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (sop == null) throw new ArgumentNullException("sop");
            if (cop == null) throw new ArgumentNullException("cop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sinh_cosh(sop.ToIntPtr(), cop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the hyperbolic secant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = sech(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sech(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.648054273663885399581e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = sech(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sech(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.648054273663885399581e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sech(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sech(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the hyperbolic cosecant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_coth">mpfr_coth</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = csch(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_csch(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.850918128239321545122e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = csch(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_csch(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.850918128239321545122e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_csch(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_csch(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the hyperbolic cotangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cosh">mpfr_cosh</seealso>
        /// <seealso cref="mpfr_sinh">mpfr_sinh</seealso>
        /// <seealso cref="mpfr_tanh">mpfr_tanh</seealso>
        /// <seealso cref="mpfr_sinh_cosh">mpfr_sinh_cosh</seealso>
        /// <seealso cref="mpfr_sech">mpfr_sech</seealso>
        /// <seealso cref="mpfr_csch">mpfr_csch</seealso>
        /// <seealso cref="mpfr_acosh">mpfr_acosh</seealso>
        /// <seealso cref="mpfr_asinh">mpfr_asinh</seealso>
        /// <seealso cref="mpfr_atanh">mpfr_atanh</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = coth(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_coth(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.131303528549933130366e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = coth(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_coth(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.131303528549933130366e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_coth(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_coth(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the arc-cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that since acos(-1) returns the floating-point number closest to Pi according to the given rounding mode,
        /// this number might not be in the output range 0 &#8804; rop &lt; Pi of the arc-cosine function;
        /// still, the result lies in the image of the output range by the rounding function.
        /// The same holds for asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(<paramref name="op"/>) with large
        /// <paramref name="op"/> and small precision of <paramref name="rop"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 2 * acos(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_acos(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 2 * acos(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_acos(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_acos(mpfr_t rop,/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_acos(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the arc-sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that since acos(-1) returns the floating-point number closest to Pi according to the given rounding mode,
        /// this number might not be in the output range 0 &#8804; rop &lt; Pi of the arc-cosine function;
        /// still, the result lies in the image of the output range by the rounding function.
        /// The same holds for asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(<paramref name="op"/>) with large
        /// <paramref name="op"/> and small precision of <paramref name="rop"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 2 * asin(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_asin(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 2 * asin(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_asin(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_asin(mpfr_t rop,/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_asin(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the arc-tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note that since acos(-1) returns the floating-point number closest to Pi according to the given rounding mode,
        /// this number might not be in the output range 0 &#8804; rop &lt; Pi of the arc-cosine function;
        /// still, the result lies in the image of the output range by the rounding function.
        /// The same holds for asin(-1), asin(1), atan(-Inf), atan(+Inf) or for atan(<paramref name="op"/>) with large
        /// <paramref name="op"/> and small precision of <paramref name="rop"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 4 * atan(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_atan(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 4 * atan(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_atan(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_si(rop, rop, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_atan(mpfr_t rop,/*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_atan(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the sine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = sin(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sin(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.841470984807896506665e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = sin(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sin(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.841470984807896506665e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sin(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sin(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set simultaneously <paramref name="sop"/> to the sine of <paramref name="op"/> and <paramref name="cop"/> to the cosine of <paramref name="op"/>, rounded in the direction <paramref name="rnd"/> with the corresponding precisions of <paramref name="sop"/> and <paramref name="cop"/>, which must be different variables.
        /// </summary>
        /// <param name="sop">The result sine.</param>
        /// <param name="cop">The result cosine.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return 0 iff both results are exact, more precisely it returns s + 4c where s = 0 if <paramref name="sop"/> is exact, s = 1 if <paramref name="sop"/> is larger than the sine of <paramref name="op"/>, s = 2 if <paramref name="sop"/> is smaller than the sine of <paramref name="op"/>, and similarly for c and the cosine of <paramref name="op"/>. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number sop.
        /// mpfr_t sop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(sop, 64U);
        /// 
        /// // Create and initialize a new floating-point number cop.
        /// mpfr_t cop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(cop, 64U);
        /// 
        /// // Set sop = sin(op), cop = cos(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sin_cos(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) == 5);
        /// 
        /// // Assert the value of sop and cop.
        /// Assert.IsTrue(sop.ToString() == "0.841470984807896506665e0");
        /// Assert.IsTrue(cop.ToString() == "0.540302305868139717414e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(sop, cop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number sop.
        /// Dim sop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(sop, 64U)
        /// 
        /// ' Create and initialize a new floating-point number cop.
        /// Dim cop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(cop, 64U)
        /// 
        /// ' Set sop = sin(op), cop = cos(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sin_cos(sop, cop, op, mpfr_rnd_t.MPFR_RNDN) = 5)
        /// 
        /// ' Assert the value of sop and cop.
        /// Assert.IsTrue(sop.ToString() = "0.841470984807896506665e0")
        /// Assert.IsTrue(cop.ToString() = "0.540302305868139717414e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(sop, cop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sin_cos(mpfr_t sop, mpfr_t cop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (sop == null) throw new ArgumentNullException("sop");
            if (cop == null) throw new ArgumentNullException("cop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sin_cos(sop.ToIntPtr(), cop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the cosine of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = cos(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cos(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = cos(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cos(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_cos(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_cos(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the tangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = tan(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_tan(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.155740772465490223046e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = tan(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_tan(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.155740772465490223046e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_tan(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_tan(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the arc-tangent2 of <paramref name="y"/> and <paramref name="x"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="y">The ordinate floating-point value.</param>
        /// <param name="x">The abscissa floating-point value.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="x"/> &gt; 0, atan2(<paramref name="y"/>, <paramref name="x"/>) = atan(<paramref name="y"/>/<paramref name="x"/>);
        /// if <paramref name="x"/> &lt; 0, atan2(<paramref name="y"/>, <paramref name="x"/>) = sign(<paramref name="y"/>) * (Pi - atan(abs(<paramref name="y"/>/<paramref name="x"/>))),
        /// thus a number from -Pi to Pi.
        /// As for atan, in case the exact mathematical result is +Pi or -Pi, its rounded result might be outside the function output range. 
        /// </para>
        /// <para>
        /// atan2(<paramref name="y"/>, 0) does not raise any floating-point exception.
        /// Special values are handled as described in the ISO C99 and IEEE 754-2008 standards for the atan2 function:
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        ///  atan2(+0, -0) returns +Pi. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        ///  atan2(-0, -0) returns -Pi. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(+0, +0) returns +0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(-0, +0) returns -0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(+0, x) returns +Pi for x &lt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(-0, x) returns -Pi for x &lt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(+0, x) returns +0 for x &gt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(-0, x) returns -0 for x &gt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(y, 0) returns -Pi/2 for y &lt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(y, 0) returns +Pi/2 for y &gt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(+Inf, -Inf) returns +3 * Pi/4. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(-Inf, -Inf) returns -3 * Pi/4. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(+Inf, +Inf) returns +Pi/4. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(-Inf, +Inf) returns -Pi/4. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(+Inf, x) returns +Pi/2 for finite x. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(-Inf, x) returns -Pi/2 for finite x. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(y, -Inf) returns +Pi for finite y &gt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(y, -Inf) returns -Pi for finite y &lt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(y, +Inf) returns +0 for finite y &gt; 0. 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// atan2(y, +Inf) returns -0 for finite y &lt; 0.
        /// </description>
        /// </item>
        /// </list>
        /// </remarks>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to -1.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 0.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = atan2(y, x).
        /// Assert.IsTrue(mpfr_lib.mpfr_atan2(rop, y, x, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(x, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, x) == 0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and rop.
        /// mpfr_lib.mpfr_clears(x, y, rop, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to -1.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 0.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = atan2(y, x).
        /// Assert.IsTrue(mpfr_lib.mpfr_atan2(rop, y, x, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert that the value of rop is PI.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(x, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp(rop, x) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and rop.
        /// mpfr_lib.mpfr_clears(x, y, rop, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_atan2(mpfr_t rop,/*const*/ mpfr_t y,/*const*/ mpfr_t x, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_atan2(rop.ToIntPtr(), y.ToIntPtr(), x.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the secant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to pi.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = csc(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sec(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert that the value of rop is -1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -1) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to pi.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = csc(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_sec(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert that the value of rop is -1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, -1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sec(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_sec(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the cosecant of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_cot">mpfr_cot</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to pi / 2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = csc(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_csc(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to pi / 2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = csc(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_csc(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_csc(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_csc(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the cotangent of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_cos">mpfr_cos</seealso>
        /// <seealso cref="mpfr_sin">mpfr_sin</seealso>
        /// <seealso cref="mpfr_tan">mpfr_tan</seealso>
        /// <seealso cref="mpfr_sin_cos">mpfr_sin_cos</seealso>
        /// <seealso cref="mpfr_sec">mpfr_sec</seealso>
        /// <seealso cref="mpfr_csc">mpfr_csc</seealso>
        /// <seealso cref="mpfr_acos">mpfr_acos</seealso>
        /// <seealso cref="mpfr_asin">mpfr_asin</seealso>
        /// <seealso cref="mpfr_atan">mpfr_atan</seealso>
        /// <seealso cref="mpfr_atan2">mpfr_atan2</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to pi / 4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.25, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = cot(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cot(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to pi / 4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_const_pi(op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_d(op, op, 0.25, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = cot(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cot(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert that the value of rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_cot(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_cot(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the Euclidean norm of <paramref name="x"/> and <paramref name="y"/>, i.e., the square root of the sum of the squares of <paramref name="x"/> and <paramref name="y"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="x">The first operand floating-point number.</param>
        /// <param name="y">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Special values are handled as described in the ISO C99 (Section F.9.4.3) and IEEE 754-2008 (Section 9.2.1) standards:
        /// If <paramref name="x"/> or <paramref name="y"/> is an infinity, then +Inf is returned in <paramref name="rop"/>, even if the other number is NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to -3.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number y to 4.
        /// mpfr_t y = new mpfr_t();
        /// mpfr_lib.mpfr_init2(y, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpfr_t z = new mpfr_t();
        /// mpfr_lib.mpfr_init2(z, 64U);
        /// 
        /// // Set z = sqrt(x^2 + y^2).
        /// Assert.IsTrue(mpfr_lib.mpfr_hypot(z, x, y, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of z is 5.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(z, 5) == 0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpfr_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to -3.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, -3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to 4.
        /// Dim y As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(y, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(y, 4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(z, 64U)
        /// 
        /// ' Set z = sqrt(x^2 + y^2).
        /// Assert.IsTrue(mpfr_lib.mpfr_hypot(z, x, y, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of z is 5.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(z, 5) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpfr_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_hypot(mpfr_t rop, /*const*/ mpfr_t x, /*const*/ mpfr_t y, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (y == null) throw new ArgumentNullException("y");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_hypot(rop.ToIntPtr(), x.ToIntPtr(), y.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the error function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to error function of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_erf(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.842700792949714869368e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to error function of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_erf(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.842700792949714869368e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_erf(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_erf(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the complementary error function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to complementary error function of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_erfc(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.157299207050285130659e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to complementary error function of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_erfc(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.157299207050285130659e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_erfc(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_erfc(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the cubic root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This functions agrees with the rootn function of the IEEE 754-2008 standard (Section 9.2).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 8.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = cbrt(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cbrt(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 8.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = cbrt(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_cbrt(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_cbrt(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_cbrt(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the <paramref name="k"/>th root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="k">The degree of the root.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// For <paramref name="k"/> = 0, set <paramref name="rop"/> to NaN.
        /// For <paramref name="k"/> odd (resp. even) and op negative (including −Inf), set <paramref name="rop"/>
        /// to a negative number (resp. NaN).
        /// If <paramref name="op"/> is zero, set <paramref name="rop"/> to zero with the sign obtained by the usual
        /// limit rules, i.e., the same sign as op if <paramref name="k"/> is odd, and positive if
        /// <paramref name="k"/> is even.
        /// </para>
        /// <para>
        /// This functions agrees with the rootn function of the IEEE 754-2008 standard (Section 9.2).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 8.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to the cubic root of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_rootn_ui(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 8.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 8, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to the cubic root of op.
        /// Assert.IsTrue(mpfr_lib.mpfr_rootn_ui(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_si(rop, 2) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_rootn_ui(mpfr_t rop, /*const*/ mpfr_t op, uint k, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_rootn_ui(rop.ToIntPtr(), op.ToIntPtr(), k, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the <paramref name="k"/>th root of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="k">The degree of the root.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// This function is the same as <see cref="mpfr_rootn_ui"/> except when <paramref name="op"/> is −0 and 
        /// <paramref name="k"/> is even: the result is −0 instead of +0 (the reason was to be consistent
        /// with <see cref="mpfr_sqrt"/>).
        /// Said otherwise, if <paramref name="op"/> is zero, set <paramref name="rop"/> to <paramref name="op"/>.
        /// </para>
        /// <para>
        /// This function predates the IEEE 754-2008 standard and behaves differently from its rootn function.
        /// It is marked as deprecated and will be removed in a future release.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 32.0.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 32.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op^(1/5).
        /// Assert.IsTrue(mpfr_lib.mpfr_root(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.200000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 32.0.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 32.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op^(1/5).
        /// Assert.IsTrue(mpfr_lib.mpfr_root(rop, op, 5, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.200000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_root(mpfr_t rop, /*const*/ mpfr_t op, uint /*unsigned long*/ k, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_root(rop.ToIntPtr(), op.ToIntPtr(), k, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a negative integer, <paramref name="rop"/> is set to NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Gamma(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.100000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Gamma(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.100000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_gamma(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_gamma(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the incomplete Gamma function on <paramref name="op"/> and <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// In the literature, <see cref="mpfr_gamma_inc"/> is called upper incomplete Gamma function, or sometimes complementary incomplete Gamma function.
        /// </para>
        /// <para>
        /// For <see cref="mpfr_gamma_inc"/> when <paramref name="op2"/> is zero, when <paramref name="op"/> is a negative integer,
        /// <paramref name="rop"/> is set to NaN. 
        /// </para>
        /// <para>
        /// Note: the current implementation of <see cref="mpfr_gamma_inc"/> is slow for large values of
        /// <paramref name="rop"/> or <paramref name="op"/>, in which case some internal overflow might also occur.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Gamma(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.100000000000000000000e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Gamma(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_gamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.100000000000000000000e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_gamma_inc(mpfr_t rop, /*const*/ mpfr_t op, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_gamma_inc(rop.ToIntPtr(), op.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the Beta function at arguments <paramref name="op1"/> and <paramref name="op2"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Note: the current code does not try to avoid internal overflow or underflow, and might use a huge internal precision in some cases.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 2.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 2.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Beta(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_beta(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.166666666666666666671e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 2.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 2.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Beta(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_beta(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.166666666666666666671e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_beta(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_beta(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the logarithm of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is 1 or 2, set <paramref name="rop"/> to +0 (in all rounding modes).
        /// When <paramref name="op"/> is an infinity or a nonpositive integer, set <paramref name="rop"/> to +Inf,
        /// following the general rules on special values.
        /// When -2k - 1 &lt; op &lt; -2k, k being a nonnegative integer, set <paramref name="rop"/> to NaN.
        /// See also <see cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma">O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma</see>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log(Gamma(op)).
        /// Assert.IsTrue(mpfr_lib.mpfr_lngamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.137108263716202786516e2");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log(Gamma(op)).
        /// Assert.IsTrue(mpfr_lib.mpfr_lngamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.137108263716202786516e2")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_lngamma(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_lngamma(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the logarithm of the absolute value of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="signp">The returned sign.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The sign (1 or -1) of Gamma(<paramref name="op"/>) is returned in the object pointed to by <paramref name="signp"/>.
        /// When <paramref name="op"/> is 1 or 2, set <paramref name="rop"/> to +0 (in all rounding modes).
        /// When <paramref name="op"/> is an infinity or a nonpositive integer, set <paramref name="rop"/> to +Inf.
        /// When <paramref name="op"/> is NaN, -Inf or a negative integer, <paramref name="signp"/> is undefined,
        /// and when <paramref name="op"/> is ±0, <paramref name="signp"/> is the sign of the zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="mpfr_lgamma(mpfr_t, ptr{int}, mpfr_t, mpfr_rnd_t)">mpfr_lgamma(mpfr_t, ptr{int}, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log(|Gamma(op)|).
        /// int sign = 0;
        /// Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop, ref sign, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.137108263716202786516e2" &amp;&amp; sign == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log(|Gamma(op)|).
        /// Dim sign As Integer = 0
        /// Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop,ref sign,op,mpfr_rnd_t.MPFR_RNDN)  =  -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.137108263716202786516e2" AndAlso sign = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_lgamma(mpfr_t rop, ref int /*int **/ signp, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_lgamma(rop.ToIntPtr(), ref signp, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the logarithm of the absolute value of the Gamma function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="signp">The returned sign.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The sign (1 or -1) of Gamma(<paramref name="op"/>) is returned in the object pointed to by <paramref name="signp"/>.
        /// When <paramref name="op"/> is 1 or 2, set <paramref name="rop"/> to +0 (in all rounding modes).
        /// When <paramref name="op"/> is an infinity or a nonpositive integer, set <paramref name="rop"/> to +Inf.
        /// When <paramref name="op"/> is NaN, -Inf or a negative integer, <paramref name="signp"/> is undefined,
        /// and when <paramref name="op"/> is ±0, <paramref name="signp"/> is the sign of the zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="mpfr_lgamma(mpfr_t, ref int, mpfr_t, mpfr_rnd_t)">mpfr_lgamma(mpfr_t, ref int, mpfr_t, mpfr_rnd_t)</seealso>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to log(|Gamma(op)|).
        /// ptr&lt;int&gt; sign = new ptr&lt;int&gt;(0);
        /// Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop, sign, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() == "0.137108263716202786516e2" &amp;&amp; sign.Value == 1);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to log(|Gamma(op)|).
        /// Dim sign As ptr(Of int) =  New ptr(Of int)(0)
        /// Assert.IsTrue(mpfr_lib.mpfr_lgamma(rop, sign, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop and sign.
        /// Assert.IsTrue(rop.ToString() = "0.137108263716202786516e2" AndAlso sign.Value = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_lgamma(mpfr_t rop, ptr<int> /*int **/ signp, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (signp == null) throw new ArgumentNullException("signp");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_lgamma(rop.ToIntPtr(), ref signp.Value, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the Digamma (sometimes also called Psi) function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is a negative integer, set <paramref name="rop"/> to NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = digamma(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_digamma(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "-0.577215664901532860616e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = digamma(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_digamma(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "-0.577215664901532860616e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_digamma(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_digamma(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the Riemann Zeta function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 2.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Zeta(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_zeta(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.164493406684822643642e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 2.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Zeta(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_zeta(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.164493406684822643642e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_zeta(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_zeta(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the Riemann Zeta function on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Zeta(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_zeta_ui(rop, 2U, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.164493406684822643642e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Zeta(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_zeta_ui(rop, 2U, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.164493406684822643642e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_zeta_ui(mpfr_t rop, uint /*unsigned long*/ op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_zeta_ui(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the factorial of <paramref name="op"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = 5!.
        /// Assert.IsTrue(mpfr_lib.mpfr_fac_ui(rop, 5U, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.120000000000000000000e3");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = 5!.
        /// Assert.IsTrue(mpfr_lib.mpfr_fac_ui(rop, 5U, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.120000000000000000000e3")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// </code> 
        /// </example>
        public static int mpfr_fac_ui(mpfr_t rop, uint /*unsigned long int*/ op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_fac_ui(rop.ToIntPtr(), op, (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the first kind Bessel function of order 0 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = J0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_j0(rop, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "-0.243371750714207143215e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = J0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_j0(rop, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "-0.243371750714207143215e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_j0(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_j0(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the first kind Bessel function of order 1 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = J0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_j1(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "-0.554727618489979474337e-1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = J0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_j1(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "-0.554727618489979474337e-1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_j1(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_j1(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the first kind Bessel function of order <paramref name="n"/> on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="n">Order of the Bessel function.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
        /// When <paramref name="op"/> is zero, and <paramref name="n"/> is not zero, <paramref name="rop"/>
        /// is set to +0 or -0 depending on the parity and sign of <paramref name="n"/>, and the sign of <paramref name="op"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 10.4.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = J0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_jn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.144974266424802618878e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 10.4.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(op, 10.4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = J0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_jn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.144974266424802618878e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_jn(mpfr_t rop, int /*long*/ n, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_jn(rop.ToIntPtr(), n, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the first kind Bessel function of order 0 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Y0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_y0(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.882569642156769579796e-1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Y0(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_y0(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.882569642156769579796e-1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_y0(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_y0(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the first kind Bessel function of order 1 on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Y1(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_y1(rop, op, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "-0.781212821300288716550e0");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Y1(op).
        /// Assert.IsTrue(mpfr_lib.mpfr_y1(rop, op, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "-0.781212821300288716550e0")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_y1(mpfr_t rop, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_y1(rop.ToIntPtr(), op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the first kind Bessel function of order <paramref name="n"/> on <paramref name="op"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="n">Order of the Bessel function.</param>
        /// <param name="op">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="op"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="op"/> is plus or minus Infinity, <paramref name="rop"/> is set to +0.
        /// When <paramref name="op"/> is zero, and <paramref name="n"/> is not zero, <paramref name="rop"/>
        /// is set to +0 or -0 depending on the parity and sign of <paramref name="n"/>, and the sign of <paramref name="op"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op to 1.
        /// mpfr_t op = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Yn(3, op).
        /// Assert.IsTrue(mpfr_lib.mpfr_yn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "-0.582151760596472884774e1");
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op to 1.
        /// Dim op As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Yn(3, op).
        /// Assert.IsTrue(mpfr_lib.mpfr_yn(rop, 3, op, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "-0.582151760596472884774e1")
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpfr_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_yn(mpfr_t rop, int /*long*/ n, /*const*/ mpfr_t op, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.mpfr_yn(rop.ToIntPtr(), n, op.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of the Airy function Ai on <paramref name="x"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="x"/> is NaN, <paramref name="rop"/> is always set to NaN.
        /// When <paramref name="x"/> is +Inf or -Inf, <paramref name="rop"/> is +0.
        /// The current implementation is not intended to be used with large arguments.
        /// It works with abs(<paramref name="x"/>) typically smaller than 500.
        /// For larger arguments, other methods should be used and will be implemented in a future version. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 1.0.
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_init2(x, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 1.0, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Airy(x).
        /// Assert.IsTrue(mpfr_lib.mpfr_ai(rop, x, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() == "0.135292416312881415524e0");
        /// 
        /// // Release unmanaged memory allocated for x and rop.
        /// mpfr_lib.mpfr_clears(x, rop, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 1.0.
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(x, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_d(x, 1.0, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Airy(x).
        /// Assert.IsTrue(mpfr_lib.mpfr_ai(rop, x, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(rop.ToString() = "0.135292416312881415524e0")
        /// 
        /// ' Release unmanaged memory allocated for x and rop.
        /// mpfr_lib.mpfr_clears(x, rop, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_ai(mpfr_t rop, /*const*/ mpfr_t x, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_ai(rop.ToIntPtr(), x.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the minimum of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op1"/> and <paramref name="op2"/> are both NaN, then <paramref name="rop"/> is set to NaN.
        /// If <paramref name="op1"/> or <paramref name="op2"/> is NaN, then <paramref name="rop"/> is set to the numeric value.
        /// If <paramref name="op1"/> and <paramref name="op2"/> are zeros of different signs, then <paramref name="rop"/> is set to -0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_max">mpfr_max</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = max(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_min(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -210.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -210.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = max(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_min(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -210.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -210.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_min(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_min(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the maximum of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op1"/> and <paramref name="op2"/> are both NaN, then <paramref name="rop"/> is set to NaN.
        /// If <paramref name="op1"/> or <paramref name="op2"/> is NaN, then <paramref name="rop"/> is set to the numeric value.
        /// If <paramref name="op1"/> and <paramref name="op2"/> are zeros of different signs, then <paramref name="rop"/> is set to +0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_min">mpfr_min</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Miscellaneous_Functions">Miscellaneous Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Miscellaneous-Functions">GNU MPFR - Miscellaneous Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = max(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_max(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = max(op1, op2).
        /// Assert.IsTrue(mpfr_lib.mpfr_max(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_max(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_max(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the positive difference of <paramref name="op1"/> and <paramref name="op2"/>, i.e., <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/> if <paramref name="op1"/> &gt; <paramref name="op2"/>, +0 if <paramref name="op1"/> &#8804; <paramref name="op2"/>, and NaN if <paramref name="op1"/> or <paramref name="op2"/> is NaN. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop to positive difference of op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_dim(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop to positive difference of op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_dim(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_dim(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_dim(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands
        /// (for types having no signed zeros, 0 is considered positive).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new integer op2 to -210.
        /// mpz_t op2 = "-210";
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 * op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2100.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new integer op2 to -210.
        /// Dim op2 As mpz_t = "-210" 
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 * op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2100.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_mul_z(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpz_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_mul_z(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new integer op2 to 10.
        /// mpz_t op2 = new mpz_t();
        /// gmp_lib.mpz_init(op2);
        /// gmp_lib.mpz_set_si(op2, 10);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new integer op2 to 10.
        /// Dim op2 As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init(op2)
        /// gmp_lib.mpz_set_si(op2, 10)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_div_z(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpz_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_div_z(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_sum">mpfr_sum</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new integer op2 to 5.
        /// mpz_t op2 = new mpz_t();
        /// gmp_lib.mpz_init_set_si(op2, 5);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 + op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -200.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -205.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new integer op2 to 5.
        /// Dim op2 As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init_set_si(op2, 5)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 + op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -200.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -205.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_add_z(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpz_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_add_z(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new integer op2 to -210.
        /// mpz_t op2 = "-210";
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new integer op2 to -210.
        /// Dim op2 As mpz_t = "-210" 
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_z(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_sub_z(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpz_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_sub_z(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer op1 to -210.
        /// mpz_t op1 = "-210";
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_z_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -220.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, null);
        /// gmp_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer op1 to -210.
        /// Dim op1 As mpz_t = "-210" 
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_z_sub(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op2, Nothing)
        /// gmp_lib.mpz_clear(op1)
        /// </code> 
        /// </example>
        public static int mpfr_z_sub(mpfr_t rop, /*const*/ mpz_t op1, /*const*/ mpfr_t op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_z_sub(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new integer op2 to 128.
        /// mpz_t op2 = new mpz_t();
        /// gmp_lib.mpz_init_set_si(op2, 128);
        /// 
        /// // Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_z(op1, op2) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clear(op1);
        /// gmp_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new integer op2 to 128.
        /// Dim op2 As mpz_t = New mpz_t()
        /// gmp_lib.mpz_init_set_si(op2, 128)
        /// 
        /// ' Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_z(op1, op2) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clear(op1)
        /// gmp_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_z(/*const*/ mpfr_t op1, /*const*/ mpz_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_cmp_z(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands
        /// (for types having no signed zeros, 0 is considered positive).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_mul_ui">mpfr_mul_ui</seealso>
        /// <seealso cref="mpfr_mul_si">mpfr_mul_si</seealso>
        /// <seealso cref="mpfr_mul_d">mpfr_mul_d</seealso>
        /// <seealso cref="mpfr_mul_z">mpfr_mul_z</seealso>
        /// <seealso cref="mpfr_mul_q">mpfr_mul_q</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_mul_2ui">mpfr_mul_2ui</seealso>
        /// <seealso cref="mpfr_mul_2si">mpfr_mul_2si</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new rational op2 to -210.
        /// mpq_t op2 = "-210/1";
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 * op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2100.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpq_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new rational op2 to -210.
        /// Dim op2 As mpq_t = "-210/1" 
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 * op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_mul_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2100.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2100.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpq_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_mul_q(mpfr_t rop, /*const*/ mpfr_t op1, mpq_t /*mpq_srcptr*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_mul_q(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// When a result is zero, its sign is the product of the signs of the operands.
        /// For types having no signed zeros, 0 is considered positive; but note that if 
        /// <paramref name="op1"/> is non-zero and <paramref name="op2"/> is zero, the result might change from
        /// ±Inf to NaN in future MPFR versions if there is an opposite decision on the IEEE 754 side. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_ui_div">mpfr_ui_div</seealso>
        /// <seealso cref="mpfr_div_ui">mpfr_div_ui</seealso>
        /// <seealso cref="mpfr_si_div">mpfr_si_div</seealso>
        /// <seealso cref="mpfr_div_si">mpfr_div_si</seealso>
        /// <seealso cref="mpfr_d_div">mpfr_d_div</seealso>
        /// <seealso cref="mpfr_div_d">mpfr_div_d</seealso>
        /// <seealso cref="mpfr_div_z">mpfr_div_z</seealso>
        /// <seealso cref="mpfr_div_q">mpfr_div_q</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new rational op2 to 10.
        /// mpq_t op2 = new mpq_t();
        /// gmp_lib.mpq_init(op2);
        /// gmp_lib.mpq_set_si(op2, 10, 1);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpq_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new rational op2 to 10.
        /// Dim op2 As mpq_t = New mpq_t()
        /// gmp_lib.mpq_init(op2)
        /// gmp_lib.mpq_set_si(op2, 10, 1)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 / op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_div_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -21.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpq_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_div_q(mpfr_t rop, /*const*/ mpfr_t op1, mpq_t /*mpq_srcptr*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_div_q(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) + 0 = (+0) and (-0) + 0 = (-0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_sum">mpfr_sum</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new rational number op2 to 1/5.
        /// mpq_t op2 = new mpq_t();
        /// gmp_lib.mpq_init(op2);
        /// gmp_lib.mpq_set_si(op2, 1, 5);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 + op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == -1);
        /// 
        /// // Assert the value of rop.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -209.8);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpq_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new rational number op2 to 1/5.
        /// Dim op2 As mpq_t = New mpq_t()
        /// gmp_lib.mpq_init(op2)
        /// gmp_lib.mpq_set_si(op2, 1, 5)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 + op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = -1)
        /// 
        /// ' Assert the value of rop.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -209.8)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpq_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_add_q(mpfr_t rop, /*const*/ mpfr_t op1, mpq_t /*mpq_srcptr*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_add_q(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/> rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The IEEE-754 rules are used, in particular for signed zeros.
        /// But for types having no signed zeros, 0 is considered unsigned
        /// (i.e., (+0) - 0 = (+0), (-0) - 0 = (-0), 0 - (+0) = (-0) and 0 - (-0) = (+0)).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_sub">mpfr_sub</seealso>
        /// <seealso cref="mpfr_ui_sub">mpfr_ui_sub</seealso>
        /// <seealso cref="mpfr_sub_ui">mpfr_sub_ui</seealso>
        /// <seealso cref="mpfr_si_sub">mpfr_si_sub</seealso>
        /// <seealso cref="mpfr_sub_si">mpfr_sub_si</seealso>
        /// <seealso cref="mpfr_d_sub">mpfr_d_sub</seealso>
        /// <seealso cref="mpfr_sub_d">mpfr_sub_d</seealso>
        /// <seealso cref="mpfr_z_sub">mpfr_z_sub</seealso>
        /// <seealso cref="mpfr_sub_z">mpfr_sub_z</seealso>
        /// <seealso cref="mpfr_sub_q">mpfr_sub_q</seealso>
        /// <seealso cref="mpfr_mul">mpfr_mul</seealso>
        /// <seealso cref="mpfr_sqr">mpfr_sqr</seealso>
        /// <seealso cref="mpfr_div">mpfr_div</seealso>
        /// <seealso cref="mpfr_sqrt">mpfr_sqrt</seealso>
        /// <seealso cref="mpfr_cbrt">mpfr_cbrt</seealso>
        /// <seealso cref="mpfr_rootn_ui">mpfr_root</seealso>
        /// <seealso cref="mpfr_root">mpfr_root</seealso>
        /// <seealso cref="mpfr_pow">mpfr_pow</seealso>
        /// <seealso cref="mpfr_neg">mpfr_neg</seealso>
        /// <seealso cref="mpfr_abs">mpfr_abs</seealso>
        /// <seealso cref="mpfr_dim">mpfr_dim</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new rational op2 to -210.
        /// mpq_t op2 = "-210/1";
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, null);
        /// gmp_lib.mpq_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new rational op2 to -210.
        /// Dim op2 As mpq_t = "-210/1" 
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = op1 - op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_sub_q(rop, op1, op2, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 220.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, Nothing)
        /// gmp_lib.mpq_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_sub_q(mpfr_t rop, /*const*/ mpfr_t op1, mpq_t /*mpq_srcptr*/ op2, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_sub_q(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_f">mpfr_cmp_f</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new rational number op2.
        /// mpq_t op2 = new mpq_t();
        /// gmp_lib.mpq_init(op2);
        /// gmp_lib.mpq_set_si(op2, 128, 1);
        /// 
        /// // Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_q(op1, op2) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clear(op1);
        /// gmp_lib.mpq_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new rational number op2.
        /// Dim op2 As mpq_t = New mpq_t()
        /// gmp_lib.mpq_init(op2)
        /// gmp_lib.mpq_set_si(op2, 128, 1)
        /// 
        /// ' Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_q(op1, op2) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clear(op1)
        /// gmp_lib.mpq_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_q(/*const*/ mpfr_t op1, mpq_t /*mpq_srcptr*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_cmp_q(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both <paramref name="op1"/> and <paramref name="op2"/> are considered to their full own precision, which may differ.
        /// If one of the operands is NaN, set the erange flag and return zero. 
        /// </para>
        /// <para>
        /// Note: These functions may be useful to distinguish the three possible cases.
        /// If you need to distinguish two cases only, it is recommended to use the predicate functions
        /// (e.g., <see cref="mpfr_equal_p">mpfr_equal_p</see> for the equality) described below; they behave like the IEEE 754 comparisons,
        /// in particular when one or both arguments are NaN.
        /// But only floating-point numbers can be compared (you may need to do a conversion first). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_cmp">mpfr_cmp</seealso>
        /// <seealso cref="mpfr_cmp_ui">mpfr_cmp_ui</seealso>
        /// <seealso cref="mpfr_cmp_si">mpfr_cmp_si</seealso>
        /// <seealso cref="mpfr_cmp_d">mpfr_cmp_d</seealso>
        /// <seealso cref="mpfr_cmp_z">mpfr_cmp_z</seealso>
        /// <seealso cref="mpfr_cmp_q">mpfr_cmp_q</seealso>
        /// <seealso cref="mpfr_cmp_ui_2exp">mpfr_cmp_ui_2exp</seealso>
        /// <seealso cref="mpfr_cmp_si_2exp">mpfr_cmp_si_2exp</seealso>
        /// <seealso cref="mpfr_cmpabs">mpfr_cmpabs</seealso>
        /// <seealso cref="mpfr_nan_p">mpfr_nan_p</seealso>
        /// <seealso cref="mpfr_inf_p">mpfr_inf_p</seealso>
        /// <seealso cref="mpfr_number_p">mpfr_number_p</seealso>
        /// <seealso cref="mpfr_zero_p">mpfr_zero_p</seealso>
        /// <seealso cref="mpfr_regular_p">mpfr_regular_p</seealso>
        /// <seealso cref="mpfr_sgn">mpfr_sgn</seealso>
        /// <seealso cref="mpfr_greater_p">mpfr_greater_p</seealso>
        /// <seealso cref="mpfr_greaterequal_p">mpfr_greaterequal_p</seealso>
        /// <seealso cref="mpfr_less_p">mpfr_less_p</seealso>
        /// <seealso cref="mpfr_lessequal_p">mpfr_lessequal_p</seealso>
        /// <seealso cref="mpfr_equal_p">mpfr_equal_p</seealso>
        /// <seealso cref="mpfr_lessgreater_p">mpfr_lessgreater_p</seealso>
        /// <seealso cref="mpfr_unordered_p">mpfr_unordered_p</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Comparison_Functions">Comparison Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions">GNU MPFR - Comparison Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 512.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number op2.
        /// mpf_t op2 = new mpf_t();
        /// gmp_lib.mpf_init_set_si(op2, 128);
        /// 
        /// // Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_f(op1, op2) &gt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clear(op1);
        /// gmp_lib.mpf_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 512.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 512, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number op2.
        /// Dim op2 As mpf_t = New mpf_t()
        /// gmp_lib.mpf_init_set_si(op2, 128)
        /// 
        /// ' Assert that op1 &gt; op2.
        /// Assert.IsTrue(mpfr_lib.mpfr_cmp_f(op1, op2) &gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpfr_clear(op1)
        /// gmp_lib.mpf_clear(op2)
        /// </code> 
        /// </example>
        public static int mpfr_cmp_f(/*const*/ mpfr_t op1, /*const*/ mpf_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.mpfr_cmp_f(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) + <paramref name="op3"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="op3">The third operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Concerning special values (signed zeros, infinities, NaN), these functions behave like a multiplication followed by a separate addition.
        /// That is, the fused operation matters only for rounding. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op3 to 10.
        /// mpfr_t op3 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op3, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = (op1 * op2) + op3.
        /// Assert.IsTrue(mpfr_lib.mpfr_fma(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2090.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2090.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, op2, and op3.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op3 to 10.
        /// Dim op3 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op3, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = (op1 * op2) + op3.
        /// Assert.IsTrue(mpfr_lib.mpfr_fma(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2090.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2090.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, op2, and op3.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fma(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, /*const*/ mpfr_t op3, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            if (op3 == null) throw new ArgumentNullException("op3");
            return SafeNativeMethods.mpfr_fma(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), op3.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) - <paramref name="op3"/> rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="op3">The third operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// Concerning special values (signed zeros, infinities, NaN), these functions behave like a multiplication followed by a separate subtraction.
        /// That is, the fused operation matters only for rounding. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op3 to 10.
        /// mpfr_t op3 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op3, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = (op1 * op2) - op3.
        /// Assert.IsTrue(mpfr_lib.mpfr_fms(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2110.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2110.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, op2, and op3.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op3 to 10.
        /// Dim op3 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op3, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = (op1 * op2) - op3.
        /// Assert.IsTrue(mpfr_lib.mpfr_fms(rop, op1, op2, op3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2110.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2110.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, op2, and op3.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fms(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, /*const*/ mpfr_t op3, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            if (op3 == null) throw new ArgumentNullException("op3");
            return SafeNativeMethods.mpfr_fms(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), op3.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) + (<paramref name="op3"/> * <paramref name="op4"/>) rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="op3">The third operand floating-point number.</param>
        /// <param name="op4">The fourth operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// In case the computation of <paramref name="op1"/> × <paramref name="op2"/> overflows or underflows
        /// (or that of <paramref name="op3"/> × <paramref name="op4"/>), the result <paramref name="rop"/> is
        /// computed as if the two intermediate products were computed with rounding toward zero. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmms">mpfr_fmms</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op3 to 10.
        /// mpfr_t op3 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op3, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op4 to 10.
        /// mpfr_t op4 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op4, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = (op1 * op2) + (op3 * op4).
        /// Assert.IsTrue(mpfr_lib.mpfr_fmma(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2090.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2000.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, op2, and op3.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op3 to 10.
        /// Dim op3 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op3, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op4 to 10.
        /// Dim op4 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op4, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = (op1 * op2) + (op3 * op4).
        /// Assert.IsTrue(mpfr_lib.mpfr_fmma(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2090.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2000.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, op2, op3, and op4.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fmma(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, /*const*/ mpfr_t op3,  /*const*/ mpfr_t op4, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            if (op3 == null) throw new ArgumentNullException("op3");
            if (op3 == null) throw new ArgumentNullException("op3");
            return SafeNativeMethods.mpfr_fmma(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), op3.ToIntPtr(), op4.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="op1"/> * <paramref name="op2"/>) - (<paramref name="op3"/> * <paramref name="op4"/>) rounded in the direction <paramref name="rnd"/>. 
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="op1">The first operand floating-point number.</param>
        /// <param name="op2">The second operand floating-point number.</param>
        /// <param name="op3">The third operand floating-point number.</param>
        /// <param name="op4">The fourth operand floating-point number.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// In case the computation of <paramref name="op1"/> × <paramref name="op2"/> overflows or underflows
        /// (or that of <paramref name="op3"/> × <paramref name="op4"/>), the result <paramref name="rop"/> is
        /// computed as if the two intermediate products were computed with rounding toward zero. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_fac_ui">mpfr_fac_ui</seealso>
        /// <seealso cref="mpfr_eint">mpfr_eint</seealso>
        /// <seealso cref="mpfr_li2">mpfr_li2</seealso>
        /// <seealso cref="mpfr_gamma">mpfr_gamma</seealso>
        /// <seealso cref="mpfr_gamma_inc">mpfr_gamma_inc</seealso>
        /// <seealso cref="mpfr_lngamma">mpfr_lngamma</seealso>
        /// <seealso cref="O:Math.Mpfr.Native.mpfr_lib.mpfr_lgamma"/>
        /// <seealso cref="mpfr_digamma">mpfr_digamma</seealso>
        /// <seealso cref="mpfr_beta">mpfr_beta</seealso>
        /// <seealso cref="mpfr_zeta">mpfr_zeta</seealso>
        /// <seealso cref="mpfr_zeta_ui">mpfr_zeta_ui</seealso>
        /// <seealso cref="mpfr_erf">mpfr_erf</seealso>
        /// <seealso cref="mpfr_erfc">mpfr_erfc</seealso>
        /// <seealso cref="mpfr_j0">mpfr_j0</seealso>
        /// <seealso cref="mpfr_j1">mpfr_j1</seealso>
        /// <seealso cref="mpfr_jn">mpfr_jn</seealso>
        /// <seealso cref="mpfr_y0">mpfr_y0</seealso>
        /// <seealso cref="mpfr_y1">mpfr_y1</seealso>
        /// <seealso cref="mpfr_yn">mpfr_yn</seealso>
        /// <seealso cref="mpfr_fma">mpfr_fma</seealso>
        /// <seealso cref="mpfr_fms">mpfr_fms</seealso>
        /// <seealso cref="mpfr_fmma">mpfr_fmma</seealso>
        /// <seealso cref="mpfr_agm">mpfr_agm</seealso>
        /// <seealso cref="mpfr_hypot">mpfr_hypot</seealso>
        /// <seealso cref="mpfr_ai">mpfr_ai</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to -210.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 10.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op3 to 10.
        /// mpfr_t op3 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op3, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op4 to 10.
        /// mpfr_t op4 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op4, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = (op1 * op2) - (op3 * op4).
        /// Assert.IsTrue(mpfr_lib.mpfr_fmms(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is -2200.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == -2200.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, op2, and op3.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to -210.
        /// Dim op1 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, -210, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 10.
        /// Dim op2 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op3 to 10.
        /// Dim op3 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op3, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op4 to 10.
        /// Dim op4 As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op4, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op4, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = (op1 * op2) - (op3 * op4).
        /// Assert.IsTrue(mpfr_lib.mpfr_fmms(rop, op1, op2, op3, op4, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is -2200.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = -2200.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, op2, op3, and op4.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, op4, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_fmms(mpfr_t rop, /*const*/ mpfr_t op1, /*const*/ mpfr_t op2, /*const*/ mpfr_t op3, /*const*/ mpfr_t op4, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            if (op3 == null) throw new ArgumentNullException("op3");
            if (op3 == null) throw new ArgumentNullException("op4");
            return SafeNativeMethods.mpfr_fmms(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr(), op3.ToIntPtr(), op4.ToIntPtr(), (int)rnd);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the sum of all elements of <paramref name="tab"/>, whose size is <paramref name="n"/>, correctly rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="tab">Array of floating-point numbers.</param>
        /// <param name="n">The number of floating-point numbers in <paramref name="tab"/>.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The returned int value is zero, <paramref name="rop"/> is guaranteed to be the exact sum; otherwise <paramref name="rop"/> might be smaller than, equal to, or larger than the exact sum.</returns>
        /// <remarks>
        /// <para>
        /// Warning: for efficiency reasons, <paramref name="tab"/> is an array of pointers to <see cref="mpfr_t"/>,
        /// not an array of <see cref="mpfr_t"/>.
        /// If <paramref name="n"/> = 0, then the result is +0, and if <paramref name="n"/> = 1, then the function
        /// is equivalent to <see cref="mpfr_set"/>.
        /// For the special exact cases, the result is the same as the one obtained with a succession of additions
        /// (<see cref="mpfr_add"/>) in infinite precision. In particular, if the result is an exact zero and
        /// <paramref name="n"/> &#8804; 1:
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// if all the inputs have the same sign (i.e., all +0 or all −0), then the result has the same sign as the inputs;
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// otherwise, either because all inputs are zeros with at least a +0 and a −0, or because some inputs are non-zero
        /// (but they globally cancel), the result is +0, except for the <see cref="mpfr_rnd_t.MPFR_RNDD"/> rounding mode,
        /// where it is −0.
        /// </description>
        /// </item>
        /// </list>
        /// </remarks>
        /// <seealso cref="mpfr_add">mpfr_add</seealso>
        /// <seealso cref="mpfr_add_ui">mpfr_add_ui</seealso>
        /// <seealso cref="mpfr_add_si">mpfr_add_si</seealso>
        /// <seealso cref="mpfr_add_d">mpfr_add_d</seealso>
        /// <seealso cref="mpfr_add_z">mpfr_add_z</seealso>
        /// <seealso cref="mpfr_add_q">mpfr_add_q</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Basic_Arithmetic_Functions">Basic Arithmetic Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Basic-Arithmetic-Functions">GNU MPFR - Basic Arithmetic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number op1 to 10.
        /// mpfr_t op1 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op1, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op2 to 20.
        /// mpfr_t op2 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op2, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 20, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create, initialize, and set a new floating-point number op3 to 30.
        /// mpfr_t op3 = new mpfr_t();
        /// mpfr_lib.mpfr_init2(op3, 64U);
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 30, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Set rop = Sum({op1, op2, op3}).
        /// Assert.IsTrue(mpfr_lib.mpfr_sum(rop, new mpfr_t[] { op1, op2, op3 }, 3, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 60.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 60.0);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number op1 to 10.
        ///  mpfr_t op1 = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op1, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op1, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op2 to 20.
        /// mpfr_t op2 = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op2, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op2, 20, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create, initialize, and set a new floating-point number op3 to 30.
        /// mpfr_t op3 = New mpfr_t()
        /// mpfr_lib.mpfr_init2(op3, 64U)
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(op3, 30, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Create and initialize a new floating-point number rop.
        /// mpfr_t rop = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Set rop = Sum({op1, op2, op3}).
        /// Assert.IsTrue(mpfr_lib.mpfr_sum(rop, New mpfr_t() { op1, op2, op3 }, 3, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 60.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 60.0)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpfr_clears(rop, op1, op2, op3, Nothing)
        /// </code> 
        /// </example>
        public static int mpfr_sum(mpfr_t rop, /*const*/ mpfr_t[] /***/ tab, uint /*unsigned long*/ n, mpfr_rnd_t rnd)
        {
            if (tab == null) throw new ArgumentNullException("tab");
            void_ptr p = gmp_lib.allocate((size_t)(n * IntPtr.Size));
            for (int i = 0; i < n; i++) Marshal.WriteIntPtr(p.ToIntPtr(), i * IntPtr.Size, tab[i].ToIntPtr());
            if (rop == null) throw new ArgumentNullException("rop");
            int result = SafeNativeMethods.mpfr_sum(rop.ToIntPtr(), p.ToIntPtr(), n, (int)rnd);
            gmp_lib.free(p);
            return result;
        }

        /// <summary>
        /// Free all caches and pools used by MPFR internally.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Free all caches and pools used by MPFR internally (thoses local to the current thread and those shared by all threads).
        /// You should call this function before terminating a thread, even if you did not call mpfr_const_* functions directly
        /// (they could have been called internally).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number z.
        /// mpfr_t z = new mpfr_t();
        /// mpfr_lib.mpfr_init2(z, 64U);
        /// 
        /// // Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z);
        /// 
        /// // Frere constants cache.
        /// mpfr_lib.mpfr_free_cache();
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(z, 64U)
        /// 
        /// ' Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z)
        /// 
        /// ' Frere constants cache.
        /// mpfr_lib.mpfr_free_cache()
        /// </code> 
        /// </example>
        public static void mpfr_free_cache(/*void*/)
        {
            SafeNativeMethods.mpfr_free_cache();
        }

        /// <summary>
        /// Free various caches and pools used by MPFR internally, as specified by <paramref name="way"/>, which is a set of flags
        /// </summary>
        /// <param name="way">Flags specifying what to free,.</param>
        /// <remarks>
        /// <para>
        /// Free those local to the current thread if flag <see cref="mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE"/> is set.
        /// Free those shared by all threads if flag <see cref="mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE"/> is set.
        /// </para>
        /// <para>
        /// The other bits of <paramref name="way"/> are currently ignored and are reserved for future use; they should be zero.
        /// </para>
        /// <para>
        /// Note: <see cref="mpfr_free_cache2"/>(<see cref="mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE"/> | <see cref="mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE"/>) is currently
        /// equivalent to <see cref="mpfr_free_cache"/>().
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache</seealso>
        /// <seealso cref="mpfr_free_pool">mpfr_free_pool</seealso>
        /// <seealso cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number z.
        /// mpfr_t z = new mpfr_t();
        /// mpfr_lib.mpfr_init2(z, 64U);
        /// 
        /// // Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z);
        /// 
        /// // Free constants cache.
        /// mpfr_lib.mpfr_free_cache2(mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE | mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(z, 64U)
        /// 
        /// ' Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z)
        /// 
        /// ' Free constants cache.
        /// mpfr_lib.mpfr_free_cache2(mpfr_free_cache_t.MPFR_FREE_GLOBAL_CACHE Or mpfr_free_cache_t.MPFR_FREE_LOCAL_CACHE)
        /// </code> 
        /// </example>
        public static void mpfr_free_cache2(mpfr_free_cache_t way)
        {
            SafeNativeMethods.mpfr_free_cache2((uint) way);
        }

        /// <summary>
        /// Free the pools used by MPFR internally.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: This function is automatically called after the thread-local caches are freed (with <see cref="mpfr_free_cache"/> or <see cref="mpfr_free_cache2"/>).
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_free_cache2">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_mp_memory_cleanup">mpfr_mp_memory_cleanup</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number z.
        /// mpfr_t z = new mpfr_t();
        /// mpfr_lib.mpfr_init2(z, 64U);
        /// 
        /// // Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z);
        /// 
        /// // Free internal pools.
        /// mpfr_lib.mpfr_free_pool();
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(z, 64U)
        /// 
        /// ' Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z)
        /// 
        /// ' Free internal pools.
        /// mpfr_lib.mpfr_free_pool()
        /// </code> 
        /// </example>
        public static void mpfr_free_pool(/*void*/)
        {
            SafeNativeMethods.mpfr_free_pool();
        }

        /// <summary>
        /// This function should be called before calling <see cref="gmp_lib.mp_set_memory_functions"/>.
        /// </summary>
        /// <returns>Zero is returned in case of success, non-zero in case of error.</returns>
        /// <remarks>
        /// <para>
        /// See Section 4.7 <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Memory-Handling">GNU MPFR - Memory Handling</a>, page 10, for more information.
        /// Zero is returned in case of success, nonzero in case of error.
        /// Errors are currently not possible, but checking the return value is recommended for future compatibility.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_const_log2">mpfr_const_log2</seealso>
        /// <seealso cref="mpfr_const_pi">mpfr_const_pi</seealso>
        /// <seealso cref="mpfr_const_euler">mpfr_const_euler</seealso>
        /// <seealso cref="mpfr_const_catalan">mpfr_const_catalan</seealso>
        /// <seealso cref="mpfr_free_cache">mpfr_free_cache</seealso>
        /// <seealso cref="mpfr_free_cache2">mpfr_free_cache2</seealso>
        /// <seealso cref="mpfr_free_pool">mpfr_free_pool</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Special_Functions">Special Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Special-Functions">GNU MPFR - Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number z.
        /// mpfr_t z = new mpfr_t();
        /// mpfr_lib.mpfr_init2(z, 64U);
        /// 
        /// // Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) == 1);
        /// Assert.IsTrue(z.ToString() == "0.693147180559945309429e0");
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z);
        /// 
        /// // Free internal pools.
        /// mpfr_lib.mpfr_free_pool();
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(z, 64U)
        /// 
        /// ' Assert that z is the Catalan's constant.
        /// Assert.IsTrue(mpfr_lib.mpfr_const_log2(z, mpfr_rnd_t.MPFR_RNDN) = 1)
        /// Assert.IsTrue(z.ToString() = "0.693147180559945309429e0")
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpfr_clear(z)
        /// 
        /// ' Free internal pools.
        /// mpfr_lib.mpfr_free_pool()
        /// </code> 
        /// </example>
        public static int mpfr_mp_memory_cleanup(/*void*/)
        {
            return SafeNativeMethods.mpfr_mp_memory_cleanup();
        }

        /// <summary>
        /// This function rounds <paramref name="x"/> emulating subnormal number arithmetic.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="t">The input <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a>.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>The usual <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is returned.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="x"/> is outside the subnormal exponent range of the emulated floating-point system, this function just propagates
        /// the ternary value <paramref name="t"/>; otherwise, it rounds <paramref name="x"/> to precision EXP(<paramref name="x"/>) - emin + 1
        /// according to rounding mode <paramref name="rnd"/> and previous ternary value <paramref name="t"/>, avoiding double rounding problems.
        /// More precisely in the subnormal domain, denoting by e the value of emin, <paramref name="x"/> is rounded in fixedpoint arithmetic to an
        /// integer multiple of two to the power e - 1; as a consequence, 1.5 multiplied by two to the power e - 1 when <paramref name="t"/> is zero
        /// is rounded to two to the power e with rounding to nearest.
        /// </para>
        /// <para>
        /// PREC(<paramref name="x"/>) is not modified by this function.
        /// <paramref name="rnd"/> and <paramref name="t"/> must be the rounding mode and the returned
        /// <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> used when computing <paramref name="x"/>
        /// (as in <see cref="mpfr_check_range">mpfr_check_range</see>).
        /// The subnormal exponent range is from emin to emin + PREC(<paramref name="x"/>) - 1.
        /// If the result cannot be represented in the current exponent range of MPFR (due to a too small emax),
        /// the behavior is undefined.
        /// Note that unlike most functions, the result is compared to the exact one, not the input value <paramref name="x"/>,
        /// i.e., the <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is propagated. 
        /// </para>
        /// <para>
        /// As usual, if the returned <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is non zero,
        /// the inexact flag is set.
        /// Moreover, if a second rounding occurred (because the input <paramref name="x"/> was in the subnormal range), the underflow flag is set. 
        /// </para>
        /// <para>
        /// Warning! If you change emin (with <see cref="mpfr_set_emin"/>) just before calling <see cref="mpfr_subnormalize"/>, you need to make
        /// sure that the value is in the current exponent range of MPFR.
        /// But it is better to change emin before any computation, if possible.
        /// </para>
        /// <para>
        /// This is an example of how to emulate binary double IEEE 754 arithmetic (binary64 in IEEE 754-2008) using MPFR:
        /// </para>
        /// <code language="C#">
        /// mpfr_t xa, xb; int i; volatile double a, b;
        /// mpfr_set_default_prec(53);
        /// mpfr_set_emin(-1073);
        /// mpfr_set_emax(1024);
        /// 
        /// mpfr_init(xa); mpfr_init(xb);
        /// 
        /// b = 34.3; mpfr_set_d(xb, b, MPFR_RNDN);
        /// a = 0x1.1235P-1021;
        /// mpfr_set_d(xa, a, MPFR_RNDN);
        /// 
        /// a /= b;
        /// i = mpfr_div(xa, xa, xb, MPFR_RNDN);
        /// i = mpfr_subnormalize(xa, i, MPFR_RNDN); /* new ternary value */
        /// 
        /// mpfr_clear(xa);
        /// mpfr_clear(xb);
        /// </code> 
        /// <para>
        /// Note that <see cref="mpfr_set_emin"/> and <see cref="mpfr_set_emax"/> are called early enough in order to make sure that all
        /// computed values are in the current exponent range.
        /// Warning! This emulates a double IEEE 754 arithmetic with correct rounding in the subnormal range, which may not be the case
        /// for your hardware.
        /// </para>
        /// <para>
        /// Below is another example showing how to emulate fixed-point arithmetic in a specific case.
        /// Here we compute the sine of the integers 1 to 17 with a result in a fixed-point arithmetic rounded at 2−42 
        /// (using the fact that the result is at most 1 in absolute value):
        /// </para>
        /// <code language="C#">
        /// mpfr_t x; int i, inex;
        /// mpfr_set_emin(-41); 
        /// mpfr_init2(x, 42);
        /// for (i = 1; i &#8804; 17; i++)
        /// { 
        ///     mpfr_set_ui(x, i, MPFR_RNDN);
        ///     inex = mpfr_sin(x, x, MPFR_RNDZ);
        ///     mpfr_subnormalize(x, inex, MPFR_RNDZ);
        ///     mpfr_dump(x);
        /// }
        /// mpfr_clear(x);
        /// </code> 
        /// </remarks>
        /// <seealso cref="mpfr_get_emin">mpfr_get_emin</seealso>
        /// <seealso cref="mpfr_get_emax">mpfr_get_emax</seealso>
        /// <seealso cref="mpfr_set_emin">mpfr_set_emin</seealso>
        /// <seealso cref="mpfr_set_emax">mpfr_set_emax</seealso>
        /// <seealso cref="mpfr_get_emin_min">mpfr_get_emin_min</seealso>
        /// <seealso cref="mpfr_get_emin_max">mpfr_get_emin_max</seealso>
        /// <seealso cref="mpfr_get_emax_min">mpfr_get_emax_min</seealso>
        /// <seealso cref="mpfr_get_emax_max">mpfr_get_emax_max</seealso>
        /// <seealso cref="mpfr_check_range">mpfr_check_range</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Exception_Related_Functions">Exception Related Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Exception-Related-Functions">GNU MPFR - Exception Related Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Emulate IEEE 754 double precision.
        /// mpfr_lib.mpfr_set_default_prec(53U);
        /// mpfr_lib.mpfr_set_emin(-1073);
        /// mpfr_lib.mpfr_set_emax(1023);
        /// 
        /// // Create and initialize near-subnormal floating-point number x.
        /// mpfr_t x = "0x1.1235P-1021";
        /// 
        /// // Create subnormal by dividing by 34.3, and round it emulating subnormal.
        /// int i = mpfr_lib.mpfr_div_d(x, x, 34.3, mpfr_rnd_t.MPFR_RNDN);
        /// i = mpfr_lib.mpfr_subnormalize(x, i, mpfr_rnd_t.MPFR_RNDN);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Emulate IEEE 754 double precision.
        /// mpfr_lib.mpfr_set_default_prec(53U)
        /// mpfr_lib.mpfr_set_emin(-1073)
        /// mpfr_lib.mpfr_set_emax(1023)
        /// 
        /// ' Create and initialize near-subnormal floating-point number x.
        /// Dim x As mpfr_t = "0x1.1235P-1021" 
        /// 
        /// ' Create subnormal by dividing by 34.3, and round it emulating subnormal.
        /// Dim i As Integer = mpfr_lib.mpfr_div_d(x, x, 34.3, mpfr_rnd_t.MPFR_RNDN)
        /// i = mpfr_lib.mpfr_subnormalize(x, i, mpfr_rnd_t.MPFR_RNDN)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpfr_clear(x)
        /// </code> 
        /// </example>
        public static int mpfr_subnormalize(mpfr_t x, int t, mpfr_rnd_t rnd)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_subnormalize(x.ToIntPtr(), t, (int)rnd);
        }

        /// <summary>
        /// Read a floating-point number from a string <paramref name="nptr"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="nptr">String containing a floating-point number.</param>
        /// <param name="endptr">On return, points the first character after floating-point number in <paramref name="nptr"/>.</param>
        /// <param name="base">The base.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The <paramref name="base"/> must be either 0 (to detect the base, as described below) or a number from 2 to 62 (otherwise the behavior is undefined).
        /// If <paramref name="nptr"/> starts with valid data, the result is stored in <paramref name="rop"/> and <paramref name="endptr"/> points to the character
        /// just after the valid data (if <paramref name="endptr"/> is not a null pointer); otherwise <paramref name="rop"/> is set to zero (for consistency with
        /// <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>) and the value of <paramref name="nptr"/> is stored in the location referenced
        /// by <paramref name="endptr"/> (if <paramref name="endptr"/> is not a null pointer).
        /// The usual <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is returned. 
        /// </para>
        /// <para>
        /// Parsing follows the standard C <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a> function with some extensions.
        /// After optional leading whitespace, one has a subject sequence consisting of an optional sign (+ or -), and either numeric data or special data.
        /// The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-whitespace character, that is of the expected form. 
        /// </para>
        /// <para>
        /// The form of numeric data is a non-empty sequence of significand digits with an optional decimal point, and an optional exponent consisting
        /// of an exponent prefix followed by an optional sign and a non-empty sequence of decimal digits.
        /// A significand digit is either a decimal digit or a Latin letter (62 possible characters), with A = 10, B = 11, …, Z = 35; case is ignored in
        /// bases less or equal to 36, in bases larger than 36, a = 36, b = 37, …, z = 61.
        /// The value of a significand digit must be strictly less than the base.
        /// The decimal point can be either the one defined by the current locale or the period (the first one is accepted for consistency with the
        /// C standard and the practice, the second one is accepted to allow the programmer to provide MPFR numbers from strings in a way that does
        /// not depend on the current locale).
        /// The exponent prefix can be e or E for bases up to 10, or @ in any base; it indicates a multiplication by a power of the base.
        /// In bases 2 and 16, the exponent prefix can also be p or P, in which case the exponent, called binary exponent, indicates a multiplication
        /// by a power of 2 instead of the base (there is a difference only for base 16); in base 16 for example 1p2 represents 4 whereas 1@2 represents 256.
        /// The value of an exponent is always written in base 10. 
        /// </para>
        /// <para>
        /// If the argument base is 0, then the base is automatically detected as follows.
        /// If the significand starts with 0b or 0B, base 2 is assumed.
        /// If the significand starts with 0x or 0X, base 16 is assumed.
        /// Otherwise base 10 is assumed. 
        /// </para>
        /// <para>
        /// Note: The exponent (if present) must contain at least a digit.
        /// Otherwise the possible exponent prefix and sign are not part of the number (which ends with the significand).
        /// Similarly, if 0b, 0B, 0x or 0X is not followed by a binary/hexadecimal digit, then the subject sequence stops at the character 0, thus 0 is read.
        /// </para>
        /// <para>
        /// Special data (for infinities and NaN) can be @inf@ or @nan@(n-char-sequence-opt), and if base &#8804; 16, it can also be infinity, inf,
        /// nan or nan(n-char-sequence-opt), all case insensitive.
        /// A n-char-sequence-opt is a possibly empty string containing only digits, Latin letters and the underscore (0, 1, 2, …, 9, a, b, …, z, A, B, …, Z, _).
        /// Note: one has an optional sign for all data, even NaN. 
        /// For example, -@nAn@(This_Is_Not_17) is a valid representation for NaN in base 17. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Parse first float in string.
        /// char_ptr nptr = new char_ptr("10.0  20.0");
        /// char_ptr endptr = new char_ptr();
        /// Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop, nptr, ref endptr, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// Assert.IsTrue(endptr.ToString() == "  20.0");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.free(nptr);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Parse first float in string.
        /// Dim nptr As char_ptr = New char_ptr("10.0  20.0")
        /// Dim endptr As char_ptr = New char_ptr()
        /// Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop,nptr,ref endptr,10,mpfr_rnd_t.MPFR_RNDN)  =  0)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// Assert.IsTrue(endptr.ToString() = "  20.0")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.free(nptr)
        /// </code> 
        /// </example>
        public static int mpfr_strtofr(mpfr_t rop, /*const*/ char_ptr /*char **/ nptr, ref char_ptr /*char ***/ endptr, int @base, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.mpfr_strtofr(rop.ToIntPtr(), nptr.ToIntPtr(), ref endptr.Pointer, @base, (int)rnd);
        }

        /// <summary>
        /// Read a floating-point number from a string <paramref name="nptr"/> in base <paramref name="base"/>, rounded in the direction <paramref name="rnd"/>.
        /// </summary>
        /// <param name="rop">The result floating-point number.</param>
        /// <param name="nptr">String containing a floating-point number.</param>
        /// <param name="endptr">On return, points the first character after floating-point number in <paramref name="nptr"/>.</param>
        /// <param name="base">The base.</param>
        /// <param name="rnd">The rounding direction.</param>
        /// <returns>Return zero, a positive, or a negative value if <paramref name="rop"/> is respectively equal to, greater than, or lower than the exact result. See <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">GNU MPFR - Rounding Modes</a> for details.</returns>
        /// <remarks>
        /// <para>
        /// The <paramref name="base"/> must be either 0 (to detect the base, as described below) or a number from 2 to 62 (otherwise the behavior is undefined).
        /// If <paramref name="nptr"/> starts with valid data, the result is stored in <paramref name="rop"/> and <paramref name="endptr"/> points to the character
        /// just after the valid data (if <paramref name="endptr"/> is not a null pointer); otherwise <paramref name="rop"/> is set to zero (for consistency with
        /// <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a>) and the value of <paramref name="nptr"/> is stored in the location referenced
        /// by <paramref name="endptr"/> (if <paramref name="endptr"/> is not a null pointer).
        /// The usual <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Rounding-Modes">ternary value</a> is returned. 
        /// </para>
        /// <para>
        /// Parsing follows the standard C <a href="http://en.cppreference.com/w/c/string/byte/strtof">strtod</a> function with some extensions.
        /// After optional leading whitespace, one has a subject sequence consisting of an optional sign (+ or -), and either numeric data or special data.
        /// The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-whitespace character, that is of the expected form. 
        /// </para>
        /// <para>
        /// The form of numeric data is a non-empty sequence of significand digits with an optional decimal point, and an optional exponent consisting
        /// of an exponent prefix followed by an optional sign and a non-empty sequence of decimal digits.
        /// A significand digit is either a decimal digit or a Latin letter (62 possible characters), with A = 10, B = 11, …, Z = 35; case is ignored in
        /// bases less or equal to 36, in bases larger than 36, a = 36, b = 37, …, z = 61.
        /// The value of a significand digit must be strictly less than the base.
        /// The decimal point can be either the one defined by the current locale or the period (the first one is accepted for consistency with the
        /// C standard and the practice, the second one is accepted to allow the programmer to provide MPFR numbers from strings in a way that does
        /// not depend on the current locale).
        /// The exponent prefix can be e or E for bases up to 10, or @ in any base; it indicates a multiplication by a power of the base.
        /// In bases 2 and 16, the exponent prefix can also be p or P, in which case the exponent, called binary exponent, indicates a multiplication
        /// by a power of 2 instead of the base (there is a difference only for base 16); in base 16 for example 1p2 represents 4 whereas 1@2 represents 256.
        /// The value of an exponent is always written in base 10. 
        /// </para>
        /// <para>
        /// If the argument base is 0, then the base is automatically detected as follows.
        /// If the significand starts with 0b or 0B, base 2 is assumed.
        /// If the significand starts with 0x or 0X, base 16 is assumed.
        /// Otherwise base 10 is assumed. 
        /// </para>
        /// <para>
        /// Note: The exponent (if present) must contain at least a digit.
        /// Otherwise the possible exponent prefix and sign are not part of the number (which ends with the significand).
        /// Similarly, if 0b, 0B, 0x or 0X is not followed by a binary/hexadecimal digit, then the subject sequence stops at the character 0, thus 0 is read.
        /// </para>
        /// <para>
        /// Special data (for infinities and NaN) can be @inf@ or @nan@(n-char-sequence-opt), and if base &#8804; 16, it can also be infinity, inf,
        /// nan or nan(n-char-sequence-opt), all case insensitive.
        /// A n-char-sequence-opt is a possibly empty string containing only digits, Latin letters and the underscore (0, 1, 2, …, 9, a, b, …, z, A, B, …, Z, _).
        /// Note: one has an optional sign for all data, even NaN. 
        /// For example, -@nAn@(This_Is_Not_17) is a valid representation for NaN in base 17. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_set">mpfr_set</seealso>
        /// <seealso cref="mpfr_set_ui">mpfr_set_ui</seealso>
        /// <seealso cref="mpfr_set_si">mpfr_set_si</seealso>
        /// <seealso cref="mpfr_set_uj">mpfr_set_uj</seealso>
        /// <seealso cref="mpfr_set_sj">mpfr_set_sj</seealso>
        /// <seealso cref="mpfr_set_flt">mpfr_set_flt</seealso>
        /// <seealso cref="mpfr_set_d">mpfr_set_d</seealso>
        /// <seealso cref="mpfr_set_z">mpfr_set_z</seealso>
        /// <seealso cref="mpfr_set_q">mpfr_set_q</seealso>
        /// <seealso cref="mpfr_set_f">mpfr_set_f</seealso>
        /// <seealso cref="mpfr_set_ui_2exp">mpfr_set_ui_2exp</seealso>
        /// <seealso cref="mpfr_set_si_2exp">mpfr_set_si_2exp</seealso>
        /// <seealso cref="mpfr_set_uj_2exp">mpfr_set_uj_2exp</seealso>
        /// <seealso cref="mpfr_set_sj_2exp">mpfr_set_sj_2exp</seealso>
        /// <seealso cref="mpfr_set_z_2exp">mpfr_set_z_2exp</seealso>
        /// <seealso cref="mpfr_set_nan">mpfr_set_nan</seealso>
        /// <seealso cref="mpfr_set_inf">mpfr_set_inf</seealso>
        /// <seealso cref="mpfr_set_zero">mpfr_set_zero</seealso>
        /// <seealso cref="mpfr_swap">mpfr_swap</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Assignment_Functions">Assignment Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Assignment-Functions">GNU MPFR - Assignment Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number rop.
        /// mpfr_t rop = new mpfr_t();
        /// mpfr_lib.mpfr_init2(rop, 64U);
        /// 
        /// // Parse first float in string.
        /// char_ptr nptr = new char_ptr("10.0  20.0");
        /// ptr&lt;char_ptr&gt; endptr = new ptr&lt;char_ptr&gt;();
        /// Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop, nptr, endptr, 10, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) == 10.0);
        /// Assert.IsTrue(endptr.Value.ToString() == "  20.0");
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop);
        /// gmp_lib.free(nptr);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number rop.
        /// Dim rop As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_init2(rop, 64U)
        /// 
        /// ' Parse first float in string.
        /// Dim nptr As char_ptr = New char_ptr("10.0  20.0")
        /// Dim endptr As ptr(Of char_ptr) =  New ptr(Of char_ptr)()
        /// Assert.IsTrue(mpfr_lib.mpfr_strtofr(rop, nptr, endptr, 10, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the value of rop is 10.
        /// Assert.IsTrue(mpfr_lib.mpfr_get_d(rop, mpfr_rnd_t.MPFR_RNDN) = 10.0)
        /// Assert.IsTrue(endptr.Value.ToString() = "  20.0")
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpfr_clear(rop)
        /// gmp_lib.free(nptr)
        /// </code> 
        /// </example>
        public static int mpfr_strtofr(mpfr_t rop, /*const*/ char_ptr /*char **/ nptr, ptr<char_ptr> /*char ***/ endptr, int @base, mpfr_rnd_t rnd)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            IntPtr tmp = IntPtr.Zero;
            if (endptr == null)
            return SafeNativeMethods.mpfr_strtofr(rop.ToIntPtr(), nptr.ToIntPtr(), ref tmp, @base, (int)rnd);
            else
                return SafeNativeMethods.mpfr_strtofr(rop.ToIntPtr(), nptr.ToIntPtr(), ref endptr.Value.Pointer, @base, (int)rnd);
        }

        /// <summary>
        /// Free the space occupied by <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <remarks>
        /// <para>
        /// The behavior of this function for any <see cref="mpfr_t">mpfr_t</see> not initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpfr_custom_clear(mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            x.Clear();
        }

        /// <summary>
        /// Return the needed size in bytes to store the significand of a floating-point number of precision <paramref name="prec"/>. 
        /// </summary>
        /// <param name="prec">The precision in bits.</param>
        /// <returns>Return the needed size in bytes to store the significand of a floating-point number of precision <paramref name="prec"/>.</returns>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// size_t size = mpfr_lib.mpfr_custom_get_size(64U);
        /// void_ptr significand = gmp_lib.allocate(size);
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
        /// 
        /// // Set x = 16.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert exponent of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) == 5);
        /// 
        /// // Assert significand of x.
        /// Byte[] result = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0x80 };
        /// byte[] sp = new byte[8];
        /// Marshal.Copy(significand.ToIntPtr(), sp, 0, 8);
        /// Assert.IsTrue(sp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x);
        /// gmp_lib.free(significand);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
        /// Dim significand As void_ptr = gmp_lib.allocate(size)
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
        /// 
        /// ' Set x = 16.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert exponent of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) = 5)
        /// 
        /// ' Assert significand of x.
        /// Dim result() As Byte = New Byte() { 0, 0, 0, 0, 0, 0, 0, 0x80}
        /// 
        /// Dim sp() As Byte = New Byte(8) { }
        /// Marshal.Copy(significand.ToIntPtr(), sp, 0, 8)
        /// Assert.IsTrue(sp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x)
        /// gmp_lib.free(significand)
        /// </code> 
        /// </example>
        public static size_t mpfr_custom_get_size(uint /*mpfr_prec_t*/ prec)
        {
            if (IntPtr.Size == 4)
                return SafeNativeMethods.mpfr_custom_get_size_x86(prec);
            else
                return SafeNativeMethods.mpfr_custom_get_size_x64(prec);
        }

        /// <summary>
        /// Initialize a significand of precision <paramref name="prec"/>.
        /// </summary>
        /// <param name="significand">Pointer to significand.</param>
        /// <param name="prec">The precision in bits.</param>
        /// <remarks>
        /// <para>
        /// Initialize a significand of precision <paramref name="prec"/>, where significand must be an area of
        /// <see cref="mpfr_custom_get_size">mpfr_custom_get_size</see>(<paramref name="prec"/>) bytes at least and be suitably aligned
        /// for an array of mp_limb_t (GMP type, see <a href="http://www.mpfr.org/mpfr-current/mpfr.html#Internals">GNU MPFR - Internals</a>). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpfr_custom_init(void_ptr /*void **/ significand, uint /*mpfr_prec_t*/ prec)
        {
            SafeNativeMethods.mpfr_custom_init(significand.ToIntPtr(), prec);
        }

        /// <summary>
        /// Return a pointer to the significand used by a <see cref="mpfr_t">mpfr_t</see> initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <returns>Return a pointer to the significand used by a <see cref="mpfr_t">mpfr_t</see> initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>.</returns>
        /// <remarks>
        /// <para>
        /// The behavior of this function for any <see cref="mpfr_t">mpfr_t</see> not initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// size_t size = mpfr_lib.mpfr_custom_get_size(64U);
        /// void_ptr significand = gmp_lib.allocate(size);
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
        /// 
        /// // Set x = x + 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert significand of x.
        /// Byte[] result = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0x80 };
        /// byte[] sp = new byte[8];
        /// Marshal.Copy(significand.ToIntPtr(), sp, 0, 8);
        /// Assert.IsTrue(sp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x);
        /// gmp_lib.free(significand);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
        /// Dim significand As void_ptr = gmp_lib.allocate(size)
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
        /// 
        /// ' Set x = x + 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert significand of x.
        /// Dim result() As Byte = New Byte() { 0, 0, 0, 0, 0, 0, 0, 0x80}
        /// 
        /// Dim sp() As Byte = New Byte(8) { }
        /// Marshal.Copy(significand.ToIntPtr(), sp, 0, 8)
        /// Assert.IsTrue(sp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x)
        /// gmp_lib.free(significand)
        /// </code> 
        /// </example>
        public static void_ptr /*void **/ mpfr_custom_get_significand(/*const*/ mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            return new void_ptr(SafeNativeMethods.mpfr_custom_get_significand(x.ToIntPtr()));
        }

        /// <summary>
        /// Return the exponent of <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <returns>Return the exponent of <paramref name="x"/>.</returns>
        /// <remarks>
        /// <para>
        /// Return the exponent of <paramref name="x"/>, assuming that <paramref name="x"/> is a non-zero ordinary number.
        /// The return value for NaN, Infinity or zero is unspecified but does not produce any trap.
        /// The behavior of this function for any <see cref="mpfr_t">mpfr_t</see> not initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// size_t size = mpfr_lib.mpfr_custom_get_size(64U);
        /// void_ptr significand = gmp_lib.allocate(size);
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
        /// 
        /// // Set x = x + 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert that the exponent of x is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) == 1);
        /// 
        /// // Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x);
        /// gmp_lib.free(significand);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
        /// Dim significand As void_ptr = gmp_lib.allocate(size)
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
        /// 
        /// ' Set x = x + 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert that the exponent of x is 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) = 1)
        /// 
        /// ' Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x)
        /// gmp_lib.free(significand)
        /// </code> 
        /// </example>
        public static mpfr_exp_t mpfr_custom_get_exp(/*const*/ mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            return SafeNativeMethods.mpfr_custom_get_exp(x.ToIntPtr());
        }

        /// <summary>
        /// Inform MPFR that the significand of <paramref name="x"/> has moved due to a garbage collect and update its new position to <paramref name="new_position"/>.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="new_position">Pointer to the new address of the significand of <paramref name="x"/>.</param>
        /// <remarks>
        /// <para>
        /// However the application has to move the significand and the <see cref="mpfr_t">mpfr_t</see> itself.
        /// The behavior of this function for any <see cref="mpfr_t">mpfr_t</see> not initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// size_t size = mpfr_lib.mpfr_custom_get_size(64U);
        /// void_ptr significand = gmp_lib.allocate(size);
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
        /// 
        /// // Set x = 16.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert the value of x.
        /// Assert.IsTrue(x.ToString() == "0.160000000000000000000e2");
        /// 
        /// // Allocate new significand.
        /// void_ptr significand2 = gmp_lib.allocate(8);
        /// Marshal.Copy(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0 }, 0, significand2.ToIntPtr(), 8);
        /// 
        /// // Assign new significanf to x.
        /// mpfr_lib.mpfr_custom_move(x, significand2);
        /// 
        /// // Assert the value of x.
        /// Assert.IsTrue(x.ToString() == "0.240000000000000000000e2");
        /// 
        /// // Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x);
        /// gmp_lib.free(significand);
        /// gmp_lib.free(significand2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
        /// Dim significand As void_ptr = gmp_lib.allocate(size)
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
        /// 
        /// ' Set x = 16.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert the value of x.
        /// Assert.IsTrue(x.ToString() = "0.160000000000000000000e2")
        /// 
        /// ' Allocate new significand.
        /// Dim significand2 As void_ptr = gmp_lib.allocate(8)
        /// Dim Byte() As Marshal.Copy(New { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0 }, 0, significand2.ToIntPtr(), 8)
        /// 
        /// ' Assign new significanf to x.
        /// mpfr_lib.mpfr_custom_move(x, significand2)
        /// 
        /// ' Assert the value of x.
        /// Assert.IsTrue(x.ToString() = "0.240000000000000000000e2")
        /// 
        /// ' Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x)
        /// gmp_lib.free(significand)
        /// gmp_lib.free(significand2)
        /// </code> 
        /// </example>
        public static void mpfr_custom_move(mpfr_t x, void_ptr /*void **/ new_position)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.mpfr_custom_move(x.ToIntPtr(), new_position.ToIntPtr());
        }

        /// <summary>
        /// Perform a dummy initialization of a <see cref="mpfr_t">mpfr_t</see>.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <param name="kind">The kind of number to initialize.</param>
        /// <param name="exp">The exponent.</param>
        /// <param name="prec">The precision in bits.</param>
        /// <param name="significand">Pointer to the significand.</param>
        /// <remarks>
        /// <para>
        /// Perform a dummy initialization of a <see cref="mpfr_t">mpfr_t</see> and set it to:
        /// </para>
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// if ABS(<paramref name="kind"/>) == <see cref="mpfr_kind_t.MPFR_NAN_KIND">mpfr_kind_t.MPFR_NAN_KIND</see>, <paramref name="x"/> is set to NaN;
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// if ABS(<paramref name="kind"/>) == <see cref="mpfr_kind_t.MPFR_INF_KIND">mpfr_kind_t.MPFR_INF_KIND</see>, <paramref name="x"/> is set to the infinity of sign sign(<paramref name="kind"/>); 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// if ABS(<paramref name="kind"/>) == <see cref="mpfr_kind_t.MPFR_ZERO_KIND">mpfr_kind_t.MPFR_ZERO_KIND</see>, <paramref name="x"/> is set to the zero of sign sign(<paramref name="kind"/>); 
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// if ABS(<paramref name="kind"/>) == <see cref="mpfr_kind_t.MPFR_REGULAR_KIND">mpfr_kind_t.MPFR_REGULAR_KIND</see>, <paramref name="x"/> is set to a regular number: 
        /// <paramref name="x"/> = sign(<paramref name="kind"/>) * <paramref name="significand"/> * 2^<paramref name="exp"/>. 
        /// </description>
        /// </item>
        /// </list>
        /// <para>
        /// In all cases, it uses significand directly for further computing involving <paramref name="x"/>.
        /// It will not allocate anything.
        /// A floating-point number initialized with this function cannot be resized using <see cref="mpfr_set_prec">mpfr_set_prec</see>
        /// or <see cref="mpfr_prec_round">mpfr_prec_round</see>, or cleared using <see cref="mpfr_clear">mpfr_clear</see>!
        /// The <paramref name="significand"/> must have been initialized with <see cref="mpfr_custom_init">mpfr_custom_init</see> using the same precision <paramref name="prec"/>. 
        /// </para>
        /// <para>
        /// The <see cref="mpfr_custom_clear">mpfr_custom_clear</see> function must be called to free the memory occupied by <paramref name="x"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_get_kind">mpfr_custom_get_kind</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// size_t size = mpfr_lib.mpfr_custom_get_size(64U);
        /// void_ptr significand = gmp_lib.allocate(size);
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
        /// 
        /// // Set x = 16.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert exponent of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) == 5);
        /// 
        /// // Assert significand of x.
        /// Byte[] result = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0x80 };
        /// Byte[] sp = new byte[8];
        /// Marshal.Copy(significand.ToIntPtr(), sp, 0, 8);
        /// Assert.IsTrue(sp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x);
        /// gmp_lib.free(significand);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
        /// Dim significand As void_ptr = gmp_lib.allocate(size)
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
        /// 
        /// ' Set x = 16.
        /// Assert.IsTrue(mpfr_lib.mpfr_set_si(x, 16, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert exponent of x.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_exp(x) = 5)
        /// 
        /// ' Assert significand of x.
        /// Dim result() As Byte = New Byte() { 0, 0, 0, 0, 0, 0, 0, 0x80}
        /// 
        /// Dim sp() As Byte = New Byte(8) { }
        /// Marshal.Copy(significand.ToIntPtr(), sp, 0, 8)
        /// Assert.IsTrue(sp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x)
        /// gmp_lib.free(significand)
        /// </code> 
        /// </example>
        public static void mpfr_custom_init_set(mpfr_t x, /*int*/ mpfr_kind_t kind, mpfr_exp_t exp, uint /*mpfr_prec_t*/ prec, void_ptr /*void **/ significand)
        {
            if (x == null) throw new ArgumentNullException("x");
            x.Initializing();
            SafeNativeMethods.mpfr_custom_init_set(x.ToIntPtr(), (int)kind, exp, prec, significand.ToIntPtr());
            x.Initialized();
        }

        /// <summary>
        /// Return the current kind of a <see cref="mpfr_t">mpfr_t</see> as created by <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>.
        /// </summary>
        /// <param name="x">The operand floating-point number.</param>
        /// <returns>Return the current kind of a <see cref="mpfr_t">mpfr_t</see> as created by <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see>.</returns>
        /// <remarks>
        /// <para>
        /// The behavior of this function for any <see cref="mpfr_t">mpfr_t</see> not initialized with <see cref="mpfr_custom_init_set">mpfr_custom_init_set</see> is undefined. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_custom_get_size">mpfr_custom_get_size</seealso>
        /// <seealso cref="mpfr_custom_init">mpfr_custom_init</seealso>
        /// <seealso cref="mpfr_custom_init_set">mpfr_custom_init_set</seealso>
        /// <seealso cref="mpfr_custom_get_significand">mpfr_custom_get_significand</seealso>
        /// <seealso cref="mpfr_custom_get_exp">mpfr_custom_get_exp</seealso>
        /// <seealso cref="mpfr_custom_move">mpfr_custom_move</seealso>
        /// <seealso cref="mpfr_custom_clear">mpfr_custom_clear</seealso>
        /// <seealso cref="mpfr_lib"><a href="/html/6146e71f-a352-2e48-f234-6d79ad0f8c3c.htm#Custom_Interface">Custom Interface</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="http://www.mpfr.org/mpfr-current/mpfr.html#Custom-Interface">GNU MPFR - Custom Interface</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// size_t size = mpfr_lib.mpfr_custom_get_size(64U);
        /// void_ptr significand = gmp_lib.allocate(size);
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), (int)size);
        /// mpfr_t x = new mpfr_t();
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand);
        /// 
        /// // Set x = x + 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) == 0);
        /// 
        /// // Assert x is a regular floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_kind(x) == mpfr_kind_t.MPFR_REGULAR_KIND);
        /// 
        /// // Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x);
        /// gmp_lib.free(significand);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Initialize a custom, 64-bit significand floating-point number, and set it to 0.
        /// Dim size As size_t = mpfr_lib.mpfr_custom_get_size(64U)
        /// Dim significand As void_ptr = gmp_lib.allocate(size)
        /// gmp_lib.ZeroMemory(significand.ToIntPtr(), CType(size, Integer))
        /// Dim x As mpfr_t = New mpfr_t()
        /// mpfr_lib.mpfr_custom_init_set(x, mpfr_kind_t.MPFR_ZERO_KIND, 0, 64U, significand)
        /// 
        /// ' Set x = x + 1.
        /// Assert.IsTrue(mpfr_lib.mpfr_add_si(x, x, 1, mpfr_rnd_t.MPFR_RNDN) = 0)
        /// 
        /// ' Assert x is a regular floating-point number.
        /// Assert.IsTrue(mpfr_lib.mpfr_custom_get_kind(x) = mpfr_kind_t.MPFR_REGULAR_KIND)
        /// 
        /// ' Release unmanaged memory allocated for x and significand.
        /// mpfr_lib.mpfr_custom_clear(x)
        /// gmp_lib.free(significand)
        /// </code> 
        /// </example>
        public static mpfr_kind_t /*int*/ mpfr_custom_get_kind(/*const*/ mpfr_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            return (mpfr_kind_t)SafeNativeMethods.mpfr_custom_get_kind(x.ToIntPtr());
        }

        [SuppressUnmanagedCodeSecurity]
        private static class SafeNativeMethods
        {

            #region "Win32 functions."

            [DllImport("kernel32", CharSet = CharSet.Unicode)]
            public static extern IntPtr LoadLibrary(string lpFileName);

            [DllImport("kernel32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool FreeLibrary(IntPtr hModule);

            [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool SetDllDirectory(string directory);

            #endregion

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_out_str")]
            public static extern uint /*size_t*/ __gmpfr_out_str_x86(IntPtr /*FILE **/ stream, int @base, uint /*size_t*/ n, IntPtr /*mpfr_srcptr*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_out_str")]
            public static extern ulong /*size_t*/ __gmpfr_out_str_x64(IntPtr /*FILE **/ stream, int @base, ulong /*size_t*/ n, IntPtr /*mpfr_srcptr*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_inp_str")]
            public static extern uint /*size_t*/ __gmpfr_inp_str_x86(IntPtr /*mpfr_ptr*/ rop, IntPtr /*FILE **/ stream, int @base, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_inp_str")]
            public static extern ulong /*size_t*/ __gmpfr_inp_str_x64(IntPtr /*mpfr_ptr*/ rop, IntPtr /*FILE **/ stream, int @base, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __gmpfr_fpif_export(IntPtr /*FILE **/ stream, IntPtr /*mpfr_srcptr*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __gmpfr_fpif_import(IntPtr /*mpfr_ptr*/ op, IntPtr /*FILE **/ stream);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern long /*intmax_t*/ __gmpfr_mpfr_get_sj(IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern ulong /*uintmax_t*/ __gmpfr_mpfr_get_uj(IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __gmpfr_set_sj(IntPtr /*mpfr_t*/ rop, long /*intmax_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __gmpfr_set_uj(IntPtr /*mpfr_t*/ rop, ulong /*uintmax_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __gmpfr_set_sj_2exp(IntPtr /*mpfr_t*/ rop, long /*intmax_t*/ op, long /*intmax_t*/ e, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __gmpfr_set_uj_2exp(IntPtr /*mpfr_t*/ rop, ulong /*uintmax_t*/ op, ulong /*uintmax_t*/ e, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*const*/ IntPtr /*char **/ mpfr_get_version(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*const*/ IntPtr /*char **/ mpfr_get_patches(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_buildopt_tls_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_buildopt_float128_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_buildopt_decimal_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_buildopt_gmpinternals_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_buildopt_sharedcache_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*const*/ IntPtr /*char **/ mpfr_buildopt_tune_case(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_emin(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_emin(int /*mpfr_exp_t*/ exp);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_emin_min(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_emin_max(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_emax(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_emax(int /*mpfr_exp_t*/ exp);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_emax_min(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_emax_max(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_default_rounding_mode(int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_rnd_t*/ mpfr_get_default_rounding_mode(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*const*/ IntPtr /*char **/ mpfr_print_rnd_mode(int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_flags(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_underflow(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_overflow(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_divby0(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_nanflag(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_inexflag(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear_erangeflag(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_underflow(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_overflow(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_divby0(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_nanflag(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_inexflag(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_erangeflag(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_underflow_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_overflow_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_divby0_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_nanflag_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_inexflag_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_erangeflag_p(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_flags_clear(/*mpfr_flags_t*/ uint mask);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_flags_set(/*mpfr_flags_t*/ uint mask);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*mpfr_flags_t*/ uint mpfr_flags_test(/*mpfr_flags_t*/ uint mask);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*mpfr_flags_t*/ uint mpfr_flags_save(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_flags_restore(/*mpfr_flags_t*/ uint flags, /*mpfr_flags_t*/ uint mask);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_check_range(IntPtr /*mpfr_t*/ x, int t, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_init2(IntPtr /*mpfr_t*/ x, uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_init(IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_clear(IntPtr /*mpfr_t*/ x);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void mpfr_inits2(uint /*mpfr_prec_t*/ prec, IntPtr /*mpfr_t*/ x /*...*/);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void mpfr_inits(IntPtr /*mpfr_t*/ x, IntPtr args /*...*/);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void mpfr_clears(IntPtr /*mpfr_t*/ x, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_prec_round(IntPtr /*mpfr_t*/ x, uint /*mpfr_prec_t*/ prec, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_can_round(/*const*/ IntPtr /*mpfr_t*/ b, int /*mpfr_exp_t*/ err, int /*mpfr_rnd_t*/ rnd1, int /*mpfr_rnd_t*/ rnd2, uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mpfr_prec_t*/ mpfr_min_prec(/*const*/ IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_exp(/*const*/ IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_exp(IntPtr /*mpfr_t*/ x, int /*mpfr_exp_t*/ e);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mpfr_prec_t*/ mpfr_get_prec(/*const*/ IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_prec(IntPtr /*mpfr_t*/ x, uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_prec_raw(IntPtr /*mpfr_t*/ x, uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_default_prec(uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mpfr_prec_t*/ mpfr_get_default_prec(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_d(IntPtr /*mpfr_t*/ rop, double op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_flt(IntPtr /*mpfr_t*/ rop, float op, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern int mpfr_set_decimal64(IntPtr /*mpfr_t*/, _Decimal64, int /*mpfr_rnd_t*/);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern int mpfr_set_ld(IntPtr /*mpfr_t*/, long double, int /*mpfr_rnd_t*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_z(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_z_2exp(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op, int /*mpfr_exp_t*/ e, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_nan(IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_inf(IntPtr /*mpfr_t*/ x, int sign);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_set_zero(IntPtr /*mpfr_t*/ x, int sign);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_f(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_get_f(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_si(IntPtr /*mpfr_t*/ rop, int /*long*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_ui(IntPtr /*mpfr_t*/ rop, uint /*unsigned long*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_si_2exp(IntPtr /*mpfr_t*/ rop, int /*long*/ op, int /*mpfr_exp_t*/ e, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_ui_2exp(IntPtr /*mpfr_t*/ rop, uint /*unsigned long*/ op, int /*mpfr_exp_t*/ e, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_q(IntPtr /*mpfr_t*/ rop, IntPtr /*mpq_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set_str(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*char **/ s, int @base, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_init_set_str(IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*char **/ s, int @base, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern int mpfr_set4(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd, int s);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_abs(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_set(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_neg(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_signbit(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_setsign(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int s, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_copysign(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_get_z_2exp(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern float mpfr_get_flt(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double mpfr_get_d(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern _Decimal64 mpfr_get_decimal64(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern long double mpfr_get_ld(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern double mpfr_get_d1(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double mpfr_get_d_2exp(ref int /*long **/ exp, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern long double mpfr_get_ld_2exp(ptr<int> /*long **/ exp, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_frexp(ref int /*mpfr_exp_t **/ exp, IntPtr /*mpfr_t*/ y, /*const*/ IntPtr /*mpfr_t*/ x, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*long*/ mpfr_get_si(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long*/ mpfr_get_ui(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mpfr_get_str")]
            public static extern IntPtr /*char **/ mpfr_get_str_x86(IntPtr /*char **/ str, ref int /*mpfr_exp_t **/ expptr, int b, uint /*size_t*/ n, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mpfr_get_str")]
            public static extern IntPtr /*char **/ mpfr_get_str_x64(IntPtr /*char **/ str, ref int /*mpfr_exp_t **/ expptr, int b, ulong /*size_t*/ n, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_get_z(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_get_q(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_free_str(IntPtr /*char **/ str);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_urandom(IntPtr /*mpfr_t*/ rop, IntPtr /*gmp_randstate_t*/ state, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_nrandom(IntPtr /*mpfr_t*/ rop, IntPtr /*gmp_randstate_t*/ state, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_grandom(IntPtr /*mpfr_t*/ rop1, IntPtr /*mpfr_t*/ rop2, IntPtr /*gmp_randstate_t*/ state, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_erandom(IntPtr /*mpfr_t*/ rop, IntPtr /*gmp_randstate_t*/ state, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_urandomb(IntPtr /*mpfr_t*/ rop, IntPtr /*gmp_randstate_t*/ state);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_nextabove(IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_nextbelow(IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_nexttoward(IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*mpfr_t*/ y);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_vasprintf")]
            public static extern int mpfr_vasprintf(ref IntPtr /*char ***/ str, /*const*/ IntPtr /*char **/ template, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_vfprintf")]
            public static extern int mpfr_vfprintf(IntPtr /*FILE */stream, /*const*/ IntPtr /*char **/ template, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_vprintf")]
            public static extern int mpfr_vprintf(/*const*/ IntPtr /*char **/ template, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_vsnprintf")]
            public static extern int mpfr_vsnprintf_x86(IntPtr /*char **/ buf, uint /*size_t*/ n, /*const*/ IntPtr /*char **/ template, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_vsnprintf")]
            public static extern int mpfr_vsnprintf_x64(IntPtr /*char **/ buf, ulong /*size_t*/ n, /*const*/ IntPtr /*char **/ template, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__gmpfr_vsprintf")]
            public static extern int mpfr_vsprintf(IntPtr /*char **/ buf, /*const*/ IntPtr /*char **/ template, IntPtr args /*...*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_pow(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_pow_si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_pow_ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_ui_pow_ui(IntPtr /*mpfr_t*/ rop, uint /*unsigned long int*/ op1, uint /*unsigned long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_ui_pow(IntPtr /*mpfr_t*/ rop, uint /*unsigned long int*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_pow_z(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sqrt(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sqrt_ui(IntPtr /*mpfr_t*/ rop, uint /*unsigned long*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rec_sqrt(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_add(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sub(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_add_ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sub_ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_ui_sub(IntPtr /*mpfr_t*/ rop, uint /*unsigned long*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_ui_div(IntPtr /*mpfr_t*/ rop, uint /*unsigned long*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_add_si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sub_si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_si_sub(IntPtr /*mpfr_t*/ rop, int /*long int*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long int*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_si_div(IntPtr /*mpfr_t*/ rop, int /*long int*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_add_d(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, double op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sub_d(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, double op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_d_sub(IntPtr /*mpfr_t*/ rop, double op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_d(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, double op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_d(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, double op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_d_div(IntPtr /*mpfr_t*/ rop, double op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sqr(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_const_pi(IntPtr /*mpfr_t*/ rop, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_const_log2(IntPtr /*mpfr_t*/ rop, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_const_euler(IntPtr /*mpfr_t*/ rop, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_const_catalan(IntPtr /*mpfr_t*/ rop, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_agm(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_log(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_log_ui(IntPtr /*mpfr_t*/ rop, /*const*/ uint /*unsigned long*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_log2(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_log10(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_log1p(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_exp(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_exp2(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_exp10(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_expm1(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_eint(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_li2(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern int mpfr_cmp3(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int s);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_d(/*const*/ IntPtr /*mpfr_t*/ op1, double op2);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern int mpfr_cmp_ld(/*const*/ IntPtr /*mpfr_t*/, long double);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmpabs(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_ui(/*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_si(/*const*/ IntPtr /*mpfr_t*/ op1, int /*long*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_ui_2exp(/*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_exp_t*/ e);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_si_2exp(/*const*/ IntPtr /*mpfr_t*/ op1, int /*long*/ op2, int /*mpfr_exp_t*/ e);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_reldiff(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_eq(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, uint /*unsigned long*/ op3);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sgn(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_2exp(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_2exp(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_2ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_2ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, uint /*unsigned long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_2si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_2si(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, int /*long*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rint(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_round(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_roundeven(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_trunc(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_ceil(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_floor(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rint_round(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rint_roundeven(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rint_trunc(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rint_ceil(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rint_floor(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_frac(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_modf(IntPtr /*mpfr_t*/ iop, IntPtr /*mpfr_t*/ fop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_remquo(IntPtr /*mpfr_t*/ r, ref int /*long **/ q, /*const*/ IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*mpfr_t*/ y, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_remainder(IntPtr /*mpfr_t*/ r, /*const*/ IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*mpfr_t*/ y, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fmod(IntPtr /*mpfr_t*/ r, /*const*/ IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*mpfr_t*/ y, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fmodquo(IntPtr /*mpfr_t*/ r, ref int /*long **/ q, /*const*/ IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*mpfr_t*/ y, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_ulong_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_slong_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_uint_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_sint_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_ushort_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_sshort_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_uintmax_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fits_intmax_p(/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void mpfr_extract(IntPtr /*mpz_t*/ y, /*const*/ IntPtr /*mpfr_t*/ p, uint /*unsigned int*/ i);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_swap(IntPtr /*mpfr_t*/ x, IntPtr /*mpfr_t*/ y);

            //[DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void mpfr_dump(/*const*/ IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_nan_p(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_inf_p(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_number_p(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_integer_p(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_zero_p(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_regular_p(/*const*/ IntPtr /*mpfr_t*/ op);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_greater_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_greaterequal_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_less_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_lessequal_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_lessgreater_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_equal_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_unordered_p(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_atanh(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_acosh(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_asinh(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cosh(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sinh(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_tanh(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sinh_cosh(IntPtr /*mpfr_t*/ sop, IntPtr /*mpfr_t*/ cop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sech(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_csch(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_coth(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_acos(IntPtr /*mpfr_t*/ rop,/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_asin(IntPtr /*mpfr_t*/ rop,/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_atan(IntPtr /*mpfr_t*/ rop,/*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sin(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sin_cos(IntPtr /*mpfr_t*/ sop, IntPtr /*mpfr_t*/ cop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cos(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_tan(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_atan2(IntPtr /*mpfr_t*/ rop,/*const*/ IntPtr /*mpfr_t*/ y,/*const*/ IntPtr /*mpfr_t*/ x, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sec(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_csc(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cot(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_hypot(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ x, /*const*/ IntPtr /*mpfr_t*/ y, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_erf(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_erfc(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cbrt(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_rootn_ui(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, uint /*unsigned long*/ k, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_root(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, uint /*unsigned long*/ k, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_gamma(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_gamma_inc(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_beta(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_lngamma(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_lgamma(IntPtr /*mpfr_t*/ rop, ref int /*int **/ signp, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_digamma(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_zeta(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_zeta_ui(IntPtr /*mpfr_t*/ rop, uint /*unsigned long*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fac_ui(IntPtr /*mpfr_t*/ rop, uint /*unsigned long int*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_j0(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_j1(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_jn(IntPtr /*mpfr_t*/ rop, int /*long*/ n, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_y0(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_y1(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_yn(IntPtr /*mpfr_t*/ rop, int /*long*/ n, /*const*/ IntPtr /*mpfr_t*/ op, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_ai(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ x, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_min(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_max(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_dim(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_z(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_z(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_add_z(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sub_z(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_z_sub(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_z(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mul_q(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, IntPtr /*mpq_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_div_q(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, IntPtr /*mpq_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_add_q(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, IntPtr /*mpq_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sub_q(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, IntPtr /*mpq_t*/ op2, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_q(/*const*/ IntPtr /*mpfr_t*/ op1, IntPtr /*mpq_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_cmp_f(/*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fma(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, /*const*/ IntPtr /*mpfr_t*/ op3, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fms(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, /*const*/ IntPtr /*mpfr_t*/ op3, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fmma(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, /*const*/ IntPtr /*mpfr_t*/ op3, /*const*/ IntPtr /*mpfr_t*/ op4, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_fmms(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t*/ op1, /*const*/ IntPtr /*mpfr_t*/ op2, /*const*/ IntPtr /*mpfr_t*/ op3, /*const*/ IntPtr /*mpfr_t*/ op4, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_sum(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*mpfr_t[]*/ tab, uint /*unsigned long*/ n, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_free_cache(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_free_cache2(uint /*mpfr_free_cache_t*/ way);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_free_pool(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_mp_memory_cleanup(/*void*/);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_subnormalize(IntPtr /*mpfr_t*/ x, int t, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_strtofr(IntPtr /*mpfr_t*/ rop, /*const*/ IntPtr /*char **/ nptr, ref IntPtr /*char ***/ endptr, int @base, int /*mpfr_rnd_t*/ rnd);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mpfr_custom_get_size")]
            public static extern uint /*size_t*/ mpfr_custom_get_size_x86(uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mpfr_custom_get_size")]
            public static extern ulong /*size_t*/ mpfr_custom_get_size_x64(uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_custom_init(IntPtr /*void **/ significand, uint /*mpfr_prec_t*/ prec);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern IntPtr /*void **/ mpfr_custom_get_significand(/*const*/ IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mpfr_exp_t*/ mpfr_custom_get_exp(/*const*/ IntPtr /*mpfr_t*/ x);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_custom_move(IntPtr /*mpfr_t*/ x, IntPtr /*void **/ new_position);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void mpfr_custom_init_set(IntPtr /*mpfr_t*/ x, int kind, int /*mpfr_exp_t*/ exp, uint /*mpfr_prec_t*/ prec, IntPtr /*void **/ significand);

            [DllImport(@"libmpfr-6.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int mpfr_custom_get_kind(/*const*/ IntPtr /*mpfr_t*/ x);

        }

        private class SafeHandle : SafeHandleZeroOrMinusOneIsInvalid
        {
            public SafeHandle(IntPtr handle)
                : base(true)
            {
                SetHandle(handle);
            }

            //public IntPtr Handle
            //{
            //    get
            //    {
            //        return handle;
            //    }
            //}

            [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
            protected override bool ReleaseHandle()
            {
                mpfr_lib.SafeNativeMethods.FreeLibrary(handle);
                return true;
            }
        }

    }
}
