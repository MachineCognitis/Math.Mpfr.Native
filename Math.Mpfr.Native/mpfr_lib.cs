
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using System.Runtime.ConstrainedExecution;
using System.Security;

namespace Math.Mpfr.Native
{

    /// <summary>
    /// Represents all of the functions of the GNU MPFR library.
    /// </summary>
    public static class mpfr_lib
    {

        // Safe handle to the loaded MPFR library.
        private static SafeHandle _mpfr_lib = new SafeHandle(_load_mpfr_lib());

        // Delegate to MPFR dynamic unmanaged memory allocation function.
        private static allocate_function allocate_func_ptr;

        // Delegate to MPFR dynamic unmanaged memory reallocation function.
        private static reallocate_function reallocate_func_ptr;

        // Delegate to MPFR dynamic unmanaged memory free function.
        private static free_function free_func_ptr;

        private static IntPtr _load_mpfr_lib()
        {
            // Load MPFR library based on current computer x86 or x64 architecture.
            string folderName = IntPtr.Size == 4 ? "x86" : "x64";
            // Get pathname of executing assembly.
            string codeBase = System.Reflection.Assembly.GetExecutingAssembly().EscapedCodeBase;
            // Get directory pathname of MPFR library.
            string libpath = System.IO.Path.GetDirectoryName(System.Uri.UnescapeDataString((new System.UriBuilder(codeBase)).Path)) + System.IO.Path.DirectorySeparatorChar + folderName;
            // Add MPFR library directory to DLL search paths.
            SafeNativeMethods.SetDllDirectory(libpath);
            // Load MPFR library and create safe handle to it.
            IntPtr handle = SafeNativeMethods.LoadLibrary(@"libmpfr-4.dll");
            // Retrieve and cache MPFR dynamic memory allocation functions.
            _get_memory_functions();
            return handle;
        }

        #region "Global variables."

        /// <summary>
        /// Gets or sets the global MPFR error number.
        /// </summary>
        public static int mpfr_errno
        {
            get
            {
                return Marshal.ReadInt32(SafeNativeMethods.GetProcAddress(_mpfr_lib.Handle, "__mpfr_errno"));
            }
            set
            {
                Marshal.WriteInt32(SafeNativeMethods.GetProcAddress(_mpfr_lib.Handle, "__mpfr_errno"), value);
            }
        }

        /// <summary>
        /// The MPFR version number in the form “i.j.k”. This release is "6.1.2".
        /// </summary>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Useful-Macros-and-Constants.html#Useful-Macros-and-Constants">GNU MPFR - Useful Macros and Constants</a></seealso>
        /// <example>
        /// <code language="C#">
        /// string version = mpfr_lib.mpfr_version;
        /// Assert.AreEqual(version, "6.1.2");
        /// </code> 
        /// <code language="VB.NET">
        /// Dim version As String = mpfr_lib.mpfr_version
        /// Assert.AreEqual(version, "6.1.2")
        /// </code> 
        /// </example>
        public static readonly string mpfr_version = Marshal.PtrToStringAnsi(Marshal.ReadIntPtr(SafeNativeMethods.GetProcAddress(_mpfr_lib.Handle, "__mpfr_version")));

        /// <summary>
        /// The number of bits per limb.
        /// </summary>
        /// <seealso cref="mp_bytes_per_limb"/>
        /// <seealso cref="mp_uint_per_limb"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Useful-Macros-and-Constants.html#Useful-Macros-and-Constants">GNU MPFR - Useful Macros and Constants</a></seealso>
        /// <example>
        /// <code language="C#">
        /// int bitsPerLimb = mpfr_lib.mp_bits_per_limb;
        /// Assert.AreEqual(bitsPerLimb, IntPtr.Size * 8);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim bitsPerLimb As Integer = mpfr_lib.mp_bits_per_limb
        /// Assert.AreEqual(bitsPerLimb, IntPtr.Size * 8)
        /// </code> 
        /// </example>
        public static readonly int mp_bits_per_limb = Marshal.ReadInt32(SafeNativeMethods.GetProcAddress(_mpfr_lib.Handle, "__mpfr_bits_per_limb"));

        /// <summary>
        /// The number of bytes per limb.
        /// </summary>
        /// <seealso cref="mp_bits_per_limb"/>
        /// <seealso cref="mp_uint_per_limb"/>
        /// <example>
        /// <code language="C#">
        /// mp_size_t bytesPerLimb = mpfr_lib.mp_bytes_per_limb;
        /// Assert.AreEqual(bytesPerLimb, (mp_size_t)IntPtr.Size);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim bytesPerLimb As mp_size_t = mpfr_lib.mp_bytes_per_limb
        /// Assert.AreEqual(bytesPerLimb, DirectCast(IntPtr.Size, mp_size_t)) 
        /// </code> 
        /// </example>
        public static readonly mp_size_t mp_bytes_per_limb = mp_bits_per_limb / 8;

        /// <summary>
        /// The number of 32-bit, unsigned integers per limb.
        /// </summary>
        /// <seealso cref="mp_bits_per_limb"/>
        /// <seealso cref="mp_bytes_per_limb"/>
        /// <example>
        /// <code language="C#">
        /// mp_size_t uintsPerLimb = mpfr_lib.mp_uint_per_limb;
        /// Assert.AreEqual(uintsPerLimb, (mp_size_t)(IntPtr.Size / 4));
        /// </code> 
        /// <code language="VB.NET">
        /// Dim uintsPerLimb As mp_size_t = mpfr_lib.mp_uint_per_limb
        /// Assert.AreEqual(uintsPerLimb, DirectCast(IntPtr.Size / 4, mp_size_t))
        /// </code> 
        /// </example>
        public static readonly  mp_size_t mp_uint_per_limb = mp_bits_per_limb / 32;

        #endregion

        #region "Memory allocation functions."

        /// <summary>
        /// Return a pointer to newly allocated space with at least <paramref name="alloc_size"/> bytes.
        /// </summary>
        /// <param name="alloc_size">The minimum number of bytes to allocate.</param>
        /// <returns>A pointer to newly allocated space with at least <paramref name="alloc_size"/> bytes.</returns>
        /// <remarks></remarks>
        /// <seealso cref="free(void_ptr, size_t)"/>
        /// <seealso cref="reallocate"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a></seealso>
        public static void_ptr allocate(size_t alloc_size)
        {
            return allocate_func_ptr(alloc_size);
        }

        /// <summary>
        /// Resize a previously allocated block <paramref name="ptr"/> of <paramref name="old_size"/> bytes to be <paramref name="new_size"/> bytes.
        /// </summary>
        /// <param name="ptr">Pointer to previously allocated block.</param>
        /// <param name="old_size">Number of bytes of previously allocated block.</param>
        /// <param name="new_size">New number of bytes of previously allocated block.</param>
        /// <returns>A previously allocated block ptr of <paramref name="old_size"/> bytes to be <paramref name="new_size"/> bytes.</returns>
        /// <remarks>
        /// <para>
        /// The block may be moved if necessary or if desired, and in that case the smaller of <paramref name="old_size"/> and
        /// <paramref name="new_size"/> bytes must be copied to the new location.
        /// The return value is a pointer to the resized block, that being the new location if moved or just <paramref name="ptr"/> if not.
        /// </para>
        /// <para>
        /// <paramref name="ptr"/> is never NULL, it’s always a previously allocated block. 
        /// <paramref name="new_size"/> may be bigger or smaller than <paramref name="old_size"/>.
        /// </para>
        /// <para>
        /// The reallocate function parameter <paramref name="old_size"/> is passed for convenience, but of course it can be ignored
        /// if not needed by an implementation. The default functions using malloc and friends for instance don’t use it.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_lib.allocate"/>
        /// <seealso cref="mpfr_lib.free(void_ptr, size_t)"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a></seealso>
        public static void_ptr reallocate(void_ptr ptr, size_t old_size, size_t new_size)
        {
            return reallocate_func_ptr(ptr, old_size, new_size);
        }

        /// <summary>
        /// De-allocate the space pointed to by <paramref name="ptrs"/>.
        /// </summary>
        /// <param name="ptrs">Pointers to previously allocated memory.</param>
        /// <remarks></remarks>
        /// <seealso cref="free(void_ptr, size_t)"/>
        public static void free(params mp_ptr[] ptrs)
        {
            if (ptrs == null) throw new ArgumentNullException("ptrs");
            foreach (mp_ptr p in ptrs)
                if (p.Size > 0)
                    free_func_ptr(new void_ptr(p.ToIntPtr()), 0);
        }

        /// <summary>
        /// De-allocate the space pointed to by <paramref name="ptr"/>.
        /// </summary>
        /// <param name="ptr">Pointer to previously allocated memory.</param>
        /// <remarks></remarks>
        /// <seealso cref="free(void_ptr, size_t)"/>
        public static void free(mpfr_randstate_t ptr)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");
            free_func_ptr(new void_ptr(ptr.ToIntPtr()), 0);
        }

        /// <summary>
        /// De-allocate the space pointed to by <paramref name="ptr"/>.
        /// </summary>
        /// <param name="ptr">Pointer to previously allocated memory.</param>
        /// <remarks></remarks>
        /// <seealso cref="free(void_ptr, size_t)"/>
        public static void free(char_ptr ptr)
        {
            free_func_ptr(new void_ptr(ptr.ToIntPtr()), 0);
        }

        /// <summary>
        /// De-allocate the space pointed to by <paramref name="ptr"/>.
        /// </summary>
        /// <param name="ptr">Pointer to previously allocated memory.</param>
        /// <remarks></remarks>
        /// <seealso cref="free(void_ptr, size_t)"/>
        public static void free(void_ptr ptr)
        {
            free_func_ptr(ptr, 0);
        }

        internal static void free(IntPtr ptr)
        {
            free_func_ptr(new void_ptr(ptr), 0);
        }

        /// <summary>
        /// De-allocate the space pointed to by <paramref name="ptr"/>.
        /// </summary>
        /// <param name="ptr">Pointer to previously allocated block.</param>
        /// <param name="size">Number of bytes of previously allocated block.</param>
        /// <remarks>
        /// <para>
        /// The free function parameter <paramref name="size"/> is passed for convenience, but of course it can be ignored
        /// if not needed by an implementation. The default functions using malloc and friends for instance don’t use it.
        /// </para>
        /// </remarks>
        /// <seealso cref="allocate"/>
        /// <seealso cref="reallocate"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a></seealso>
        public static void free(void_ptr ptr, size_t size)
        {
            free_func_ptr(ptr, size);
        }

        /// <summary>
        /// Get the current allocation functions, storing function pointers to the locations given by the arguments.
        /// </summary>
        /// <param name="alloc_func_ptr">The memory allocation function.</param>
        /// <param name="realloc_func_ptr">The memory reallocation function.</param>
        /// <param name="free_func_ptr">The memory de-allocation function.</param>
        /// <seealso cref="mp_set_memory_functions"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// allocate_function allocate;
        /// reallocate_function reallocate;
        /// free_function free;
        /// 
        /// // Retrieve the MPFR memory allocation functions.
        /// allocate = null;
        /// reallocate = null;
        /// free = null;
        /// mpfr_lib.mp_get_memory_functions(ref allocate, ref reallocate, ref free);
        /// Assert.IsTrue(allocate != null &amp;&amp; reallocate != null &amp;&amp; free != null);
        /// 
        /// // Allocate and free memory.
        /// void_ptr p = allocate(100);
        /// free(p, 100);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim allocate As allocate_function
        /// Dim reallocate As reallocate_function
        /// Dim free As free_function
        /// 
        /// ' Retrieve the MPFR memory allocation functions.
        /// allocate = Nothing
        /// reallocate = Nothing
        /// free = Nothing
        /// mpfr_lib.mp_get_memory_functions(allocate, reallocate, free)
        /// Assert.IsTrue(allocate IsNot Nothing AndAlso reallocate IsNot Nothing AndAlso free IsNot Nothing)
        /// 
        /// ' Allocate and free memory.
        /// Dim p As void_ptr = allocate(100)
        /// free(p, 100)
        /// </code> 
        /// </example>
        public static void mp_get_memory_functions(ref allocate_function alloc_func_ptr, ref reallocate_function realloc_func_ptr, ref free_function free_func_ptr)
        {
            alloc_func_ptr = mpfr_lib.allocate_func_ptr;
            realloc_func_ptr = mpfr_lib.reallocate_func_ptr;
            free_func_ptr = mpfr_lib.free_func_ptr;
        }

        /// <summary>
        /// Replace the current allocation functions from the arguments.
        /// </summary>
        /// <param name="alloc_func_ptr">The new memory allocation function.</param>
        /// <param name="realloc_func_ptr">The new memory reallocation function.</param>
        /// <param name="free_func_ptr">The new memory de-allocation function.</param>
        /// <remarks>
        /// <para>
        /// If an argument is <c>null</c> (<c>Nothing</c> in VB.NET), the corresponding
        /// default function is used.
        /// </para>
        /// </remarks>
        /// <seealso cref="mp_get_memory_functions"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Retrieve MPFR default memory allocation functions.
        /// allocate_function default_allocate = null;
        /// reallocate_function default_reallocate = null;
        /// free_function default_free = null;
        /// mpfr_lib.mp_get_memory_functions(ref default_allocate, ref default_reallocate, ref default_free);
        /// 
        /// // Create and set new memory allocation functions that count the number of times they are called.
        /// int counter = 0;
        /// allocate_function new_allocate = (size_t alloc_size) => { counter++; return default_allocate(alloc_size); };
        /// reallocate_function new_reallocate = (void_ptr ptr, size_t old_size, size_t new_size) => { counter++; return default_reallocate(ptr, old_size, new_size); };
        /// free_function new_free = (void_ptr ptr, size_t size) => { counter++; default_free(ptr, size); };
        /// mpfr_lib.mp_set_memory_functions(new_allocate, new_reallocate, new_free);
        /// 
        /// // Retrieve MPFR memory allocation functions.
        /// allocate_function allocate = null;
        /// reallocate_function reallocate = null;
        /// free_function free = null;
        /// mpfr_lib.mp_get_memory_functions(ref allocate, ref reallocate, ref free);
        /// 
        /// // Call memory function and assert calls count.
        /// void_ptr p = allocate(10);
        /// Assert.IsTrue(counter == 1);
        /// 
        /// reallocate(p, 10, 20);
        /// Assert.IsTrue(counter == 2);
        /// 
        /// free(p, 20);
        /// Assert.IsTrue(counter == 3);
        /// 
        /// // Restore default memory allocation functions.
        /// mpfr_lib.mp_set_memory_functions(null, null, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Retrieve MPFR default memory allocation functions.
        /// Dim default_allocate As allocate_function = Nothing
        /// Dim default_reallocate As reallocate_function = Nothing
        /// Dim default_free As free_function = Nothing
        /// mpfr_lib.mpfr_get_memory_functions(default_allocate, default_reallocate, default_free)
        /// 
        /// ' Create and set new memory allocation functions that count the number of times they are called.
        /// Dim counter As Integer = 0
        /// Dim new_allocate As allocate_function =
        ///     Function(alloc_size As size_t) 
        ///         counter += 1
        ///         Return default_allocate(alloc_size)
        ///     End Function
        /// Dim new_reallocate As reallocate_function =
        ///     Function(ptr As void_ptr, old_size As size_t, new_size As size_t) 
        /// 	    counter += 1
        /// 	    Return default_reallocate(ptr, old_size, new_size)
        ///     End Function
        /// Dim new_free As free_function =
        ///     Function(ptr As void_ptr, size As size_t) 
        /// 	    counter += 1
        /// 	    default_free(ptr, size)
        ///     End Function
        /// mpfr_lib.mpfr_set_memory_functions(new_allocate, new_reallocate, new_free)
        /// 
        /// ' Retrieve MPFR memory allocation functions.
        /// Dim allocate As allocate_function = Nothing
        /// Dim reallocate As reallocate_function = Nothing
        /// Dim free As free_function = Nothing
        /// mpfr_lib.mpfr_get_memory_functions(allocate, reallocate, free)
        /// 
        /// ' Call memory function and assert calls count.
        /// Dim p As void_ptr = allocate(10)
        /// Assert.IsTrue(counter = 1)
        /// 
        /// reallocate(p, 10, 20)
        /// Assert.IsTrue(counter = 2)
        /// 
        /// free(p, 20)
        /// Assert.IsTrue(counter = 3)
        /// 
        /// ' Restore default memory allocation functions.
        /// mpfr_lib.mpfr_set_memory_functions(Nothing, Nothing, Nothing)
        /// </code> 
        /// </example>
        public static void mp_set_memory_functions(allocate_function alloc_func_ptr, reallocate_function realloc_func_ptr, free_function free_func_ptr)
        {
            IntPtr allocate = IntPtr.Zero;
            IntPtr reallocate = IntPtr.Zero;
            IntPtr free = IntPtr.Zero;

            if (IntPtr.Size == 4)
            {
                if (alloc_func_ptr != null)
                    allocate = Marshal.GetFunctionPointerForDelegate((_allocate_function_x86)((uint alloc_size) => { return alloc_func_ptr((size_t)alloc_size).ToIntPtr(); }));
                if (realloc_func_ptr != null)
                    reallocate = Marshal.GetFunctionPointerForDelegate((_reallocate_function_x86)((IntPtr ptr, uint old_size, uint new_size) => { return realloc_func_ptr(new void_ptr(ptr), (size_t)old_size, (size_t)new_size).ToIntPtr(); }));
                if (free_func_ptr != null)
                    free = Marshal.GetFunctionPointerForDelegate((_free_function_x86)((IntPtr ptr, uint size) => { free_func_ptr(new void_ptr(ptr), (size_t)size); }));
            }
            else
            {
                if (alloc_func_ptr != null)
                    allocate = Marshal.GetFunctionPointerForDelegate((_allocate_function_x64)((ulong alloc_size) => { return alloc_func_ptr((size_t)alloc_size).ToIntPtr(); }));
                if (realloc_func_ptr != null)
                    reallocate = Marshal.GetFunctionPointerForDelegate((_reallocate_function_x64)((IntPtr ptr, ulong old_size, ulong new_size) => { return realloc_func_ptr(new void_ptr(ptr), (size_t)old_size, (size_t)new_size).ToIntPtr(); }));
                if (free_func_ptr != null)
                    free = Marshal.GetFunctionPointerForDelegate((_free_function_x64)((IntPtr ptr, ulong size) => { free_func_ptr(new void_ptr(ptr), (size_t)size); }));
            }

            SafeNativeMethods.__mpfr_set_memory_functions(allocate, reallocate, free);

            _get_memory_functions();
        }

        private static void _get_memory_functions()
        {
            // Cache dynamic memory allocation functions.

            IntPtr allocate = IntPtr.Zero;
            IntPtr reallocate = IntPtr.Zero;
            IntPtr free = IntPtr.Zero;

            SafeNativeMethods.__mpfr_get_memory_functions(ref allocate, ref reallocate, ref free);

            _get_memory_function(allocate, ref mpfr_lib.allocate_func_ptr);
            _get_memory_function(reallocate, ref mpfr_lib.reallocate_func_ptr);
            _get_memory_function(free, ref mpfr_lib.free_func_ptr);
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate IntPtr _allocate_function_x86(uint alloc_size);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate IntPtr _allocate_function_x64(ulong alloc_size);

        private static void _get_memory_function(IntPtr allocate, ref allocate_function alloc_func_ptr)
        {
            if (IntPtr.Size == 4)
                alloc_func_ptr = (size_t alloc_size) => { return new void_ptr(((_allocate_function_x86)Marshal.GetDelegateForFunctionPointer(allocate, typeof(_allocate_function_x86)))((uint)alloc_size)); };
            else
                alloc_func_ptr = (size_t alloc_size) => { return new void_ptr(((_allocate_function_x64)Marshal.GetDelegateForFunctionPointer(allocate, typeof(_allocate_function_x64)))((ulong)alloc_size)); };
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate IntPtr _reallocate_function_x86(IntPtr ptr, uint old_size, uint new_size);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate IntPtr _reallocate_function_x64(IntPtr ptr, ulong old_size, ulong new_size);

        private static void _get_memory_function(IntPtr reallocate, ref reallocate_function realloc_func_ptr)
        {
            if (IntPtr.Size == 4)
                realloc_func_ptr = (ptr, old_size, new_size) => { return ptr.FromIntPtr(((_reallocate_function_x86)Marshal.GetDelegateForFunctionPointer(reallocate, typeof(_reallocate_function_x86)))(ptr.ToIntPtr(), (uint)old_size, (uint)new_size)); };
            else
                realloc_func_ptr = (ptr, old_size, new_size) => { return ptr.FromIntPtr(((_reallocate_function_x64)Marshal.GetDelegateForFunctionPointer(reallocate, typeof(_reallocate_function_x64)))(ptr.ToIntPtr(), (ulong)old_size, (ulong)new_size)); };
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate void _free_function_x86(IntPtr ptr, uint size);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate void _free_function_x64(IntPtr ptr, ulong size);

        private static void _get_memory_function(IntPtr free, ref free_function free_func_ptr)
        {
            if (IntPtr.Size == 4)
                free_func_ptr = (ptr, size) => { ((_free_function_x86)Marshal.GetDelegateForFunctionPointer(free, typeof(_free_function_x86)))(ptr.ToIntPtr(), (uint)size); };
            else
                free_func_ptr = (ptr, size) => { ((_free_function_x64)Marshal.GetDelegateForFunctionPointer(free, typeof(_free_function_x64)))(ptr.ToIntPtr(), (ulong)size); };
        }

        /// <summary>
        /// The <see cref="ZeroMemory"/> routine fills a block of memory with zeros, given a pointer to the block and the length, in bytes, to be filled.
        /// </summary>
        /// <param name="dst">A pointer to the memory block to be filled with zeros.</param>
        /// <param name="length">The number of bytes to fill with zeros.</param>
        public static void ZeroMemory(IntPtr dst, int length)
        {
            SafeNativeMethods.RtlZeroMemory(dst, length);
        }

        #endregion

        #region "Random number routines."

        /// <summary>
        /// Initialize <paramref name="state"/> with a default algorithm.
        /// </summary>
        /// <param name="state">The state to initialize.</param>
        /// <remarks>
        /// <para>
        /// This will be a compromise between speed and randomness, 
        /// and is recommended for applications with no special requirements.
        /// Currently this is <see cref="mpfr_randinit_mt"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_randclear"/>
        /// <seealso cref="mpfr_randinit_lc_2exp"/>
        /// <seealso cref="mpfr_randinit_lc_2exp_size"/>
        /// <seealso cref="mpfr_randinit_mt"/>
        /// <seealso cref="mpfr_randinit_set"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// 
        /// // Initialize state with default random number generator algorithm.
        /// mpfr_lib.mpfr_randinit_default(state);
        /// 
        /// // Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// ' Initialize state with default random number generator algorithm.
        /// mpfr_lib.mpfr_randinit_default(state)
        /// 
        /// ' Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state)
        /// </code> 
        /// </example>
        public static void mpfr_randinit_default(mpfr_randstate_t state)
        {
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfr_randinit_default(state.ToIntPtr());
        }

        /// <summary>
        /// Initialize <paramref name="state"/> with a linear congruential algorithm X = (<paramref name="a"/>X + <paramref name="c"/>) mod 2^<paramref name="m2exp"/>.
        /// </summary>
        /// <param name="state">The state to initialize.</param>
        /// <param name="a">Parameter of the algorithm.</param>
        /// <param name="c">Parameter of the algorithm.</param>
        /// <param name="m2exp">Parameter of the algorithm.</param>
        /// <remarks>
        /// <para>
        /// The low bits of X in this algorithm are not very random.
        /// The least significant bit will have a period no more than 2, and the second bit
        /// no more than 4, etc. For this reason only the high half of each X is actually used.
        /// </para>
        /// <para>
        /// When a random number of more than <paramref name="m2exp"/> / 2 bits is to be generated,
        /// multiple iterations of the recurrence are used and the results concatenated.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_randclear"/>
        /// <seealso cref="mpfr_randinit_default"/>
        /// <seealso cref="mpfr_randinit_lc_2exp_size"/>
        /// <seealso cref="mpfr_randinit_mt"/>
        /// <seealso cref="mpfr_randinit_set"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// 
        /// // Initialize state with a linear congruential random number generator algorithm.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 100000U);
        /// mpfr_lib.mpfr_randinit_lc_2exp(state, a, 13, 300);
        /// 
        /// // Free all memory occupied by state and a.
        /// mpfr_lib.mpfr_randclear(state);
        /// mpfr_lib.mpz_clear(a);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// ' Initialize state with a linear congruential random number generator algorithm.
        /// Dim a As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init_set_ui(a, 100000UI)
        /// mpfr_lib.mpfr_randinit_lc_2exp(state, a, 13, 300)
        /// 
        /// ' Free all memory occupied by state and a.
        /// mpfr_lib.mpfr_randclear(state)
        /// mpfr_lib.mpz_clear(a)
        /// </code> 
        /// </example>
        public static void mpfr_randinit_lc_2exp(mpfr_randstate_t state, /*const*/ mpz_t a, uint /*unsigned long int*/ c, mp_bitcnt_t m2exp)
        {
            if (state == null) throw new ArgumentNullException("state");
            if (a == null) throw new ArgumentNullException("a");
            SafeNativeMethods.__mpfr_randinit_lc_2exp(state.ToIntPtr(), a.ToIntPtr(), c, m2exp);
        }

        /// <summary>
        /// Initialize <paramref name="state"/> for a linear congruential algorithm as per <see cref="mpfr_randinit_lc_2exp"/>.
        /// </summary>
        /// <param name="state">The state to initialize.</param>
        /// <param name="size"></param>
        /// <returns>If successful the return value is non-zero. If <paramref name="size"/> is bigger than the table data provides then the return value is zero.</returns>
        /// <remarks>
        /// <para>
        /// a, c and m2exp are selected from a table, chosen so that <paramref name="size"/>
        /// bits (or more) of each X will be used, i.e. m2exp / 2 &#8805; <paramref name="size"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_randclear"/>
        /// <seealso cref="mpfr_randinit_default"/>
        /// <seealso cref="mpfr_randinit_lc_2exp"/>
        /// <seealso cref="mpfr_randinit_mt"/>
        /// <seealso cref="mpfr_randinit_set"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// 
        /// // Initialize state with a linear congruential random number generator algorithm.
        /// mpfr_lib.mpfr_randinit_lc_2exp_size(state, 30);
        /// 
        /// // Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// ' Initialize state with a linear congruential random number generator algorithm.
        /// mpfr_lib.mpfr_randinit_lc_2exp_size(state, 30)
        /// 
        /// ' Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state)
        /// </code> 
        /// </example>
        public static int mpfr_randinit_lc_2exp_size(mpfr_randstate_t state, mp_bitcnt_t size)
        {
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.__mpfr_randinit_lc_2exp_size(state.ToIntPtr(), size);
        }

        /// <summary>
        /// Initialize <paramref name="state"/> for a Mersenne Twister algorithm.
        /// </summary>
        /// <param name="state">The state to initialize.</param>
        /// <remarks>
        /// <para>
        /// This algorithm is fast and has good randomness properties.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_randclear"/>
        /// <seealso cref="mpfr_randinit_default"/>
        /// <seealso cref="mpfr_randinit_lc_2exp"/>
        /// <seealso cref="mpfr_randinit_lc_2exp_size"/>
        /// <seealso cref="mpfr_randinit_set"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// 
        /// // Initialize state with Mersenne Twister random number generator algorithm.
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// 
        /// // Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// ' Initialize state with Mersenne Twister random number generator algorithm.
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// 
        /// ' Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state)
        /// </code> 
        /// </example>
        public static void mpfr_randinit_mt(mpfr_randstate_t state)
        {
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfr_randinit_mt(state.ToIntPtr());
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> with a copy of the algorithm and state from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The state to initialize.</param>
        /// <param name="op">The source state.</param>
        /// <seealso cref="mpfr_randclear"/>
        /// <seealso cref="mpfr_randinit_default"/>
        /// <seealso cref="mpfr_randinit_lc_2exp"/>
        /// <seealso cref="mpfr_randinit_lc_2exp_size"/>
        /// <seealso cref="mpfr_randinit_mt"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
        /// mpfr_randstate_t op = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(op);
        /// 
        /// // Create new random number generator state, and initialize it with the state op.
        /// mpfr_randstate_t rop = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_set(rop, op);
        /// 
        /// // Free all memory occupied by op and rop.
        /// mpfr_lib.mpfr_randclear(op);
        /// mpfr_lib.mpfr_randclear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
        /// Dim op As New mpfr_randstate_t()
        /// 
        /// mpfr_lib.mpfr_randinit_mt(op)
        /// 
        /// ' Create new random number generator state, and initialize it with the state op.
        /// Dim rop As New mpfr_randstate_t()
        /// 
        /// mpfr_lib.mpfr_randinit_set(rop, op)
        /// 
        /// ' Free all memory occupied by op and rop.
        /// mpfr_lib.mpfr_randclear(op)
        /// mpfr_lib.mpfr_randclear(rop)
        /// </code> 
        /// </example>
        public static void mpfr_randinit_set(mpfr_randstate_t rop, /*const*/ mpfr_randstate_t /*__mpfr_randstate_struct **/ op)
        {
            if (rop == null) throw new ArgumentNullException("state");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfr_randinit_set(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set an initial <paramref name="seed"/> value into <paramref name="state"/>.
        /// </summary>
        /// <param name="state">The state to seed.</param>
        /// <param name="seed">The seed.</param>
        /// <remarks>
        /// <para>
        /// The size of a seed determines how many different sequences of random numbers that it’s possible to
        /// generate. The “quality” of the seed is the randomness of a given seed compared to the previous seed
        /// used, and this affects the randomness of separate number sequences. The method for choosing a seed
        /// is critical if the generated numbers are to be used for important applications, such as generating
        /// cryptographic keys.
        /// </para>
        /// <para>
        /// Traditionally the system time has been used to seed, but care needs to be taken with this. If an
        /// application seeds often and the resolution of the system clock is low, then the same sequence of
        /// numbers might be repeated. Also, the system time is quite easy to guess, so if unpredictability is
        /// required then it should definitely not be the only source for the seed value. On some systems
        /// there’s a special device /dev/random which provides random data better suited for use as a seed.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_randseed_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Seeding.html#Random-State-Seeding">GNU MPFR - Random State Seeding</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// 
        /// // Seed random number generator.
        /// mpz_t seed = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(seed, 100000U);
        /// mpfr_lib.mpfr_randseed(state, seed);
        /// 
        /// // Free all memory occupied by state and seed.
        /// mpfr_lib.mpfr_randclear(state);
        /// mpfr_lib.mpz_clear(seed);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// 
        /// ' Seed random number generator.
        /// Dim seed As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init_set_ui(seed, 100000UI)
        /// mpfr_lib.mpfr_randseed(state, seed)
        /// 
        /// ' Free all memory occupied by state and seed.
        /// mpfr_lib.mpfr_randclear(state)
        /// mpfr_lib.mpz_clear(seed)
        /// </code> 
        /// </example>
        public static void mpfr_randseed(mpfr_randstate_t state, /*const*/ mpz_t seed)
        {
            if (state == null) throw new ArgumentNullException("state");
            if (seed == null) throw new ArgumentNullException("seed");
            SafeNativeMethods.__mpfr_randseed(state.ToIntPtr(), seed.ToIntPtr());
        }

        /// <summary>
        /// Set an initial <paramref name="seed"/> value into <paramref name="state"/>.
        /// </summary>
        /// <param name="state">The state to seed.</param>
        /// <param name="seed">The seed.</param>
        /// <remarks>
        /// <para>
        /// The size of a seed determines how many different sequences of random numbers that it’s possible to
        /// generate. The “quality” of the seed is the randomness of a given seed compared to the previous seed
        /// used, and this affects the randomness of separate number sequences. The method for choosing a seed
        /// is critical if the generated numbers are to be used for important applications, such as generating
        /// cryptographic keys.
        /// </para>
        /// <para>
        /// Traditionally the system time has been used to seed, but care needs to be taken with this. If an
        /// application seeds often and the resolution of the system clock is low, then the same sequence of
        /// numbers might be repeated. Also, the system time is quite easy to guess, so if unpredictability is
        /// required then it should definitely not be the only source for the seed value. On some systems
        /// there’s a special device /dev/random which provides random data better suited for use as a seed.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_randseed"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Seeding.html#Random-State-Seeding">GNU MPFR - Random State Seeding</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// 
        /// // Seed random number generator.
        /// mpfr_lib.mpfr_randseed_ui(state, 100000U);
        /// 
        /// // Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new random number generator state, and initialize state with the Mersenne Twister algorithm.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// 
        /// ' Seed random number generator.
        /// mpfr_lib.mpfr_randseed_ui(state, 100000UI)
        /// 
        /// ' Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state)        /// </code> 
        /// </example>
        public static void mpfr_randseed_ui(mpfr_randstate_t state, uint /*unsigned long int*/ seed)
        {
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfr_randseed_ui(state.ToIntPtr(), seed);
        }

        /// <summary>
        /// Free all memory occupied by <paramref name="state"/>.
        /// </summary>
        /// <param name="state">A state.</param>
        /// <seealso cref="mpfr_randinit_default"/>
        /// <seealso cref="mpfr_randinit_lc_2exp"/>
        /// <seealso cref="mpfr_randinit_lc_2exp_size"/>
        /// <seealso cref="mpfr_randinit_mt"/>
        /// <seealso cref="mpfr_randinit_set"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a></seealso>
        public static void mpfr_randclear(mpfr_randstate_t state)
        {
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfr_randclear(state.ToIntPtr());
            mpfr_lib.free(state);
        }

        /// <summary>
        /// Generate a uniformly distributed random number of <paramref name="n"/> bits, i.e. in the range 0 to 2^<paramref name="n"/> - 1 inclusive.
        /// </summary>
        /// <param name="state">The state of the random number generator to use.</param>
        /// <param name="n">The numbe rof bits.</param>
        /// <returns>The generated random number.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> must be less than or equal to the number of bits in an unsigned long.
        /// </para>
        /// <para>
        /// In .NET, <paramref name="n"/> must be less than or equal to the number of bits in an unsigned 32-bit integer.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_urandomm_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Miscellaneous.html#Random-State-Miscellaneous">GNU MPFR - Random State Miscellaneous</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// mpfr_lib.mpfr_randseed_ui(state, 100000U);
        /// 
        /// // Generate a random integer in the range [0, 2^8-1].
        /// uint rand = mpfr_lib.mpfr_urandomb_ui(state, 8);
        /// 
        /// // Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As New mpfr_randstate_t()
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// mpfr_lib.mpfr_randseed_ui(state, 100000UI)
        /// 
        /// ' Generate a random integer in the range [0, 2^8-1].
        /// Dim rand As UInteger = mpfr_lib.mpfr_urandomb_ui(state, 8)
        /// 
        /// ' Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpfr_urandomb_ui(mpfr_randstate_t state, uint /*unsigned long int*/ n)
        {
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.__mpfr_urandomb_ui(state.ToIntPtr(), n);
        }

        /// <summary>
        /// Generate a uniformly distributed random number in the range 0 to <paramref name="n"/> - 1, inclusive.
        /// </summary>
        /// <param name="state">The state of the random number generator to use.</param>
        /// <param name="n">The upper bound of the range.</param>
        /// <returns>The generated random number.</returns>
        /// <seealso cref="mpfr_urandomb_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Random-State-Miscellaneous.html#Random-State-Miscellaneous">GNU MPFR - Random State Miscellaneous</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// mpfr_lib.mpfr_randseed_ui(state, 1000U);
        /// 
        /// // Generate a random integer in the range [0, 8-1].
        /// uint rand = mpfr_lib.mpfr_urandomm_ui(state, 8);
        /// 
        /// // Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As New mpfr_randstate_t()
        /// 
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// mpfr_lib.mpfr_randseed_ui(state, 1000UI)
        /// 
        /// ' Generate a random integer in the range [0, 8-1].
        /// Dim rand As UInteger = mpfr_lib.mpfr_urandomm_ui(state, 8)
        /// 
        /// ' Free all memory occupied by state.
        /// mpfr_lib.mpfr_randclear(state)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpfr_urandomm_ui(mpfr_randstate_t state, uint /*unsigned long int*/ n)
        {
            if (state == null) throw new ArgumentNullException("state");
            return SafeNativeMethods.__mpfr_urandomm_ui(state.ToIntPtr(), n);
        }

        #endregion

        #region "Formatted output routines."

        /// <summary>
        /// Form a null-terminated string in a block of memory obtained from the current memory allocation function.
        /// </summary>
        /// <param name="pp">Pointer to returned, allocated string.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="args">Arguments.</param>
        /// <returns>The return value is the number of characters produced, excluding the null-terminator.</returns>
        /// <remarks>
        /// <para>
        /// The block will be the size of the string and null-terminator. The address of the block in stored to <paramref name="pp"/>.
        /// </para>
        /// <para>
        /// Unlike the C library asprintf, <see cref="mpfr_asprintf"/> doesn’t return -1 if there’s no more memory available,
        /// it lets the current allocation function handle that. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_snprintf"/>
        /// <seealso cref="mpfr_sprintf"/>
        /// <seealso cref="mpfr_vasprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create pointer to unmanaged character string pointer.
        /// ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to newly allocated unmanaged memory string.
        /// Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// Assert.IsTrue(str.Value.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(str.Value);
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create pointer to unmanaged character string pointer.
        /// Dim str As New ptr(Of char_ptr)()
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to newly allocated unmanaged memory string.
        /// Assert.IsTrue(mpfr_lib.mpfr_asprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// Assert.IsTrue(str.Value.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(str.Value)
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_asprintf(ptr<char_ptr> /*char ***/ pp, /*const*/ string /*char **/ fmt, params object[] /*...*/ args)
        {
            return mpfr_vasprintf(pp, fmt, args);
        }

        /// <summary>
        /// Print to the stream <paramref name="fp"/>.
        /// </summary>
        /// <param name="fp">File stream.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="args">Arguments.</param>
        /// <returns>Return the number of characters written, or -1 if an error occurred.</returns>
        /// <seealso cref="mpfr_printf"/>
        /// <seealso cref="mpfr_sprintf"/>
        /// <seealso cref="mpfr_vfprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create unique file pathname and a file pointer.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Open file stream and print to it.
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// Assert.IsTrue(mpfr_lib.mpfr_fprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// fclose(stream.Value.Value);
        /// Assert.IsTrue(System.IO.File.ReadAllText(pathname) == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create unique file pathname and a file pointer.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// Dim stream As New ptr(Of FILE)()
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Open file stream and print to it.
        /// _wfopen_s(stream.Value.Value, pathname, "w")
        /// Assert.IsTrue(mpfr_lib.mpfr_fprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// fclose(stream.Value.Value)
        /// Assert.IsTrue(System.IO.File.ReadAllText(pathname) = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_fprintf(ptr<FILE> /*FILE **/ fp, /*const*/ string /*char **/ fmt, params object[] /*...*/ args)
        {
            return mpfr_vfprintf(fp, fmt, args);
        }

        //#define mpfr_obstack_printf __mpfr_obstack_printf
        //#if defined (_MPFR_H_HAVE_OBSTACK)
        //public static extern int mpfr_obstack_printf (struct obstack *, const char *, ...);
        //#endif

        //#define mpfr_obstack_vprintf __mpfr_obstack_vprintf
        //#if defined (_MPFR_H_HAVE_OBSTACK) && defined (_MPFR_H_HAVE_VA_LIST)
        //public static extern int mpfr_obstack_vprintf (struct obstack *, const char *, va_list);
        //#endif

        /// <summary>
        /// Print to the standard output stdout.
        /// </summary>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="args">Arguments.</param>
        /// <returns>Return the number of characters written, or -1 if an error occurred.</returns>
        /// <seealso cref="mpfr_fprintf"/>
        /// <seealso cref="mpfr_sprintf"/>
        /// <seealso cref="mpfr_vprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to standard output.
        /// Assert.IsTrue(mpfr_lib.mpfr_printf("%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// <code language="VB.NET">
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to standard output.
        /// Assert.IsTrue(mpfr_lib.mpfr_printf("%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        ///
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_printf(/*const*/ string /*char **/ fmt, params object[] /*...*/ args)
        {
            return mpfr_vprintf(fmt, args);
        }

        /// <summary>
        /// Form a null-terminated string in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The string to print to.</param>
        /// <param name="size">The maximum number of bytes to write.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="args">Arguments.</param>
        /// <returns>The return value is the total number of characters which ought to have been produced, excluding the terminating null. If retval &#8805; <paramref name="size"/> then the actual output has been truncated to the first <paramref name="size"/> - 1 characters, and a null appended.</returns>
        /// <remarks>
        /// <para>
        /// No more than <paramref name="size"/> bytes will be written. To get the full output, <paramref name="size"/> must be enough for the string and null-terminator. 
        /// </para>
        /// <para>
        /// No overlap is permitted between the regiom {<paramref name="buf"/>,<paramref name="size"/>} and the <paramref name="fmt"/> string.
        /// </para>
        /// <para>
        /// Notice the return value is in ISO C99 snprintf style. This is so even if the C library vsnprintf is the older GLIBC 2.0.x style.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_asprintf"/>
        /// <seealso cref="mpfr_sprintf"/>
        /// <seealso cref="mpfr_vsnprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Allocate unmanaged string with 50 characters.
        /// char_ptr str = new char_ptr(".................................................");
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(str);
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Allocate unmanaged string with 50 characters.
        /// Dim str As New char_ptr(".................................................")
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_snprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(str)
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_snprintf(char_ptr /*char **/ buf, size_t size, /*const*/ string /*char **/ fmt, params object[] /*...*/ args)
        {
            return mpfr_vsnprintf(buf, size, fmt, args);
        }

        /// <summary>
        /// Form a null-terminated string in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The string to print to.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="args">Arguments.</param>
        /// <returns>Return the number of characters written, excluding the terminating null.</returns>
        /// <remarks>
        /// <para>
        /// No overlap is permitted between the space at <paramref name="buf"/> and the string <paramref name="fmt"/>.
        /// </para>
        /// <para>
        /// These functions are not recommended, since there’s no protection against exceeding the space available at <paramref name="buf"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_asprintf"/>
        /// <seealso cref="mpfr_printf"/>
        /// <seealso cref="mpfr_fprintf"/>
        /// <seealso cref="mpfr_snprintf"/>
        /// <seealso cref="mpfr_vsprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Allocate unmanaged string with 50 characters.
        /// char_ptr str = new char_ptr(".................................................");
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(str);
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Allocate unmanaged string with 50 characters.
        /// Dim str As New char_ptr(".................................................")
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_sprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(str)
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_sprintf(char_ptr /*char **/ buf, /*const*/ string /*char **/ fmt, params object[] /*...*/ args)
        {
            return mpfr_vsprintf(buf, fmt, args);
        }

        /// <summary>
        /// Form a null-terminated string in a block of memory obtained from the current memory allocation function.
        /// </summary>
        /// <param name="ptr"></param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value is the number of characters produced, excluding the null-terminator.</returns>
        /// <remarks>
        /// <para>
        /// The block will be the size of the string and null-terminator. The address of the block in stored to <paramref name="ptr"/>.
        /// </para>
        /// <para>
        /// Unlike the C library vasprintf, <see cref="mpfr_vasprintf"/> doesn’t return -1 if there’s no more memory available,
        /// it lets the current allocation function handle that. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_asprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create pointer to unmanaged character string pointer.
        /// ptr&lt;char_ptr&gt; str = new ptr&lt;char_ptr&gt;();
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to newly allocated unmanaged memory string.
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// Assert.IsTrue(str.Value.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(str.Value);
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create pointer to unmanaged character string pointer.
        /// Dim str As New ptr(Of char_ptr)()
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to newly allocated unmanaged memory string.
        /// Assert.IsTrue(mpfr_lib.mpfr_vasprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// Assert.IsTrue(str.Value.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(str.Value)
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vasprintf(ptr<char_ptr> /*char ***/ ptr, /*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (ptr == null) throw new ArgumentNullException("ptr");
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result = SafeNativeMethods.__mpfr_vasprintf(ref ptr.Value.pointer, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        /// <summary>
        /// Print to the stream <paramref name="fp"/>.
        /// </summary>
        /// <param name="fp">File stream.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>Return the number of characters written, or -1 if an error occurred.</returns>
        /// <seealso cref="mpfr_fprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create unique file pathname and a file pointer.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Open file stream and print to it.
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// Assert.IsTrue(mpfr_lib.mpfr_vfprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// fclose(stream.Value.Value);
        /// Assert.IsTrue(System.IO.File.ReadAllText(pathname) == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create unique file pathname and a file pointer.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// Dim stream As New ptr(Of FILE)()
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Open file stream and print to it.
        /// _wfopen_s(stream.Value.Value, pathname, "w")
        /// Assert.IsTrue(mpfr_lib.mpfr_vfprintf(stream, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// fclose(stream.Value.Value)
        /// Assert.IsTrue(System.IO.File.ReadAllText(pathname) = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vfprintf(ptr<FILE> /*FILE **/ fp, /*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (fp == null) throw new ArgumentNullException("fp");
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result = SafeNativeMethods.__mpfr_vfprintf(fp.Value.Value, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        /// <summary>
        /// Print to the standard output stdout.
        /// </summary>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>Return the number of characters written, or -1 if an error occurred.</returns>
        /// <seealso cref="mpfr_printf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to standard output.
        /// Assert.IsTrue(mpfr_lib.mpfr_vprintf("%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// <code language="VB.NET">
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to standard output.
        /// Assert.IsTrue(mpfr_lib.mpfr_vprintf("%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        ///
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vprintf(/*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result = SafeNativeMethods.__mpfr_vprintf(format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        /// <summary>
        /// Form a null-terminated string in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The string to print to.</param>
        /// <param name="size">The maximum number of bytes to write.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value is the total number of characters which ought to have been produced, excluding the terminating null. If retval &#8805; <paramref name="size"/> then the actual output has been truncated to the first <paramref name="size"/> - 1 characters, and a null appended.</returns>
        /// <remarks>
        /// <para>
        /// No more than <paramref name="size"/> bytes will be written. To get the full output, <paramref name="size"/> must be enough for the string and null-terminator. 
        /// </para>
        /// <para>
        /// No overlap is permitted between the regiom {<paramref name="buf"/>,<paramref name="size"/>} and the <paramref name="fmt"/> string.
        /// </para>
        /// <para>
        /// Notice the return value is in ISO C99 snprintf style. This is so even if the C library vsnprintf is the older GLIBC 2.0.x style. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_snprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Allocate unmanaged string with 50 characters.
        /// char_ptr str = new char_ptr(".................................................");
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(str);
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Allocate unmanaged string with 50 characters.
        /// Dim str As New char_ptr(".................................................")
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_vsnprintf(str, 50, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(str)
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vsnprintf(char_ptr /*char **/ buf, size_t size, /*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (buf == null) throw new ArgumentNullException("buf");
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result;
            if (IntPtr.Size == 4)
                result = SafeNativeMethods.__mpfr_vsnprintf_x86(buf.ToIntPtr(), (uint)size, format.ToIntPtr(), va_args.ToIntPtr());
            else
                result = SafeNativeMethods.__mpfr_vsnprintf_x64(buf.ToIntPtr(), (ulong)size, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        /// <summary>
        /// Form a null-terminated string in <paramref name="buf"/>.
        /// </summary>
        /// <param name="buf">The string to print to.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">Formatted Output Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>Return the number of characters written, excluding the terminating null.</returns>
        /// <remarks>
        /// <para>
        /// No overlap is permitted between the space at <paramref name="buf"/> and the string <paramref name="fmt"/>.
        /// </para>
        /// <para>
        /// These functions are not recommended, since there’s no protection against exceeding the space available at <paramref name="buf"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_sprintf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Functions.html#Formatted-Output-Functions">GNU MPFR - Formatted Output Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Output-Strings.html#Formatted-Output-Strings">GNU MPFR - Formatted Output Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Allocate unmanaged string with 50 characters.
        /// char_ptr str = new char_ptr(".................................................");
        /// 
        /// mpz_t z = "123456";
        /// mpq_t q = "123/456";
        /// mpf_t f = "12345e6";
        /// mp_limb_t m = 123456;
        /// 
        /// // Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) == 42);
        /// Assert.IsTrue(str.ToString() == "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100");
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(str);
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Allocate unmanaged string with 50 characters.
        /// Dim str As New char_ptr(".................................................")
        /// 
        /// Dim z As mpz_t = "123456"
        /// Dim q As mpq_t = "123/456"
        /// Dim f As mpf_t = "12345e6"
        /// Dim m As mp_limb_t = 123456
        /// 
        /// ' Print to string.
        /// Assert.IsTrue(mpfr_lib.mpfr_vsprintf(str, "%Zd - %QX - %Fa - %Mo", z, q, f, m) = 42)
        /// Assert.IsTrue(str.ToString() = "123456 - 7B/1C8 - 0x2.dfd1c04p+32 - 361100")
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(str)
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vsprintf(char_ptr /*char **/ buf, /*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (buf == null) throw new ArgumentNullException("buf");
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result = SafeNativeMethods.__mpfr_vsprintf(buf.ToIntPtr(), format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        #endregion

        #region "Formatted input routines."

        /// <summary>
        /// Read from the stream <paramref name="fp"/>.
        /// </summary>
        /// <param name="fp">File stream.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
        /// <seealso cref="mpfr_scanf"/>
        /// <seealso cref="mpfr_sscanf"/>
        /// <seealso cref="mpfr_vfscanf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MPFR - Formatted Input Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MPFR - Formatted Input Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create unique filename and stream pointer.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// 
        /// mpz_t z = "0";
        /// mpq_t q = "0";
        /// mpf_t f = "0";
        /// ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
        /// ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
        /// ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
        /// 
        /// // Write string to file, and then read values from it.
        /// System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000");
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpfr_fscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert values read.
        /// Assert.IsTrue(z.ToString() == "123456");
        /// Assert.IsTrue(q.ToString() == "123/456");
        /// Assert.IsTrue(f.ToString() == "0.12345e11");
        /// Assert.IsTrue(c.Value == 'A');
        /// Assert.IsTrue(zt.Value == 10);
        /// Assert.IsTrue(dbl.Value == 1.0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create unique filename and stream pointer.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// Dim stream As New ptr(Of FILE)()
        /// 
        /// Dim z As mpz_t = "0"
        /// Dim q As mpq_t = "0"
        /// Dim f As mpf_t = "0"
        /// Dim c As New ptr(Of[Char])("0"C)
        /// Dim zt As New ptr(Of mp_size_t)(0)
        /// Dim dbl As New ptr(Of[Double])(0)
        /// 
        /// ' Write string to file, and then read values from it.
        /// System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000")
        /// _wfopen_s(stream.Value.Value, pathname, "r")
        /// Assert.IsTrue(mpfr_lib.mpfr_fscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert values read.
        /// Assert.IsTrue(z.ToString() = "123456")
        /// Assert.IsTrue(q.ToString() = "123/456")
        /// Assert.IsTrue(f.ToString() = "0.12345e11")
        /// Assert.IsTrue(c.Value = "A"C)
        /// Assert.IsTrue(zt.Value = 10)
        /// Assert.IsTrue(dbl.Value = 1.0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_fscanf(ptr<FILE> /*FILE **/ fp, /*const*/ string /*char **/ fmt, params object[] /*...*/ ap)
        {
            return mpfr_vfscanf(fp, fmt, ap);
        }

        /// <summary>
        /// Read from the standard input <c>stdin</c>.
        /// </summary>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
        /// <seealso cref="mpfr_fscanf"/>
        /// <seealso cref="mpfr_sscanf"/>
        /// <seealso cref="mpfr_vscanf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MPFR - Formatted Input Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MPFR - Formatted Input Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// mpz_t z = "0";
        /// mpq_t q = "0";
        /// mpf_t f = "0";
        /// ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
        /// ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
        /// ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
        /// 
        /// // Read values from standard input.
        /// Assert.IsTrue(mpfr_lib.mpfr_scanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
        /// 
        /// // Assert values read.
        /// Assert.IsTrue(z.ToString() == "123456");
        /// Assert.IsTrue(q.ToString() == "123/456");
        /// Assert.IsTrue(f.ToString() == "0.12345e11");
        /// Assert.IsTrue(c.Value == 'A');
        /// Assert.IsTrue(zt.Value == 10);
        /// Assert.IsTrue(dbl.Value == 1.0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim z As mpz_t = "0"
        /// Dim q As mpq_t = "0"
        /// Dim f As mpf_t = "0"
        /// Dim c As New ptr(Of[Char])("0"C)
        /// Dim zt As New ptr(Of mp_size_t)(0)
        /// Dim dbl As New ptr(Of[Double])(0)
        /// 
        /// ' Read values from standard input.
        /// Assert.IsTrue(mpfr_lib.mpfr_scanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
        /// 
        /// ' Assert values read.
        /// Assert.IsTrue(z.ToString() = "123456")
        /// Assert.IsTrue(q.ToString() = "123/456")
        /// Assert.IsTrue(f.ToString() = "0.12345e11")
        /// Assert.IsTrue(c.Value = "A"C)
        /// Assert.IsTrue(zt.Value = 10)
        /// Assert.IsTrue(dbl.Value = 1.0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_scanf(/*const*/ string /*char **/ fmt, params object[] /*...*/ ap)
        {
            return mpfr_vscanf(fmt, ap);
        }

        /// <summary>
        /// Read from a null-terminated string <paramref name="s"/>.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
        /// <seealso cref="mpfr_fscanf"/>
        /// <seealso cref="mpfr_scanf"/>
        /// <seealso cref="mpfr_vsscanf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MPFR - Formatted Input Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MPFR - Formatted Input Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// mpz_t z = "0";
        /// mpq_t q = "0";
        /// mpf_t f = "0";
        /// ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
        /// ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
        /// ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_sscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
        /// 
        /// Assert.IsTrue(z.ToString() == "123456");
        /// Assert.IsTrue(q.ToString() == "123/456");
        /// Assert.IsTrue(f.ToString() == "0.12345e11");
        /// Assert.IsTrue(c.Value == 'A');
        /// Assert.IsTrue(zt.Value == 10);
        /// Assert.IsTrue(dbl.Value == 1.0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim z As mpz_t = "0"
        /// Dim q As mpq_t = "0"
        /// Dim f As mpf_t = "0"
        /// Dim c As New ptr(Of[Char])("0"C)
        /// Dim zt As New ptr(Of mp_size_t)(0)
        /// Dim dbl As New ptr(Of[Double])(0)
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_sscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
        /// 
        /// Assert.IsTrue(z.ToString() = "123456")
        /// Assert.IsTrue(q.ToString() = "123/456")
        /// Assert.IsTrue(f.ToString() = "0.12345e11")
        /// Assert.IsTrue(c.Value = "A"C)
        /// Assert.IsTrue(zt.Value = 10)
        /// Assert.IsTrue(dbl.Value = 1.0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_sscanf(/*const*/ string /*char **/ s, /*const*/ string /*char **/ fmt, params object[] /*...*/ ap)
        {
            return mpfr_vsscanf(s, fmt, ap);
        }

        /// <summary>
        /// Read from the stream <paramref name="fp"/>.
        /// </summary>
        /// <param name="fp">File stream.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
        /// <seealso cref="mpfr_fscanf"/>
        /// <seealso cref="mpfr_vscanf"/>
        /// <seealso cref="mpfr_vsscanf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MPFR - Formatted Input Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MPFR - Formatted Input Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create unique filename and stream pointer.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// 
        /// mpz_t z = "0";
        /// mpq_t q = "0";
        /// mpf_t f = "0";
        /// ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
        /// ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
        /// ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
        /// 
        /// // Write string to file, and then read values from it.
        /// System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000");
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpfr_vfscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert values read.
        /// Assert.IsTrue(z.ToString() == "123456");
        /// Assert.IsTrue(q.ToString() == "123/456");
        /// Assert.IsTrue(f.ToString() == "0.12345e11");
        /// Assert.IsTrue(c.Value == 'A');
        /// Assert.IsTrue(zt.Value == 10);
        /// Assert.IsTrue(dbl.Value == 1.0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create unique filename and stream pointer.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// Dim stream As New ptr(Of FILE)()
        /// 
        /// Dim z As mpz_t = "0"
        /// Dim q As mpq_t = "0"
        /// Dim f As mpf_t = "0"
        /// Dim c As New ptr(Of[Char])("0"C)
        /// Dim zt As New ptr(Of mp_size_t)(0)
        /// Dim dbl As New ptr(Of[Double])(0)
        /// 
        /// ' Write string to file, and then read values from it.
        /// System.IO.File.WriteAllText(pathname, "123456 7B/1C8 1.234500e+10 A 10 1.000000")
        /// _wfopen_s(stream.Value.Value, pathname, "r")
        /// Assert.IsTrue(mpfr_lib.mpfr_vfscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert values read.
        /// Assert.IsTrue(z.ToString() = "123456")
        /// Assert.IsTrue(q.ToString() = "123/456")
        /// Assert.IsTrue(f.ToString() = "0.12345e11")
        /// Assert.IsTrue(c.Value = "A"C)
        /// Assert.IsTrue(zt.Value = 10)
        /// Assert.IsTrue(dbl.Value = 1.0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vfscanf(ptr<FILE> /*FILE **/ fp, /*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (fp == null) throw new ArgumentNullException("fp");
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result = SafeNativeMethods.__mpfr_vfscanf(fp.Value.Value, format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        /// <summary>
        /// Read from the standard input <c>stdin</c>.
        /// </summary>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
        /// <seealso cref="mpfr_scanf"/>
        /// <seealso cref="mpfr_vfscanf"/>
        /// <seealso cref="mpfr_vsscanf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MPFR - Formatted Input Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MPFR - Formatted Input Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// mpz_t z = "0";
        /// mpq_t q = "0";
        /// mpf_t f = "0";
        /// ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
        /// ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
        /// ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
        /// 
        /// // Read values from standard input.
        /// Assert.IsTrue(mpfr_lib.mpfr_vscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
        /// 
        /// // Assert values read.
        /// Assert.IsTrue(z.ToString() == "123456");
        /// Assert.IsTrue(q.ToString() == "123/456");
        /// Assert.IsTrue(f.ToString() == "0.12345e11");
        /// Assert.IsTrue(c.Value == 'A');
        /// Assert.IsTrue(zt.Value == 10);
        /// Assert.IsTrue(dbl.Value == 1.0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim z As mpz_t = "0"
        /// Dim q As mpq_t = "0"
        /// Dim f As mpf_t = "0"
        /// Dim c As New ptr(Of[Char])("0"C)
        /// Dim zt As New ptr(Of mp_size_t)(0)
        /// Dim dbl As New ptr(Of[Double])(0)
        /// 
        /// ' Read values from standard input.
        /// Assert.IsTrue(mpfr_lib.mpfr_vscanf(stream, "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
        /// 
        /// ' Assert values read.
        /// Assert.IsTrue(z.ToString() = "123456")
        /// Assert.IsTrue(q.ToString() = "123/456")
        /// Assert.IsTrue(f.ToString() = "0.12345e11")
        /// Assert.IsTrue(c.Value = "A"C)
        /// Assert.IsTrue(zt.Value = 10)
        /// Assert.IsTrue(dbl.Value = 1.0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vscanf(/*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            int result = SafeNativeMethods.__mpfr_vscanf(format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            return result;
        }

        /// <summary>
        /// Read from a null-terminated string <paramref name="s"/>.
        /// </summary>
        /// <param name="s">A string.</param>
        /// <param name="fmt">Format string. See <a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">Formatted Input Strings</a>.</param>
        /// <param name="ap">Arguments.</param>
        /// <returns>The return value the number of fields successfully parsed and stored. ‘%n’ fields and fields read but suppressed by ‘*’ don’t count towards the return value.</returns>
        /// <seealso cref="mpfr_sscanf"/>
        /// <seealso cref="mpfr_vfscanf"/>
        /// <seealso cref="mpfr_vscanf"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Functions.html#Formatted-Input-Functions">GNU MPFR - Formatted Input Functions</a></seealso>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Formatted-Input-Strings.html#Formatted-Input-Strings">GNU MPFR - Formatted Input Strings</a></seealso>
        /// <example>
        /// <code language="C#">
        /// mpz_t z = "0";
        /// mpq_t q = "0";
        /// mpf_t f = "0";
        /// ptr&lt;Char&gt; c = new ptr&lt;Char&gt;('0');
        /// ptr&lt;mp_size_t&gt; zt = new ptr&lt;mp_size_t&gt;(0);
        /// ptr&lt;Double&gt; dbl = new ptr&lt;Double&gt;(0);
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_vsscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) == 6);
        /// 
        /// Assert.IsTrue(z.ToString() == "123456");
        /// Assert.IsTrue(q.ToString() == "123/456");
        /// Assert.IsTrue(f.ToString() == "0.12345e11");
        /// Assert.IsTrue(c.Value == 'A');
        /// Assert.IsTrue(zt.Value == 10);
        /// Assert.IsTrue(dbl.Value == 1.0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z);
        /// mpfr_lib.mpq_clear(q);
        /// mpfr_lib.mpf_clear(f);
        /// </code> 
        /// <code language="VB.NET">
        /// Dim z As mpz_t = "0"
        /// Dim q As mpq_t = "0"
        /// Dim f As mpf_t = "0"
        /// Dim c As New ptr(Of[Char])("0"C)
        /// Dim zt As New ptr(Of mp_size_t)(0)
        /// Dim dbl As New ptr(Of[Double])(0)
        /// 
        /// Assert.IsTrue(mpfr_lib.mpfr_vsscanf("123456 7B/1C8 1.234500e+10 A 10 1.000000", "%Zd %QX %Fe %hhc %d %lf", z, q, f, c, zt, dbl) = 6)
        /// 
        /// Assert.IsTrue(z.ToString() = "123456")
        /// Assert.IsTrue(q.ToString() = "123/456")
        /// Assert.IsTrue(f.ToString() = "0.12345e11")
        /// Assert.IsTrue(c.Value = "A"C)
        /// Assert.IsTrue(zt.Value = 10)
        /// Assert.IsTrue(dbl.Value = 1.0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.mpz_clear(z)
        /// mpfr_lib.mpq_clear(q)
        /// mpfr_lib.mpf_clear(f)
        /// </code> 
        /// </example>
        public static int mpfr_vsscanf(/*const*/ string /*char **/ s, /*const*/ string /*char **/ fmt, params object[] /*va_list*/ ap)
        {
            if (s == null) throw new ArgumentNullException("s");
            if (fmt == null) throw new ArgumentNullException("fmt");
            if (ap == null) throw new ArgumentNullException("ap");
            va_list va_args = new va_list(ap);
            char_ptr format = new char_ptr(fmt);
            char_ptr buf = new char_ptr(s);
            int result = SafeNativeMethods.__mpfr_vsscanf(buf.ToIntPtr(), format.ToIntPtr(), va_args.ToIntPtr());
            va_args.RetrieveArgumentValues();
            mpfr_lib.free(format);
            mpfr_lib.free(buf);
            return result;
        }

        #endregion

        #region "Integer (i.e. Z) routines."

        /// <summary>
        /// Change the space for <paramref name="integer"/> to <paramref name="new_alloc"/> limbs.
        /// </summary>
        /// <param name="integer">The integer to resize.</param>
        /// <param name="new_alloc">The new number of limbs.</param>
        /// <remarks>
        /// <para>
        /// The value in <paramref name="integer"/> is preserved if it fits, or is set to 0 if not.
        /// </para>
        /// <para>
        /// <see cref="mpz_realloc2"/> is the preferred way to accomplish allocation changes like this.
        /// <see cref="mpz_realloc2"/> and <see cref="_mpz_realloc"/> are the same except that
        /// <see cref="_mpz_realloc"/> takes its size in limbs.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_realloc2"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x to a 77-bit integer.
        /// char_ptr value = new char_ptr("1000 0000 0000 0000 0000");
        /// mpfr_lib.mpz_set_str(x, value, 16);
        /// 
        /// // Resize x to 50 limbs, and assert that its value has not changed.
        /// mpfr_lib._mpz_realloc(x, 50);
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, 16, x);
        /// Assert.IsTrue(s.ToString() == "1000 0000 0000 0000 0000".Replace(" ", ""));
        /// 
        /// // Resize x to 1 limb, and assert that its value has changed to 0.
        /// mpfr_lib._mpz_realloc(x, 1);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 0);
        /// 
        /// // Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(value);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x to a 77-bit integer.
        /// Dim value As New char_ptr("1000 0000 0000 0000 0000")
        /// mpfr_lib.mpz_set_str(x, value, 16)
        /// 
        /// ' Resize x to 50 limbs, and assert that its value has not changed.
        /// mpfr_lib._mpz_realloc(x, 50)
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 16, x)
        /// Assert.IsTrue(s.ToString() = "1000 0000 0000 0000 0000".Replace(" ", ""))
        /// 
        /// ' Resize x to 1 limb, and assert that its value has changed to 0.
        /// mpfr_lib._mpz_realloc(x, 1)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(value)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static void _mpz_realloc(mpz_t integer, mp_size_t new_alloc)
        {
            if (integer == null) throw new ArgumentNullException("integer");
            SafeNativeMethods.__mpfrz_realloc(integer.ToIntPtr(), new_alloc);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the absolute value of <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = |x|.
        /// mpfr_lib.mpz_abs(z, x);
        /// 
        /// // Assert that z is |x|.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 10000);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = |x|.
        /// mpfr_lib.mpz_abs(z, x)
        /// 
        /// ' Assert that z is |x|.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 10000)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_abs(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_abs(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add_ui"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 12222.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 12222U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x + y.
        /// mpfr_lib.mpz_add(z, x, y);
        /// 
        /// // Assert that z is the sum of x and y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(z) == 22222U);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 12222.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x + y.
        /// mpfr_lib.mpz_add(z, x, y)
        /// 
        /// ' Assert that z is the sum of x and y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(z) = 22222UI)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_add(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_add(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 0.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Increment x twice by 101999.
        /// mpfr_lib.mpz_add_ui(x, x, 101999U);
        /// mpfr_lib.mpz_add_ui(x, x, 101999U);
        /// 
        /// // Assert that x is 203998.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) == 203998U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 0.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Increment x twice by 101999.
        /// mpfr_lib.mpz_add_ui(x, x, 101999UI)
        /// mpfr_lib.mpz_add_ui(x, x, 101999UI)
        /// 
        /// ' Assert that x is 203998.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) = 203998UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_add_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_add_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="rop"/> + <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul_ui"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 12222.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 12222U);
        /// 
        /// // Create, initialize, and set the value of z to 20000.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(z, 20000U);
        /// 
        /// // Set z += x * y.
        /// mpfr_lib.mpz_addmul(z, x, y);
        /// 
        /// // Assert that z has been incremented by 10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 20000U + 10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 12222.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of z to 20000.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(z, 20000UI)
        /// 
        /// ' Set z += x * y.
        /// mpfr_lib.mpz_addmul(z, x, y)
        /// 
        /// ' Assert that z has been incremented by 10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 20000UI + 10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_addmul(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_addmul(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="rop"/> + <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of z to 20000.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(z, 20000);
        /// 
        /// // Set z += x * 12222.
        /// mpfr_lib.mpz_addmul_ui(z, x, 12222U);
        /// 
        /// // Assert that z has been incremented by -10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 20000 + -10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of z to 20000.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(z, 20000)
        /// 
        /// ' Set z += x * 12222.
        /// mpfr_lib.mpz_addmul_ui(z, x, 12222UI)
        /// 
        /// ' Assert that z has been incremented by -10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 20000 + -10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_addmul_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_addmul_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> bitwise-and <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the bitwise and of op1 and op2.
        /// mpfr_lib.mpz_and(rop, op1, op2);
        /// 
        /// // Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 6);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the bitwise and of op1 and op2.
        /// mpfr_lib.mpz_and(rop, op1, op2)
        /// 
        /// ' Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 6)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_and(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_and(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compute the binomial coefficient <paramref name="n"/> over <paramref name="k"/> and store the result in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="n">The first operand integer.</param>
        /// <param name="k">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// Negative values of n are supported by <see cref="mpz_bin_ui"/>, using the identity
        /// bin(-<paramref name="n"/>, <paramref name="k"/>) = (-1)^<paramref name="k"/> * bin(<paramref name="n"/> + <paramref name="k"/> - 1, <paramref name="k"/>),
        /// see Knuth volume 1 section 1.2.6 part G.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_bin_uiui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 4.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 4);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the binomial coefficient (n:2).
        /// mpfr_lib.mpz_bin_ui(rop, n, 2U);
        /// 
        /// // Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 6);
        /// 
        /// // Release unmanaged memory allocated for n and rop.
        /// mpfr_lib.mpz_clears(n, rop, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 4.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 4)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the binomial coefficient (n:2).
        /// mpfr_lib.mpz_bin_ui(rop, n, 2UI)
        /// 
        /// ' Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 6)
        /// 
        /// ' Release unmanaged memory allocated for n and rop.
        /// mpfr_lib.mpz_clears(n, rop, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_bin_ui(mpz_t rop, /*const*/ mpz_t n, uint /*unsigned long int*/ k)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_bin_ui(rop.ToIntPtr(), n.ToIntPtr(), k);
        }

        /// <summary>
        /// Compute the binomial coefficient <paramref name="n"/> over <paramref name="k"/> and store the result in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="n">The first operand integer.</param>
        /// <param name="k">The second operand integer.</param>
        /// <seealso cref="mpz_bin_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the binomial coefficient (4:2).
        /// mpfr_lib.mpz_bin_uiui(rop, 4U, 2U);
        /// 
        /// // Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 6);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the binomial coefficient (4:2).
        /// mpfr_lib.mpz_bin_uiui(rop, 4UI, 2UI)
        /// 
        /// ' Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 6)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_bin_uiui(mpz_t rop, uint /*unsigned long int*/ n, uint /*unsigned long int*/ k)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_bin_uiui(rop.ToIntPtr(), n, k);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = ceiling(n / d).
        /// mpfr_lib.mpz_cdiv_q(q, n, d);
        /// 
        /// // Assert that q is ceiling(10000 / 3).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3334);
        /// 
        /// // Release unmanaged memory allocated for n, d, and q.
        /// mpfr_lib.mpz_clears(n, d, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = ceiling(n / d).
        /// mpfr_lib.mpz_cdiv_q(q, n, d)
        /// 
        /// ' Assert that q is ceiling(10000 / 3).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3334)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and q.
        /// mpfr_lib.mpz_clears(n, d, q, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_cdiv_q(mpz_t q, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_cdiv_q(q.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / 2^<paramref name="b"/>).
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator.</param>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10001);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = ceiling(n / 2^2).
        /// mpfr_lib.mpz_cdiv_q_2exp(q, n, 2U);
        /// 
        /// // Assert that q is ceiling(10001 / 4).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 2501);
        /// 
        /// // Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10001)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = ceiling(n / 2^2).
        /// mpfr_lib.mpz_cdiv_q_2exp(q, n, 2UI)
        /// 
        /// ' Assert that q is ceiling(10001 / 4).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 2501)
        /// 
        /// ' Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_cdiv_q_2exp(mpz_t q, /*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_cdiv_q_2exp(q.ToIntPtr(), n.ToIntPtr(), b);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>), and return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.</returns>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = ceiling(n / 3) and return r = n - 3 * q.
        /// // Assert q and r values.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_q_ui(q, n, 3U) == 2U);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3334);
        /// 
        /// // Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = ceiling(n / 3) and return r = n - 3 * q.
        /// ' Assert q and r values.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_q_ui(q, n, 3UI) = 2UI)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3334)
        /// 
        /// ' Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, Nothing)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_cdiv_q_ui(mpz_t q, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_cdiv_q_ui(q.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>), and set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the values of q and r to 0.
        /// mpz_t q = new mpz_t();
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_inits(q, r, null);
        /// 
        /// // Set q = ceiling(n / 3) and r = n - d * q.
        /// mpfr_lib.mpz_cdiv_qr(q, r, n, d);
        /// 
        /// // Assert that q is 3334, and that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3334);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == -2);
        /// 
        /// // Release unmanaged memory allocated for n, d, q, and r.
        /// mpfr_lib.mpz_clears(n, d, q, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the values of q and r to 0.
        /// Dim q As New mpz_t()
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_inits(q, r, Nothing)
        /// 
        ///  Set q = ceiling(n / 3) and r = n - d * q.
        /// mpfr_lib.mpz_cdiv_qr(q, r, n, d)
        /// 
        /// ' Assert that q is 3334, and that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3334)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = -2)
        /// 
        /// ' Release unmanaged memory allocated for n, d, q, and r.
        /// mpfr_lib.mpz_clears(n, d, q, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_cdiv_qr(mpz_t q, mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_cdiv_qr(q.ToIntPtr(), r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set quotient <paramref name="q"/> to ceiling(<paramref name="n"/> / <paramref name="d"/>), set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>, and return | <paramref name="r"/> |.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return | <paramref name="r"/> |.</returns>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the values of q and r to 0.
        /// mpz_t q = new mpz_t();
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_inits(q, r, null);
        /// 
        /// // Set q = ceiling(n / 3), r = n - d * q, and return r.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_qr_ui(q, r, n, 3U) == 2U);
        /// 
        /// // Assert that q is 3334, and that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3334);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == -2);
        /// 
        /// // Release unmanaged memory allocated for n, q, and r.
        /// mpfr_lib.mpz_clears(n, q, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the values of q and r to 0.
        /// Dim q As New mpz_t()
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_inits(q, r, Nothing)
        /// 
        /// ' Set q = ceiling(n / 3), r = n - d * q, and return r.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_qr_ui(q, r, n, 3UI) = 2UI)
        /// 
        /// ' Assert that q is 3334, and that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3334)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = -2)
        /// 
        /// ' Release unmanaged memory allocated for n, q, and r.
        /// mpfr_lib.mpz_clears(n, q, r, Nothing)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_cdiv_qr_ui(mpz_t q, mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_cdiv_qr_ui(q.ToIntPtr(), r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = ceiling(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - d * ceiling(n / d).
        /// mpfr_lib.mpz_cdiv_r(r, n, d);
        /// 
        /// // Assert that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == -2);
        /// 
        /// // Release unmanaged memory allocated for n, d, and r.
        /// mpfr_lib.mpz_clears(n, d, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - d * ceiling(n / d).
        /// mpfr_lib.mpz_cdiv_r(r, n, d)
        /// 
        /// ' Assert that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = -2)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and r.
        /// mpfr_lib.mpz_clears(n, d, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_cdiv_r(mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_cdiv_r(r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * 2^<paramref name="b"/> where q = ceiling(<paramref name="n"/> / 2^<paramref name="b"/>).
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator.</param>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10001);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - 2^2 * ceiling(n / 2^2)
        /// mpfr_lib.mpz_cdiv_r_2exp(r, n, 2U);
        /// 
        /// // Assert that r is -3.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == -3);
        /// 
        /// // Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10001)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// ' Set r = n - 2^2 * ceiling(n / 2^2)
        /// mpfr_lib.mpz_cdiv_r_2exp(r, n, 2UI)
        /// 
        /// ' Assert that r is -3.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = -3)
        /// 
        /// ' Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_cdiv_r_2exp(mpz_t r, /*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_cdiv_r_2exp(r.ToIntPtr(), n.ToIntPtr(), b);
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = ceiling(<paramref name="n"/> / <paramref name="d"/>), and return | <paramref name="r"/> |.
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return | <paramref name="r"/> |.</returns>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - 3 * ceiling(n / 3), and return |r|.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_r_ui(r, n, 3U) == 2U);
        /// 
        /// // Assert that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == -2);
        /// 
        /// // Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - 3 * ceiling(n / 3), and return |r|.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_r_ui(r, n, 3UI) = 2UI)
        /// 
        /// ' Assert that r is -2.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = -2)
        /// 
        /// ' Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, Nothing)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_cdiv_r_ui(mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_cdiv_r_ui(r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Return the remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = ceiling(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>The remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = ceiling(<paramref name="n"/> / <paramref name="d"/>).</returns>
        /// <seealso cref="mpz_cdiv_q"/>
        /// <seealso cref="mpz_cdiv_r"/>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_cdiv_q_ui"/>
        /// <seealso cref="mpz_cdiv_r_ui"/>
        /// <seealso cref="mpz_cdiv_qr_ui"/>
        /// <seealso cref="mpz_cdiv_q_2exp"/>
        /// <seealso cref="mpz_cdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Assert that returned value is |n - 3 * ceiling(n / 3)|.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_ui(n, 3U) == 2U);
        /// 
        /// // Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Assert that returned value is |n - 3 * ceiling(n / 3)|.
        /// Assert.IsTrue(mpfr_lib.mpz_cdiv_ui(n, 3UI) = 2UI)
        /// 
        /// ' Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n)
        /// </code> 
        /// </example>
        public static ulong mpz_cdiv_ui(/*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_cdiv_ui(n.ToIntPtr(), d);
        }

        /// <summary>
        /// Free the space occupied by <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The integer.</param>
        /// <remarks>
        /// <para>
        /// Call this function for all <see cref="mpz_t"/> variables when you are done with them.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_clears"/>
        /// <seealso cref="mpz_init"/>
        /// <seealso cref="mpz_inits"/>
        /// <seealso cref="mpz_init2"/>
        /// <seealso cref="mpz_realloc2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MPFR - Initializing Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Assert that the value of x is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) == 0U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Assert that the value of x is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) = 0UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_clear(mpz_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_clear(x.ToIntPtr());
            mpfr_lib.free(new void_ptr(x.ToIntPtr()));
        }

        /// <summary>
        /// Free the space occupied by a NULL-terminated list of <see cref="mpz_t"/> variables.
        /// </summary>
        /// <param name="x">A NULL-terminated list of <see cref="mpz_t"/> variables.</param>
        /// <seealso cref="mpz_clear"/>
        /// <seealso cref="mpz_init"/>
        /// <seealso cref="mpz_inits"/>
        /// <seealso cref="mpz_init2"/>
        /// <seealso cref="mpz_realloc2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MPFR - Initializing Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new integers x1, x2 and x3.
        /// mpz_t x1 = new mpz_t();
        /// mpz_t x2 = new mpz_t();
        /// mpz_t x3 = new mpz_t();
        /// 
        /// // Initialize the integers.
        /// mpfr_lib.mpz_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x1) == 0);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x2) == 0);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x3) == 0);
        /// 
        /// // Release unmanaged memory allocated for the integers.
        /// mpfr_lib.mpz_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new integers x1, x2 and x3.
        /// Dim x1 As New mpz_t()
        /// Dim x2 As New mpz_t()
        /// Dim x3 As New mpz_t()
        /// 
        /// ' Initialize the integers.
        /// mpfr_lib.mpz_inits(x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x1) = 0)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x2) = 0)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x3) = 0)
        /// 
        /// ' Release unmanaged memory allocated for the integers.
        /// mpfr_lib.mpz_clears(x1, x2, x3, Nothing) 
        /// </code> 
        /// </example>
        public static void mpz_clears(params mpz_t[] x)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpz_t a in x) { if (a != null) mpz_clear(a); }
        }

        /// <summary>
        /// Clear bit <paramref name="bit_index"/> in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="bit_index">The index of the bit to clear.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 70.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(rop, 70);
        /// 
        /// // Clear bit 3 of rop.
        /// mpfr_lib.mpz_clrbit(rop, 3U);
        /// 
        /// // Assert that rop is 70.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 70);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 70.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(rop, 70)
        /// 
        /// ' Clear bit 3 of rop.
        /// mpfr_lib.mpz_clrbit(rop, 3UI)
        /// 
        /// ' Assert that rop is 70.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 70)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_clrbit(mpz_t rop, mp_bitcnt_t bit_index)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_clrbit(rop.ToIntPtr(), bit_index);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_cmpabs_ui"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Assert that op1 &lt; op2.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp(op1, op2) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpz_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Assert that op1 &lt; op2.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp(op1, op2) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpz_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_cmp(/*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrz_cmp(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// <see cref="mpz_cmp_d"/> can be called with an infinity (see <see cref="double.PositiveInfinity"/> or <see cref="double.NegativeInfinity"/>),
        /// but results are undefined for a <see cref="double.NaN"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_cmpabs_ui"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Assert that op1 &lt; 70.0.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_d(op1, 70.0) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Assert that op1 &lt; 70.0.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_d(op1, 70.0) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1)
        /// </code> 
        /// </example>
        public static int mpz_cmp_d(/*const*/ mpz_t op1, double op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrz_cmp_d(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_cmpabs_ui"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Assert that op1 &lt; 70.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_si(op1, 70) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Assert that op1 &lt; 70.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_si(op1, 70) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1)
        /// </code> 
        /// </example>
        public static int mpz_cmp_si(/*const*/ mpz_t op1, int /*long int*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrz_cmp_si(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, or a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Assert that op1 &lt; 70.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_ui(op1, 70U) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Assert that op1 &lt; 70.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_ui(op1, 70UI) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1)
        /// </code> 
        /// </example>
        public static int mpz_cmp_ui(/*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrz_cmp_ui(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare the absolute values of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if | <paramref name="op1"/> | &gt; | <paramref name="op2"/> |, zero if | <paramref name="op1"/> | = | <paramref name="op2"/> |, or a negative value if | <paramref name="op1"/> | &lt; | <paramref name="op2"/> |.</returns>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_cmpabs_ui"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to -63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op1, -63);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Assert that |op1| &lt; |op2|.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp(op1, op2) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpz_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to -63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op1, -63)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Assert that |op1| &lt; |op2|.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp(op1, op2) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpz_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_cmpabs(/*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrz_cmpabs(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare the absolute values of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if | <paramref name="op1"/> | &gt; | <paramref name="op2"/> |, zero if | <paramref name="op1"/> | = | <paramref name="op2"/> |, or a negative value if | <paramref name="op1"/> | &lt; | <paramref name="op2"/> |.</returns>
        /// <remarks>
        /// <para>
        /// <see cref="mpz_cmpabs_d"/> can be called with an infinity (see <see cref="double.PositiveInfinity"/> or <see cref="double.NegativeInfinity"/>),
        /// but results are undefined for a <see cref="double.NaN"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_ui"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to -63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op1, -63);
        /// 
        /// // Assert that |op1| &lt; |-70.0|.
        /// Assert.IsTrue(mpfr_lib.mpz_cmpabs_d(op1, -70.0) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to -63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op1, -63)
        /// 
        /// ' Assert that |op1| &lt; |-70.0|.
        /// Assert.IsTrue(mpfr_lib.mpz_cmpabs_d(op1, -70.0) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1)
        /// </code> 
        /// </example>
        public static int mpz_cmpabs_d(/*const*/ mpz_t op1, double op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrz_cmpabs_d(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare the absolute values of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>Return a positive value if | <paramref name="op1"/> | &gt; | <paramref name="op2"/> |, zero if | <paramref name="op1"/> | = | <paramref name="op2"/> |, or a negative value if | <paramref name="op1"/> | &lt; | <paramref name="op2"/> |.</returns>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to -63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op1, -63);
        /// 
        /// // Assert that |op1| &lt; |70|.
        /// Assert.IsTrue(mpfr_lib.mpz_cmpabs_ui(op1, 70U) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpz_cmpabs_ui(/*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrz_cmpabs_ui(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the one’s complement of <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 63.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 63U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the one's complement of op.
        /// mpfr_lib.mpz_com(rop, op);
        /// 
        /// // Assert that rop is -64.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == -64);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpz_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 63.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 63UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the one's complement of op.
        /// mpfr_lib.mpz_com(rop, op)
        /// 
        /// ' Assert that rop is -64.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = -64)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpz_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_com(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_com(rop.ToIntPtr(), op.ToIntPtr());
        }


        /// <summary>
        /// Complement bit <paramref name="bit_index"/> in <paramref name="rop"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="bit_index">The index of the bit to comlpement.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 70.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(rop, 70);
        /// 
        /// // Complement bit 3 of rop.
        /// mpfr_lib.mpz_combit(rop, 3U);
        /// 
        /// // Assert that rop is 78.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 78);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 70.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(rop, 70)
        /// 
        /// ' Complement bit 3 of rop.
        /// mpfr_lib.mpz_combit(rop, 3UI)
        /// 
        /// ' Assert that rop is 78.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 78)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// </code> 
        /// </example>
        public static void mpz_combit(mpz_t rop, mp_bitcnt_t bit_index)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_combit(rop.ToIntPtr(), bit_index);
        }

        /// <summary>
        /// Return non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.
        /// </summary>
        /// <param name="n">An operand integer.</param>
        /// <param name="c">The remainder of the division by <paramref name="d"/>.</param>
        /// <param name="d">The divisor operand integer.</param>
        /// <returns>Non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> is congruent to <paramref name="c"/> mod <paramref name="d"/> if there exists an integer q
        /// satisfying <paramref name="n"/> = <paramref name="c"/> + q * <paramref name="d"/>.
        /// Unlike the other division functions, <paramref name="d"/> = 0 is accepted and following the rule it can be seen
        /// that <paramref name="n"/> and <paramref name="c"/> are considered congruent mod 0 only when exactly equal.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_2exp_p"/>
        /// <seealso cref="mpz_congruent_ui_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(n, 10000U);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(d, 3U);
        /// 
        /// // Create, initialize, and set the value of c to 1.
        /// mpz_t c = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(c, 1U);
        /// 
        /// // Assert that n is congruent to c mod d.
        /// Assert.IsTrue(mpfr_lib.mpz_congruent_p(n, c, d) > 0);
        /// 
        /// // Release unmanaged memory allocated for n, d, and c.
        /// mpfr_lib.mpz_clears(n, d, c, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(n, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(d, 3UI)
        /// 
        /// ' Create, initialize, and set the value of c to 1.
        /// Dim c As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(c, 1UI)
        /// 
        /// ' Assert that n is congruent to c mod d.
        /// Assert.IsTrue(mpfr_lib.mpz_congruent_p(n, c, d) > 0)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and c.
        /// mpfr_lib.mpz_clears(n, d, c, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_congruent_p(/*const*/ mpz_t n, /*const*/ mpz_t c, /*const*/ mpz_t d)
        {
            if (n == null) throw new ArgumentNullException("n");
            if (c == null) throw new ArgumentNullException("c");
            if (d == null) throw new ArgumentNullException("d");
            return SafeNativeMethods.__mpfrz_congruent_p(n.ToIntPtr(), c.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo 2^<paramref name="b"/>.
        /// </summary>
        /// <param name="n">An operand integer.</param>
        /// <param name="c">The remainder of the division by 2^<paramref name="b"/>.</param>
        /// <param name="b">The exponent of the power of two divisor.</param>
        /// <returns>Non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo 2^<paramref name="b"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> is congruent to <paramref name="c"/> mod 2^<paramref name="b"/> if there exists an integer q
        /// satisfying <paramref name="n"/> = <paramref name="c"/> + q * 2^<paramref name="b"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_congruent_ui_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(n, 10001U);
        /// 
        /// // Create, initialize, and set the value of b to 1.
        /// mpz_t c = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(c, 1U);
        /// 
        /// // Assert that n is congruent to c mod 2^3.
        /// Assert.IsTrue(mpfr_lib.mpz_congruent_2exp_p(n, c, 3U) > 0);
        /// 
        /// // Release unmanaged memory allocated for n and c.
        /// mpfr_lib.mpz_clears(n, c, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(n, 10001UI)
        /// 
        /// ' Create, initialize, and set the value of b to 1.
        /// Dim c As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(c, 1UI)
        /// 
        /// ' Assert that n is congruent to c mod 2^3.
        /// Assert.IsTrue(mpfr_lib.mpz_congruent_2exp_p(n, c, 3UI) > 0)
        /// 
        /// ' Release unmanaged memory allocated for n and c.
        /// mpfr_lib.mpz_clears(n, c, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_congruent_2exp_p(/*const*/ mpz_t n, /*const*/ mpz_t c, mp_bitcnt_t b)
        {
            if (n == null) throw new ArgumentNullException("n");
            if (c == null) throw new ArgumentNullException("c");
            return SafeNativeMethods.__mpfrz_congruent_2exp_p(n.ToIntPtr(), c.ToIntPtr(), b);
        }

        /// <summary>
        /// Return non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.
        /// </summary>
        /// <param name="n">An operand integer.</param>
        /// <param name="c">The remainder of the division by <paramref name="d"/>.</param>
        /// <param name="d">The divisor operand integer.</param>
        /// <returns>Non-zero if <paramref name="n"/> is congruent to <paramref name="c"/> modulo <paramref name="d"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> is congruent to <paramref name="c"/> mod <paramref name="d"/> if there exists an integer q
        /// satisfying <paramref name="n"/> = <paramref name="c"/> + q * <paramref name="d"/>.
        /// Unlike the other division functions, <paramref name="d"/> = 0 is accepted and following the rule it can be seen
        /// that <paramref name="n"/> and <paramref name="c"/> are considered congruent mod 0 only when exactly equal.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_2exp_p"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(n, 10000U);
        /// 
        /// // Assert that n is congruent to 1 mod 3.
        /// Assert.IsTrue(mpfr_lib.mpz_congruent_ui_p(n, 1U, 3U) > 0);
        /// 
        /// // Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(n, 10000UI)
        /// 
        /// ' Assert that n is congruent to 1 mod 3.
        /// Assert.IsTrue(mpfr_lib.mpz_congruent_ui_p(n, 1UI, 3UI) > 0)
        /// 
        /// ' Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n)
        /// </code> 
        /// </example>
        public static int mpz_congruent_ui_p(/*const*/ mpz_t n, uint /*unsigned long int*/ c, uint /*unsigned long int*/ d)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_congruent_ui_p(n.ToIntPtr(), c, d);
        }

        /// <summary>
        /// Set <paramref name="q"/> to <paramref name="n"/> / <paramref name="d"/> when it is known in advance that <paramref name="d"/> divides <paramref name="n"/>. 
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact_ui"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 5.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 5U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x / y.
        /// mpfr_lib.mpz_divexact(z, x, y);
        /// 
        /// // Assert that z is 2000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 2000);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 5.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 5UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x / y.
        /// mpfr_lib.mpz_divexact(z, x, y)
        /// 
        /// ' Assert that z is 2000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 2000)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_divexact(mpz_t q, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_divexact(q.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="q"/> to <paramref name="n"/> / <paramref name="d"/> when it is known in advance that <paramref name="d"/> divides <paramref name="n"/>. 
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x / 5.
        /// mpfr_lib.mpz_divexact_ui(z, x, 5U);
        /// 
        /// // Assert that z is 2000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 2000);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x / 5.
        /// mpfr_lib.mpz_divexact_ui(z, x, 5UI)
        /// 
        /// ' Assert that z is 2000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 2000)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_divexact_ui(mpz_t q, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_divexact_ui(q.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Return non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.
        /// </summary>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> is divisible by <paramref name="d"/> if there exists an integer q
        /// satisfying <paramref name="n"/> = q * <paramref name="d"/>. Unlike the other division functions,
        /// <paramref name="d"/> = 0 is accepted and following the rule it can be seen that only 0 is
        /// considered divisible by 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_2exp_p"/>
        /// <seealso cref="mpz_divisible_ui_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 5.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 5U);
        /// 
        /// // Assert that x is divisible by y.
        /// Assert.IsTrue(mpfr_lib.mpz_divisible_p(x, y) > 0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 5.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 5UI)
        /// 
        /// ' Assert that x is divisible by y.
        /// Assert.IsTrue(mpfr_lib.mpz_divisible_p(x, y) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_divisible_p(/*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            return SafeNativeMethods.__mpfrz_divisible_p(n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.
        /// </summary>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Non-zero if <paramref name="n"/> is exactly divisible by <paramref name="d"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> is divisible by <paramref name="d"/> if there exists an integer q
        /// satisfying <paramref name="n"/> = q * <paramref name="d"/>. Unlike the other division functions,
        /// <paramref name="d"/> = 0 is accepted and following the rule it can be seen that only 0 is
        /// considered divisible by 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_2exp_p"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Assert that x is divisible by 5.
        /// Assert.IsTrue(mpfr_lib.mpz_divisible_ui_p(x, 5U) > 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Assert that x is divisible by 5.
        /// Assert.IsTrue(mpfr_lib.mpz_divisible_ui_p(x, 5UI) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static int mpz_divisible_ui_p(/*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_divisible_ui_p(n.ToIntPtr(), d);
        }

        /// <summary>
        /// Return non-zero if <paramref name="n"/> is exactly divisible by 2^<paramref name="b"/>.
        /// </summary>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator integer.</param>
        /// <returns>Non-zero if <paramref name="n"/> is exactly divisible by 2^<paramref name="b"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="n"/> is divisible by 2^<paramref name="b"/> if there exists an integer q
        /// satisfying <paramref name="n"/> = q * 2^<paramref name="b"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_divisible_ui_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// Assert.IsTrue(mpfr_lib.mpz_divisible_2exp_p(x, 2U) > 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// Assert.IsTrue(mpfr_lib.mpz_divisible_2exp_p(x, 2UI) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static int mpz_divisible_2exp_p(/*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_divisible_2exp_p(n.ToIntPtr(), b);
        }

        /// <summary>
        /// Determine whether <paramref name="op"/> is even.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero if even, zero if odd.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 427295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 427295);
        /// 
        /// // Assert that op is not even but odd.
        /// Assert.IsTrue(mpfr_lib.mpz_even_p(op) == 0);
        /// Assert.IsTrue(mpfr_lib.mpz_odd_p(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 427295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 427295)
        /// 
        /// ' Assert that op is not even but odd.
        /// Assert.IsTrue(mpfr_lib.mpz_even_p(op) = 0)
        /// Assert.IsTrue(mpfr_lib.mpz_odd_p(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_even_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_size != 0 && (op._mp_d[0] & 1) == 0 ? 1 : 0;
        }

        /// <summary>
        /// Fill <paramref name="rop"/> with word data from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="countp">The number of words produced.</param>
        /// <param name="order">1 for most significant word first or -1 for least significant first.</param>
        /// <param name="size">The number of bytes in each word.</param>
        /// <param name="endian">1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</param>
        /// <param name="nails">The number of most significant bits to skip.</param>
        /// <param name="op">The operand integer.</param>
        /// <returns>Either <paramref name="rop"/> or the allocated block.</returns>
        /// <remarks>
        /// <para>
        /// The parameters specify the format of the data produced.
        /// Each word will be <paramref name="size"/> bytes and <paramref name="order"/> can be 1 for most significant word first
        /// or -1 for least significant first.
        /// Within each word <paramref name="endian"/> can be 1 for most significant byte first,
        /// -1 for least significant first, or 0 for the native endianness of the host CPU.
        /// The most significant <paramref name="nails"/> bits of each word are unused and set to zero,
        /// this can be 0 to produce full words. 
        /// </para>
        /// <para>
        /// The number of words produced is written to <paramref name="countp"/>, or <paramref name="countp"/> can be NULL to discard the count.
        /// <paramref name="rop"/> must have enough space for the data, or if <paramref name="rop"/> is NULL then a result array of the necessary
        /// size is allocated using the current MPFR allocation function 
        /// (see <a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a>).
        /// In either case the return value is the destination used, either <paramref name="rop"/> or the allocated block. 
        /// </para>
        /// <para>
        /// If <paramref name="op"/> is non-zero then the most significant word produced will be non-zero.
        /// If <paramref name="op"/> is zero then the count returned will be zero and nothing written to <paramref name="rop"/>.
        /// If <paramref name="rop"/> is NULL in this case, no block is allocated, just NULL is returned. 
        /// </para>
        /// <para>
        /// The sign of <paramref name="op"/> is ignored, just the absolute value is exported.
        /// An application can use <see cref="mpz_sgn"/> to get the sign and handle it as desired.
        /// (see <a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a>) 
        /// </para>
        /// <para>
        /// There are no data alignment restrictions on <paramref name="rop"/>, any address is allowed. 
        /// </para>
        /// <para>
        /// When an application is allocating space itself the required size can be determined with a calculation like the following.
        /// Since <see cref="mpz_sizeinbase"/> always returns at least 1, count here will be at least one, which avoids any portability
        /// problems with malloc(0), though if z is zero no space at all is actually needed (or written). 
        /// </para> 
        /// <code language="C++">
        /// numb = 8 * size - nail;
        /// count = (mpz_sizeinbase(z, 2) + numb - 1) / numb;
        /// p = malloc(count * size);
        /// </code> 
        /// </remarks>
        /// <seealso cref="mpz_import"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export">GNU MPFR - Integer Import and Export</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 0x800000000000000000000001.
        /// mpz_t op = new mpz_t();
        /// char_ptr value = new char_ptr("800000000000000000000001");
        /// mpfr_lib.mpz_init_set_str(op, value, 16);
        /// 
        /// // Export op as 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
        /// void_ptr data = mpfr_lib.allocate(12);
        /// size_t countp = 0;
        /// mpfr_lib.mpz_export(data, ref countp, -1, 4, 1, 0, op);
        /// 
        /// // Assert the result.
        /// byte[] result = new byte[12];
        /// Marshal.Copy(data.ToIntPtr(), result, 0, 12);
        /// Assert.IsTrue(result[0] == 0x00);
        /// Assert.IsTrue(result[1] == 0x00);
        /// Assert.IsTrue(result[2] == 0x00);
        /// Assert.IsTrue(result[3] == 0x01);
        /// Assert.IsTrue(result[4] == 0x00);
        /// Assert.IsTrue(result[5] == 0x00);
        /// Assert.IsTrue(result[6] == 0x00);
        /// Assert.IsTrue(result[7] == 0x00);
        /// Assert.IsTrue(result[8] == 0x80);
        /// Assert.IsTrue(result[9] == 0x00);
        /// Assert.IsTrue(result[10] == 0x00);
        /// Assert.IsTrue(result[11] == 0x00);
        /// 
        /// // Release unmanaged memory allocated for rop, data, and value.
        /// mpfr_lib.mpz_clear(op);
        /// mpfr_lib.free(data);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 0x800000000000000000000001.
        /// Dim op As New mpz_t()
        /// Dim value As New char_ptr("800000000000000000000001")
        /// mpfr_lib.mpz_init_set_str(op, value, 16)
        /// 
        /// ' Export op as 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
        /// Dim data As void_ptr = mpfr_lib.allocate(12)
        /// Dim countp As size_t = 0
        /// mpfr_lib.mpz_export(data, countp, -1, 4, 1, 0, op)
        /// 
        /// ' Assert the result.
        /// Dim result As Byte() = New Byte(11) { }
        /// Marshal.Copy(data.ToIntPtr(), result, 0, 12)
        /// Assert.IsTrue(result(0) = &amp;H0)
        /// Assert.IsTrue(result(1) = &amp;H0)
        /// Assert.IsTrue(result(2) = &amp;H0)
        /// Assert.IsTrue(result(3) = &amp;H1)
        /// Assert.IsTrue(result(4) = &amp;H0)
        /// Assert.IsTrue(result(5) = &amp;H0)
        /// Assert.IsTrue(result(6) = &amp;H0)
        /// Assert.IsTrue(result(7) = &amp;H0)
        /// Assert.IsTrue(result(8) = &amp;H80)
        /// Assert.IsTrue(result(9) = &amp;H0)
        /// Assert.IsTrue(result(10) = &amp;H0)
        /// Assert.IsTrue(result(11) = &amp;H0)
        /// 
        /// ' Release unmanaged memory allocated for rop, data, and value.
        /// mpfr_lib.mpz_clear(op)
        /// mpfr_lib.free(data)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static void_ptr mpz_export(void_ptr rop, ref size_t countp, int order, size_t size, int endian, size_t nails, /*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
            {
                uint temp = (uint)countp;
                IntPtr result = SafeNativeMethods.__mpfrz_export_x86(rop.ToIntPtr(), ref temp, order, (uint)size, endian, (uint)nails, op.ToIntPtr());
                countp = temp;
                return new void_ptr(result);
            }
            else
            {
                ulong temp = countp;
                IntPtr result = SafeNativeMethods.__mpfrz_export_x64(rop.ToIntPtr(), ref temp, order, size, endian, nails, op.ToIntPtr());
                countp = temp;
                return new void_ptr(result);
            }
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the factorial <paramref name="n"/>!.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="n">The operand integer.</param>
        /// <seealso cref="mpz_2fac_ui"/>
        /// <seealso cref="mpz_mfac_uiui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = 3!.
        /// mpfr_lib.mpz_fac_ui(rop, 3U);
        /// 
        /// // Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 6);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = 3!.
        /// mpfr_lib.mpz_fac_ui(rop, 3UI)
        /// 
        /// ' Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 6)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_fac_ui(mpz_t rop, uint /*unsigned long int*/ n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_fac_ui(rop.ToIntPtr(), n);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the double-factorial <paramref name="n"/>!!.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="n">The operand integer.</param>
        /// <seealso cref="mpz_fac_ui"/>
        /// <seealso cref="mpz_mfac_uiui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = 9!!.
        /// mpfr_lib.mpz_2fac_ui(rop, 9U);
        /// 
        /// // Assert that rop is 945.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 945);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = 9!!.
        /// mpfr_lib.mpz_2fac_ui(rop, 9UI)
        /// 
        /// ' Assert that rop is 945.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 945)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_2fac_ui(mpz_t rop, uint /*unsigned long int*/ n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_2fac_ui(rop.ToIntPtr(), n);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the m-multi-factorial <paramref name="n"/>!^(<paramref name="m"/>)n.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="n">The first operand integer.</param>
        /// <param name="m">The second operand integer.</param>
        /// <seealso cref="mpz_fac_ui"/>
        /// <seealso cref="mpz_2fac_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = 10!^(4).
        /// mpfr_lib.mpz_mfac_uiui(rop, 10U, 4U);
        /// 
        /// // Assert that rop is 945.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 120);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = 10!^(4).
        /// mpfr_lib.mpz_mfac_uiui(rop, 10UI, 4UI)
        /// 
        /// ' Assert that rop is 945.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 120)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_mfac_uiui(mpz_t rop, uint /*unsigned long int*/ n, uint /*unsigned long int*/ m)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_mfac_uiui(rop.ToIntPtr(), n, m);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the primorial of <paramref name="n"/>, i.e. the product of all positive prime numbers &#8804; <paramref name="n"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="n">The operand integer.</param>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = 7 * 5 * 3 * 2 = 210.
        /// mpfr_lib.mpz_primorial_ui(rop, 9U);
        /// 
        /// // Assert that rop is 210.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 210);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = 7 * 5 * 3 * 2 = 210.
        /// mpfr_lib.mpz_primorial_ui(rop, 9UI)
        /// 
        /// ' Assert that rop is 210.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 210)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_primorial_ui(mpz_t rop, uint /*unsigned long int*/ n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_primorial_ui(rop.ToIntPtr(), n);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = floor(n / d).
        /// mpfr_lib.mpz_fdiv_q(q, n, d);
        /// 
        /// // Assert that q is floor(10000 / 3).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// 
        /// // Release unmanaged memory allocated for n, d, and q.
        /// mpfr_lib.mpz_clears(n, d, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = floor(n / d).
        /// mpfr_lib.mpz_fdiv_q(q, n, d)
        /// 
        /// ' Assert that q is floor(10000 / 3).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and q.
        /// mpfr_lib.mpz_clears(n, d, q, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_fdiv_q(mpz_t q, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_fdiv_q(q.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / 2^<paramref name="b"/>).
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10001);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = floor(n / 2^2).
        /// mpfr_lib.mpz_fdiv_q_2exp(q, n, 2U);
        /// 
        /// // Assert that q is floor(10001 / 4).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 2500);
        /// 
        /// // Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10001)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = floor(n / 2^2).
        /// mpfr_lib.mpz_fdiv_q_2exp(q, n, 2UI)
        /// 
        /// ' Assert that q is floor(10001 / 4).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 2500)
        /// 
        /// ' Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_fdiv_q_2exp(mpz_t q, /*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_fdiv_q_2exp(q.ToIntPtr(), n.ToIntPtr(), b);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>), and return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = floor(n / 3) and return r = n - 3 * q.
        /// // Assert q and r values.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_q_ui(q, n, 3U) == 1U);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// 
        /// // Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = floor(n / 3) and return r = n - 3 * q.
        /// ' Assert q and r values.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_q_ui(q, n, 3UI) = 1UI)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// 
        /// ' Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, Nothing)
        /// </code> 
        /// </example>
        public static long mpz_fdiv_q_ui(mpz_t q, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_fdiv_q_ui(q.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>), and set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the values of q and r to 0.
        /// mpz_t q = new mpz_t();
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_inits(q, r, null);
        /// 
        /// // Set q = floor(n / 3) and r = n - d * q.
        /// mpfr_lib.mpz_fdiv_qr(q, r, n, d);
        /// 
        /// // Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n, d, q, and r.
        /// mpfr_lib.mpz_clears(n, d, q, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the values of q and r to 0.
        /// Dim q As New mpz_t()
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_inits(q, r, Nothing)
        /// 
        /// ' Set q = floor(n / 3) and r = n - d * q.
        /// mpfr_lib.mpz_fdiv_qr(q, r, n, d)
        /// /// 
        /// ' Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n, d, q, and r.
        /// mpfr_lib.mpz_clears(n, d, q, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_fdiv_qr(mpz_t q, mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_fdiv_qr(q.ToIntPtr(), r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set quotient <paramref name="q"/> to floor(<paramref name="n"/> / <paramref name="d"/>), set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>, and return | <paramref name="r"/> |.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return | <paramref name="r"/> |.</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the values of q and r to 0.
        /// mpz_t q = new mpz_t();
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_inits(q, r, null);
        /// 
        /// // Set q = floor(n / 3), r = n - d * q, and return r.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_qr_ui(q, r, n, 3U) == 1U);
        /// 
        /// // Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n, q, and r.
        /// mpfr_lib.mpz_clears(n, q, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the values of q and r to 0.
        /// Dim q As New mpz_t()
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_inits(q, r, Nothing)
        /// 
        /// ' Set q = floor(n / 3), r = n - d * q, and return r.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_qr_ui(q, r, n, 3UI) = 1UI)
        /// 
        /// ' Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n, q, and r.
        /// mpfr_lib.mpz_clears(n, q, r, Nothing)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_fdiv_qr_ui(mpz_t q, mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_fdiv_qr_ui(q.ToIntPtr(), r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = floor(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - d * floor(n / d).
        /// mpfr_lib.mpz_fdiv_r(r, n, d);
        /// 
        /// // Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n, d, and r.
        /// mpfr_lib.mpz_clears(n, d, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - d * floor(n / d).
        /// mpfr_lib.mpz_fdiv_r(r, n, d)
        /// ' Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and r.
        /// mpfr_lib.mpz_clears(n, d, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_fdiv_r(mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_fdiv_r(r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * 2^<paramref name="b"/> where q = floor(<paramref name="n"/> / 2^<paramref name="b"/>).
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10001);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - 2^2 * floor(n / 2^2)
        /// mpfr_lib.mpz_fdiv_r_2exp(r, n, 2U);
        /// 
        /// // Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10001)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - 2^2 * floor(n / 2^2)
        /// mpfr_lib.mpz_fdiv_r_2exp(r, n, 2UI)
        /// 
        /// ' Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_fdiv_r_2exp(mpz_t r, /*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_fdiv_r_2exp(r.ToIntPtr(), n.ToIntPtr(), b);
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = floor(<paramref name="n"/> / <paramref name="d"/>), and return | <paramref name="r"/> |.
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return | <paramref name="r"/> |.</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - 3 * floor(n / 3), and return |r|.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_r_ui(r, n, 3U) == 1U);
        /// 
        /// // Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - 3 * floor(n / 3), and return |r|.
        /// Set r = n - 3 * floor(n / 3), and return |r|.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_r_ui(r, n, 3UI) = 1UI)
        /// 
        /// ' Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, Nothing)
        /// </code> 
        /// </example>
        public static long mpz_fdiv_r_ui(mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_fdiv_r_ui(r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Return the remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = floor(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>The remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = floor(<paramref name="n"/> / <paramref name="d"/>).</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q"/>
        /// <seealso cref="mpz_fdiv_r"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_fdiv_q_ui"/>
        /// <seealso cref="mpz_fdiv_r_ui"/>
        /// <seealso cref="mpz_fdiv_qr_ui"/>
        /// <seealso cref="mpz_fdiv_q_2exp"/>
        /// <seealso cref="mpz_fdiv_r_2exp"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Assert that returned value is |n - 3 * floor(n / 3)|.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_ui(n, 3U) == 1U);
        /// 
        /// // Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Assert that returned value is |n - 3 * floor(n / 3)|.
        /// Assert.IsTrue(mpfr_lib.mpz_fdiv_ui(n, 3UI) = 1UI)
        /// 
        /// ' Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n)
        /// </code> 
        /// </example>
        public static long mpz_fdiv_ui(/*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_fdiv_ui(n.ToIntPtr(), d);
        }

        /// <summary>
        /// Sets <paramref name="fn"/> to to F[<paramref name="n"/>], the <paramref name="n"/>’th Fibonacci number. 
        /// </summary>
        /// <param name="fn">The F[<paramref name="n"/>] result.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
        /// <see cref="mpz_fib2_ui"/> and <see cref="mpz_lucnum2_ui"/>. 
        /// The formulas for going from Fibonacci to Lucas can be found in
        /// <a href="https://mpfrlib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MPFR - Lucas Numbers Algorithm</a>,
        /// the reverse is straightforward too.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_fib2_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of fn to 0.
        /// mpz_t fn = new mpz_t();
        /// mpfr_lib.mpz_init(fn);
        /// 
        /// // Set fn to the n'th Fibonacci number.
        /// mpfr_lib.mpz_fib_ui(fn, 20U);
        /// 
        /// // Assert that fn is 6765.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(fn) == 6765);
        /// 
        /// // Release unmanaged memory allocated for fn.
        /// mpfr_lib.mpz_clear(fn);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of fn to 0.
        /// Dim fn As New mpz_t()
        /// mpfr_lib.mpz_init(fn)
        /// 
        /// ' Set fn to the n'th Fibonacci number.
        /// mpfr_lib.mpz_fib_ui(fn, 20UI)
        /// 
        /// ' Assert that fn is 6765.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(fn) = 6765)
        /// 
        /// ' Release unmanaged memory allocated for fn.
        /// mpfr_lib.mpz_clear(fn)
        /// </code>
        /// </example>
        public static void mpz_fib_ui(mpz_t fn, uint /*unsigned long int*/ n)
        {
            if (fn == null) throw new ArgumentNullException("fn");
            SafeNativeMethods.__mpfrz_fib_ui(fn.ToIntPtr(), n);
        }

        /// <summary>
        /// Sets <paramref name="fn"/> to F[<paramref name="n"/>], and <paramref name="fnsub1"/> to F[<paramref name="n"/> - 1]. 
        /// </summary>
        /// <param name="fn">The F[<paramref name="n"/>] result.</param>
        /// <param name="fnsub1">The F[<paramref name="n"/> - 1] result.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// This function is designed for calculating isolated Fibonacci numbers. 
        /// When a sequence of values is wanted it’s best to start with <see cref="mpz_fib2_ui"/> 
        /// and iterate the defining F[n + 1] = F[n] + F[n - 1] or similar.
        /// </para>
        /// <para>
        /// The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
        /// <see cref="mpz_fib2_ui"/> and <see cref="mpz_lucnum2_ui"/>. 
        /// The formulas for going from Fibonacci to Lucas can be found in
        /// <a href="https://mpfrlib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MPFR - Lucas Numbers Algorithm</a>,
        /// the reverse is straightforward too.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_fib_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the values of fn and fnsub1 to 0.
        /// mpz_t fn = new mpz_t();
        /// mpz_t fnsub1 = new mpz_t();
        /// mpfr_lib.mpz_inits(fn, fnsub1, null);
        /// 
        /// // Set fnsub1 and fn to the 19'th and 20'th Fibonacci numbers respectively.
        /// mpfr_lib.mpz_fib2_ui(fn, fnsub1, 20U);
        /// 
        /// // Assert that fnsub1 and fn are respectively 4181 and 6765.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(fnsub1) == 4181);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(fn) == 6765);
        /// 
        /// // Release unmanaged memory allocated for fn and fnsub1.
        /// mpfr_lib.mpz_clears(fn, fnsub1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the values of fn and fnsub1 to 0.
        /// Dim fn As New mpz_t()
        /// Dim fnsub1 As New mpz_t()
        /// mpfr_lib.mpz_inits(fn, fnsub1, Nothing)
        /// 
        /// ' Set fnsub1 and fn to the 19'th and 20'th Fibonacci numbers respectively.
        /// mpfr_lib.mpz_fib2_ui(fn, fnsub1, 20UI)
        /// 
        /// ' Assert that fnsub1 and fn are respectively 4181 and 6765.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(fnsub1) = 4181)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(fn) = 6765)
        /// 
        /// ' Release unmanaged memory allocated for fn and fnsub1.
        /// mpfr_lib.mpz_clears(fn, fnsub1, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_fib2_ui(mpz_t fn, mpz_t fnsub1, uint /*unsigned long int*/ n)
        {
            if (fn == null) throw new ArgumentNullException("fn");
            if (fnsub1 == null) throw new ArgumentNullException("fnsub1");
            SafeNativeMethods.__mpfrz_fib2_ui(fn.ToIntPtr(), fnsub1.ToIntPtr(), n);
        }

        /// <summary>
        /// Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_sint_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_sint_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_fits_sint_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_fits_sint_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in long.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_slong_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in long.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_slong_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_fits_slong_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_fits_slong_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero iff the value of <paramref name="op"/> fits in a signed 16-bit integer. Otherwise, return zero.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 16-bit integer. Otherwise, return zero.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in short.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_sshort_p(op) ==  0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in short.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_sshort_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_fits_sshort_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_fits_sshort_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 32-bit integer. Otherwise, return zero.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 32-bit integer. Otherwise, return zero.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in uint.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_uint_p(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in uint.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_uint_p(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_fits_uint_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_fits_uint_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 32-bit integer. Otherwise, return zero.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero iff the value of <paramref name="op"/> fits in a signed 32-bit integer. Otherwise, return zero.</returns>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op fits in ulong.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_ulong_p(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op fits in ulong.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_ulong_p(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_fits_ulong_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_fits_ulong_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 16-bit integer. Otherwise, return zero.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero iff the value of <paramref name="op"/> fits in an unsigned 16-bit integer. Otherwise, return zero.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in ushort.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_ushort_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in ushort.
        /// Assert.IsTrue(mpfr_lib.mpz_fits_ushort_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_fits_ushort_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_fits_ushort_p(op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the greatest common divisor of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result operand integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// The result is always positive even if one or both input operands are negative.
        /// Except if both inputs are zero; then this function defines gcd(0,0) = 0.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_gcd_ui"/>
        /// <seealso cref="mpz_gcdext"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the greatest common divisor of op1 and op2.
        /// mpfr_lib.mpz_gcd(rop, op1, op2);
        /// 
        /// // Assert that rop is 7.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 7);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the greatest common divisor of op1 and op2.
        /// mpfr_lib.mpz_gcd(rop, op1, op2)
        /// 
        /// ' Assert that rop is 7.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 7)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_gcd(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_gcd(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compute the greatest common divisor of <paramref name="op1"/> and <paramref name="op2"/>. If <paramref name="rop"/> is not null, store the result there. 
        /// </summary>
        /// <param name="rop">The result operand integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>If the result is small enough to fit in an unsigned int, it is returned. If the result does not fit, 0 is returned, and the result is equal to the argument <paramref name="op1"/>.</returns>
        /// <remarks>
        /// <para>
        /// Note that the result will always fit if <paramref name="op2"/> is non-zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_gcd"/>
        /// <seealso cref="mpz_gcdext"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Return the greatest common divisor of op1 and 70.
        /// Assert.IsTrue(mpfr_lib.mpz_gcd_ui(null, op1, 70U) == 7);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Return the greatest common divisor of op1 and 70.
        /// Assert.IsTrue(mpfr_lib.mpz_gcd_ui(Nothing, op1, 70UI) = 7)
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpz_clear(op1)
        /// </code> 
        /// </example>
        public static uint mpz_gcd_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrz_gcd_ui(rop == null ? IntPtr.Zero : rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="g"/> to the greatest common divisor of <paramref name="a"/> and <paramref name="b"/>, and in addition set <paramref name="s"/> and <paramref name="t"/> to coefficients satisfying <paramref name="a"/> * <paramref name="s"/> + <paramref name="b"/> * <paramref name="t"/> = <paramref name="g"/>.
        /// </summary>
        /// <param name="g">The greateast common divisor.</param>
        /// <param name="s">The first result coefficient.</param>
        /// <param name="t">The second result coefficient.</param>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// The value in <paramref name="g"/> is always positive, even if one or both of <paramref name="a"/> and <paramref name="b"/>
        /// are negative (or zero if both inputs are zero). The values in <paramref name="s"/> and <paramref name="t"/> are chosen such
        /// that normally, | <paramref name="s"/> | &lt; | <paramref name="b"/> | / (2 <paramref name="g"/>)
        /// and | <paramref name="t"/> | &lt; | <paramref name="a"/> | / (2 <paramref name="g"/>), and these relations
        /// define <paramref name="s"/> and <paramref name="t"/> uniquely. There are a few exceptional cases: 
        /// </para>
        /// <para>
        /// If | <paramref name="a"/> | = | <paramref name="b"/> |, then <paramref name="s"/> = 0,
        /// <paramref name="t"/> = sgn(<paramref name="b"/>).
        /// </para>
        /// <para>
        /// Otherwise, <paramref name="s"/> = sgn(<paramref name="a"/>) if <paramref name="b"/> = 0 
        /// or | <paramref name="b"/> | = 2 <paramref name="g"/>, and <paramref name="t"/> = sgn(<paramref name="b"/>)
        /// if <paramref name="a"/> = 0 or | <paramref name="a"/> | = 2 <paramref name="g"/>. 
        /// </para>
        /// <para>
        /// In all cases, <paramref name="s"/> = 0 if and only if
        /// <paramref name="g"/> = | <paramref name="b"/> |, i.e.,
        /// if <paramref name="b"/> divides <paramref name="a"/>
        /// or <paramref name="a"/> = <paramref name="b"/> = 0. 
        /// </para>
        /// <para>
        /// If <paramref name="t"/> is null then that value is not computed. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_gcd"/>
        /// <seealso cref="mpz_gcd_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t b = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(b, 70U);
        /// 
        /// // Create, initialize, and set the values of g, s, and t to 0.
        /// mpz_t g = new mpz_t();
        /// mpz_t s = new mpz_t();
        /// mpz_t t = new mpz_t();
        /// mpfr_lib.mpz_inits(g, s, t, null);
        /// 
        /// // Set g to the the greatest common divisor of a and b, and set s and t such that a * s + b * t = g.
        /// mpfr_lib.mpz_gcdext(g, s, t, a, b);
        /// 
        /// // Assert that g is 7, and that s and t are respectively -1 and 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(g) == 7);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(s) == -1);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(t) == 1);
        /// 
        /// // Release unmanaged memory allocated for g, s, t, a, and b.
        /// mpfr_lib.mpz_clears(g, s, t, a, b, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim a As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(a, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim b As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(b, 70UI)
        /// 
        /// ' Create, initialize, and set the values of g, s, and t to 0.
        /// Dim g As New mpz_t()
        /// Dim s As New mpz_t()
        /// Dim t As New mpz_t()
        /// mpfr_lib.mpz_inits(g, s, t, Nothing)
        /// 
        /// ' Set g to the the greatest common divisor of a and b, and set s and t such that a * s + b * t = g.
        /// mpfr_lib.mpz_gcdext(g, s, t, a, b)
        /// 
        /// ' Assert that g is 7, and that s and t are respectively -1 and 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(g) = 7)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(s) = -1)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(t) = 1)
        /// 
        /// ' Release unmanaged memory allocated for g, s, t, a, and b.
        /// mpfr_lib.mpz_clears(g, s, t, a, b, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_gcdext(mpz_t g, mpz_t s, mpz_t t, /*const*/ mpz_t a, /*const*/ mpz_t b)
        {
            if (g == null) throw new ArgumentNullException("g");
            if (s == null) throw new ArgumentNullException("s");
            if (a == null) throw new ArgumentNullException("a");
            if (b == null) throw new ArgumentNullException("b");
            SafeNativeMethods.__mpfrz_gcdext(g.ToIntPtr(), s.ToIntPtr(), t == null ? IntPtr.Zero : t.ToIntPtr(), a.ToIntPtr(), b.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a double, truncating if necessary (i.e. rounding towards zero).
        /// </summary>
        /// <param name="op">The integer.</param>
        /// <returns> <paramref name="op"/> as a double, truncating it if necessary (i.e. rounding towards zero).</returns>
        /// <remarks>
        /// <para>
        /// If the exponent from the conversion is too big, the result is system dependent. An infinity is returned
        /// where available. A hardware overflow trap may or may not occur.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_get_d_2exp"/>
        /// <seealso cref="mpz_get_si"/>
        /// <seealso cref="mpz_get_str"/>
        /// <seealso cref="mpz_get_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Integers.html#Converting-Integers">GNU MPFR - Converting Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_d(x, 10.7D);
        /// 
        /// // Assert that the value of x is 10.0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_d(x) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_d(x, 10.7)
        /// 
        /// ' Assert that the value of x is 10.0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_d(x) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static double mpz_get_d(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_get_d(op.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a double, truncating if necessary (i.e. rounding towards zero), and returning the exponent separately.
        /// </summary>
        /// <param name="exp">The returned exponent.</param>
        /// <param name="op">The integer.</param>
        /// <returns><paramref name="op"/> as a double, truncating if necessary (i.e. rounding towards zero).</returns>
        /// <remarks>
        /// <para>
        /// The return value is in the range 0.5 &#8804; | d | &lt; 1 and the exponent is stored to <paramref name="exp"/>.
        /// d x 2^<paramref name="exp"/> is the (truncated) <paramref name="op"/> value.
        /// If <paramref name="op"/> is zero, the return value is 0.0 and 0 is stored to <paramref name="exp"/>.
        /// </para>
        /// <para>
        /// This is similar to the standard C <c>frexp</c> function.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_get_d"/>
        /// <seealso cref="mpz_get_si"/>
        /// <seealso cref="mpz_get_str"/>
        /// <seealso cref="mpz_get_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Integers.html#Converting-Integers">GNU MPFR - Converting Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 2^20.
        /// mpz_t x = new mpz_t();
        /// char_ptr value = new char_ptr("100000000000000000000");
        /// mpfr_lib.mpz_init_set_str(x, value, 2);
        /// 
        /// // Assert that x is equal to 0.5^21.
        /// int exp = 0;
        /// Assert.IsTrue(mpfr_lib.mpz_get_d_2exp(ref exp, x) == 0.5D);
        /// Assert.IsTrue(exp == 21);
        /// 
        /// // Release unmanaged memory allocated for x and the string value.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 2^20.
        /// Dim x As New mpz_t()
        /// Dim value As New char_ptr("100000000000000000000")
        /// mpfr_lib.mpz_init_set_str(x, value, 2)
        /// 
        /// ' Assert that x is equal to 0.5^21.
        /// Dim exp As Integer = 0
        /// Assert.IsTrue(mpfr_lib.mpz_get_d_2exp(exp, x) = 0.5)
        /// Assert.IsTrue(exp = 21)
        /// 
        /// ' Release unmanaged memory allocated for x and the string value.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static double mpz_get_d_2exp(ref int /*long int*/ exp, /*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_get_d_2exp(ref exp, op.ToIntPtr());
        }

        /// <summary>
        /// Return the value of <paramref name="op"/> as an signed long.
        /// </summary>
        /// <param name="op">The integer.</param>
        /// <returns>The value of <paramref name="op"/> as an signed long.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> fits into a signed long int return the value of <paramref name="op"/>.
        /// Otherwise return the least significant part of <paramref name="op"/>, with the same sign as <paramref name="op"/>.
        /// </para>
        /// <para>
        /// If <paramref name="op"/> is too big to fit in a signed long int, the returned result is probably not very useful.
        /// To find out if the value will fit, use the function <see cref="mpz_fits_slong_p"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_get_d"/>
        /// <seealso cref="mpz_get_d_2exp"/>
        /// <seealso cref="mpz_get_str"/>
        /// <seealso cref="mpz_get_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Integers.html#Converting-Integers">GNU MPFR - Converting Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10);
        /// 
        /// // Retrieve the value of x, and assert that it is -10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == -10);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10)
        /// 
        /// ' Retrieve the value of x, and assert that it is -10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = -10)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static int mpz_get_si(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_get_si(op.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
        /// </summary>
        /// <param name="str">The converted integer.</param>
        /// <param name="base">The base.</param>
        /// <param name="op">The integer.</param>
        /// <returns>A pointer to the result string is returned, being either the allocated block, or the given <paramref name="str"/>.</returns>
        /// <remarks>
        /// <para>
        /// The base argument may vary from 2 to 62 or from −2 to −36.
        /// </para>
        /// <para>
        /// For base in the range 2..36, digits and lower-case letters are used; for −2..−36, digits and
        /// upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in that
        /// significance order) are used.
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is <see cref="char_ptr.Zero"/>, the result string is allocated using the current
        /// allocation function. The block will be strlen(str)+1 bytes, that being exactly enough for the string and
        /// null-terminator.
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is not <see cref="char_ptr.Zero"/>, it should point to a block of storage large
        /// enough for the result, that being <see cref="mpz_sizeinbase"/>(op, base) + 2.
        /// The two extra bytes are for a possible minus sign, and the null-terminator.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_get_d"/>
        /// <seealso cref="mpz_get_d_2exp"/>
        /// <seealso cref="mpz_get_si"/>
        /// <seealso cref="mpz_get_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Integers.html#Converting-Integers">GNU MPFR - Converting Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -210.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -210);
        /// 
        /// // Retrieve the string value of x, and assert that it is "-210".
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == "-210");
        /// 
        /// // Release unmanaged memory allocated for x and the string value.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -210.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -210)
        /// 
        /// ' Retrieve the string value of x, and assert that it is "-210".
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x)
        /// Assert.IsTrue(s.ToString() = "-210")
        /// 
        /// ' Release unmanaged memory allocated for x and the string value.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static char_ptr mpz_get_str(char_ptr str, int @base, /*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return new char_ptr(SafeNativeMethods.__mpfrz_get_str(str.ToIntPtr(), @base, op.ToIntPtr()));
        }

        /// <summary>
        /// Return the value of <paramref name="op"/> as an unsigned long.
        /// </summary>
        /// <param name="op">The integer.</param>
        /// <returns>The value of <paramref name="op"/> as an unsigned long.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is too big to fit an unsigned long then just the least significant
        /// bits that do fit are returned. The sign of <paramref name="op"/> is ignored, only the absolute
        /// value is used.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_get_d"/>
        /// <seealso cref="mpz_get_d_2exp"/>
        /// <seealso cref="mpz_get_si"/>
        /// <seealso cref="mpz_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Integers.html#Converting-Integers">GNU MPFR - Converting Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10U);
        /// 
        /// // Retrieve the value of x, and assert that it is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) == 10U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10UI)
        /// 
        /// ' Retrieve the value of x, and assert that it is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) = 10UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_get_ui(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_get_ui(op.ToIntPtr());
        }

        /// <summary>
        /// Return limb number <paramref name="n"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <param name="n">The zero-based limb index.</param>
        /// <returns>The limb number <paramref name="n"/> from <paramref name="op"/>.</returns>
        /// <remarks>
        /// <para>
        /// The sign of <paramref name="op"/> is ignored, just the absolute value is used.
        /// The least significant limb is number 0.
        /// </para>
        /// <para>
        /// <see cref="mpz_size"/> can be used to find how many limbs make up <paramref name="op"/>.
        /// <see cref="mpz_getlimbn"/> returns zero if <paramref name="n"/> is outside the range 0
        /// to mpz_size(<paramref name="op"/>) - 1.
        /// </para>
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t op = new mpz_t();
        /// char_ptr value = new char_ptr("1000 ABCD 1234 7AB8 24FD");
        /// mpfr_lib.mpz_init_set_str(op, value, 16);
        /// 
        /// // Assert the value of the limbs of op.
        /// if (mpfr_lib.mp_bytes_per_limb == 4)
        /// {
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 0) == 0x7AB824FD);
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 1) == 0xABCD1234);
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 2) == 0x00001000);
        /// }
        /// else // mpfr_lib.mp_bytes_per_limb == 8
        /// {
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 0) == 0xABCD12347AB824FD);
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 1) == 0x0000000000001000);
        /// }
        /// 
        /// // Release unmanaged memory allocated for op and value.
        /// mpfr_lib.mpz_clear(op);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim op As New mpz_t()
        /// Dim value As New char_ptr("1000 ABCD 1234 7AB8 24FD")
        /// mpfr_lib.mpz_init_set_str(op, value, 16)
        /// 
        /// ' Assert the value of the limbs of op.
        /// If mpfr_lib.mp_bytes_per_limb = 4 Then
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 0) = &amp;H7ab824fd)
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 1) = &amp;Habcd1234UI)
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 2) = &amp;H1000)
        /// Else ' mpfr_lib.mp_bytes_per_limb == 8
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 0) = &amp;Habcd12347ab824fdUL)
        ///     Assert.IsTrue(mpfr_lib.mpz_getlimbn(op, 1) = &amp;H1000)
        /// End If
        /// 
        /// ' Release unmanaged memory allocated for op and value.
        /// mpfr_lib.mpz_clear(op)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static mp_limb_t mpz_getlimbn(/*const*/ mpz_t op, mp_size_t n)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrz_getlimbn_x86(op.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrz_getlimbn_x64(op.ToIntPtr(), n));
        }

        /// <summary>
        /// Return the hamming distance between the two operands.
        /// </summary>
        /// <param name="op1">The first operanf integer.</param>
        /// <param name="op2">The second operanf integer.</param>
        /// <returns>The hamming distance between the two operands.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op1"/> and <paramref name="op2"/> are both &#8805; 0 or both &lt; 0,
        /// return the hamming distance between the two operands, which is the number of bit positions where
        /// <paramref name="op1"/> and <paramref name="op2"/> have different bit values. If one operand is
        /// &#8805; 0 and the other &lt; 0 then the number of bits different is infinite, and the
        /// return value is the largest possible <see cref="mp_bitcnt_t"/>. 
        /// </para>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Assert that the Hamming distance between op1 and op2 is 5.
        /// Assert.IsTrue(mpfr_lib.mpz_hamdist(op1, op2) == 5U);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpz_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Assert that the Hamming distance between op1 and op2 is 5.
        /// Assert.IsTrue(mpfr_lib.mpz_hamdist(op1, op2) = 5UI)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpz_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpz_hamdist(/*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrz_hamdist(op1.ToIntPtr(), op2.ToIntPtr()));
        }

        /// <summary>
        /// Set <paramref name="rop"/> from an array of word data at <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="count">The number of words to read.</param>
        /// <param name="order">1 for most significant word first or -1 for least significant first.</param>
        /// <param name="size">The number of bytes in each word.</param>
        /// <param name="endian">1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.</param>
        /// <param name="nails">The number of most significant bits to skip.</param>
        /// <param name="op">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The parameters specify the format of the data.
        /// <paramref name="count"/> many words are read, each <paramref name="size"/> bytes.
        /// <paramref name="order"/> can be 1 for most significant word first or -1 for least significant first.
        /// Within each word endian can be 1 for most significant byte first, -1 for least significant first, or 0 for the native endianness of the host CPU.
        /// The most significant <paramref name="nails"/> bits of each word are skipped, this can be 0 to use the full words. 
        /// </para>
        /// <para>
        /// There is no sign taken from the data, <paramref name="rop"/> will simply be a positive integer.
        /// An application can handle any sign itself, and apply it for instance with <see cref="mpz_neg"/>.
        /// </para>
        /// <para>
        /// There are no data alignment restrictions on <paramref name="op"/>, any address is allowed. 
        /// </para>
        /// <para>
        /// Here’s an example converting an array of unsigned long data, most significant element first, and host byte order within each value. 
        /// </para>
        /// <code language="C++">
        /// unsigned long a[20];
        /// /* Initialize z and a */
        /// mpz_import(z, 20, 1, sizeof(a[0]), 0, 0, a);
        /// </code> 
        /// <para>
        /// This example assumes the full sizeof bytes are used for data in the given type, which is usually true,
        /// and certainly true for unsigned long everywhere we know of. However on Cray vector systems it may be noted that <c>short</c>
        /// and <c>int</c> are always stored in 8 bytes (and with sizeof indicating that) but use only 32 or 46 bits.
        /// The <paramref name="nails"/> feature can account for this, by passing for instance 8 * sizeof(int) - INT_BIT. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_export"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Import-and-Export.html#Integer-Import-and-Export">GNU MPFR - Integer Import and Export</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Copy 0x800000000000000000000001, 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
        /// void_ptr data = mpfr_lib.allocate(12);
        /// Marshal.Copy(new byte[] { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00 }, 0, data.ToIntPtr(), 12);
        /// 
        /// // Import value into rop.
        /// mpfr_lib.mpz_import(rop, 3, -1, 4, 1, 0, data);
        /// 
        /// // Assert the value of rop.
        /// char_ptr value = mpfr_lib.mpz_get_str(char_ptr.Zero, 16, rop);
        /// Assert.IsTrue(value.ToString() == "800000000000000000000001");
        /// 
        /// // Release unmanaged memory allocated for rop, data, and value.
        /// mpfr_lib.mpz_clear(rop);
        /// mpfr_lib.free(data);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Copy 0x800000000000000000000001, 3 words of 4 bytes each, first word is lsb, and first byte in each word is msb.
        /// Dim data As void_ptr = mpfr_lib.allocate(12)
        /// Marshal.Copy(New Byte() { &amp;H0, &amp;H0, &amp;H0, &amp;H1, &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H80, &amp;H0, &amp;H0, &amp;H0}, 0, data.ToIntPtr(), 12)
        /// 
        /// ' Import value into rop.
        /// mpfr_lib.mpz_import(rop, 3, -1, 4, 1, 0, data)
        /// 
        /// ' Assert the value of rop.
        /// Dim value As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 16, rop)
        /// Assert.IsTrue(value.ToString() = "800000000000000000000001")
        /// 
        /// ' Release unmanaged memory allocated for rop, data, and value.
        /// mpfr_lib.mpz_clear(rop)
        /// mpfr_lib.free(data)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static void mpz_import(mpz_t rop, size_t count, int order, size_t size, int endian, size_t nails, void_ptr op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (IntPtr.Size == 4)
                SafeNativeMethods.__mpfrz_import_x86(rop.ToIntPtr(), (uint)count, order, (uint)size, endian, (uint)nails, op.ToIntPtr());
            else
                SafeNativeMethods.__mpfrz_import_x64(rop.ToIntPtr(), count, order, size, endian, nails, op.ToIntPtr());
        }

        /// <summary>
        /// Initialize <paramref name="x"/>, and set its value to 0.
        /// </summary>
        /// <param name="x">The integer.</param>
        /// <seealso cref="mpz_clear"/>
        /// <seealso cref="mpz_clears"/>
        /// <seealso cref="mpz_inits"/>
        /// <seealso cref="mpz_init2"/>
        /// <seealso cref="mpz_realloc2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MPFR - Initializing Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Assert that the value of x is 0.
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == "0");
        /// 
        /// // Release unmanaged memory allocated for x and its string value.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Assert that the value of x is 0.
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x)
        /// Assert.IsTrue(s.ToString() = "0")
        /// 
        /// ' Release unmanaged memory allocated for x and its string value.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static void mpz_init(mpz_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_init(x.ToIntPtr());
        }

        /// <summary>
        /// Initialize <paramref name="x"/>, with space for <paramref name="n"/>-bit numbers, and set its value to 0.
        /// </summary>
        /// <param name="x">The integer.</param>
        /// <param name="n">The number of bits.</param>
        /// <remarks>
        /// <para>
        /// Calling this function instead of <see cref="mpz_init"/> or <see cref="mpz_inits"/>
        /// is never necessary; reallocation is handled automatically by MPFR when needed.
        /// </para>
        /// <para>
        /// While <paramref name="n"/> defines the initial space, <paramref name="x"/> will grow automatically in the normal way,
        /// if necessary, for subsequent values stored.
        /// <see cref="mpz_init2"/> makes it possible to avoid such reallocations if a maximum size is known in advance.
        /// </para>
        /// <para>
        /// In preparation for an operation, MPFR often allocates one limb more than ultimately needed.
        /// To make sure MPFR will not perform reallocation for <paramref name="x"/>, you need to add the number of bits
        /// in <see cref="mp_limb_t"/> to <paramref name="n"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_clear"/>
        /// <seealso cref="mpz_clears"/>
        /// <seealso cref="mpz_init"/>
        /// <seealso cref="mpz_inits"/>
        /// <seealso cref="mpz_realloc2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MPFR - Initializing Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create a new integer x, and initialize its size to 300 bits.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init2(x, 300);
        /// 
        /// // Assert that the value of x is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create a new integer x, and initialize its size to 300 bits.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init2(x, 300)
        /// 
        /// ' Assert that the value of x is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_init2(mpz_t x, mp_bitcnt_t n)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_init2(x.ToIntPtr(), n);
        }

        /// <summary>
        /// Initialize a NULL-terminated list of <see cref="mpz_t"/> variables, and set their values to 0.
        /// </summary>
        /// <param name="x">A NULL-terminated list of <see cref="mpz_t"/> variables.</param>
        /// <seealso cref="mpz_clear"/>
        /// <seealso cref="mpz_clears"/>
        /// <seealso cref="mpz_init"/>
        /// <seealso cref="mpz_init2"/>
        /// <seealso cref="mpz_realloc2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MPFR - Initializing Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new integers x1, x2 and x3.
        /// mpz_t x1 = new mpz_t();
        /// mpz_t x2 = new mpz_t();
        /// mpz_t x3 = new mpz_t();
        /// 
        /// // Initialize the integers.
        /// mpfr_lib.mpz_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x1) == 0);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x2) == 0);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x3) == 0);
        /// 
        /// // Release unmanaged memory allocated for the integers.
        /// mpfr_lib.mpz_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new integers x1, x2 and x3.
        /// Dim x1 As New mpz_t()
        /// Dim x2 As New mpz_t()
        /// Dim x3 As New mpz_t()
        /// 
        /// ' Initialize the integers.
        /// mpfr_lib.mpz_inits(x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x1) = 0)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x2) = 0)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x3) = 0)
        /// 
        /// ' Release unmanaged memory allocated for the integers.
        /// mpfr_lib.mpz_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_inits(params mpz_t[] x)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpz_t a in x) { if (a != null) mpz_init(a); }
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <seealso cref="mpz_init_set_ui"/>
        /// <seealso cref="mpz_init_set_si"/>
        /// <seealso cref="mpz_init_set_d"/>
        /// <seealso cref="mpz_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MPFR - Combined Integer Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer y to -210.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init(y);
        /// mpfr_lib.mpz_set_si(y, -210);
        /// 
        /// // Create, initialize, and set a new integer x to the value of y.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set(x, y);
        /// 
        /// // Assert that x is equal to the value of y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == -210);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer y to -210.
        /// Dim y As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init(y)
        /// mpfr_lib.mpz_set_si(y, -210)
        /// 
        /// ' Create, initialize, and set a new integer x to the value of y.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set(x, y)
        /// 
        /// ' Assert that x is equal to the value of y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = -210)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_init_set(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_init_set(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <remarks>
        /// <para>
        /// <see cref="mpz_init_set_d"/> truncate <paramref name="op"/> to make it an integer.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_init_set"/>
        /// <seealso cref="mpz_init_set_ui"/>
        /// <seealso cref="mpz_init_set_si"/>
        /// <seealso cref="mpz_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MPFR - Combined Integer Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to the truncation of 10.7.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_d(x, 10.7D);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 10);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to the truncation of 10.7.
        /// Dim x As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init_set_d(x, 10.7)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 10)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_init_set_d(mpz_t rop, double op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_init_set_d(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <seealso cref="mpz_init_set"/>
        /// <seealso cref="mpz_init_set_ui"/>
        /// <seealso cref="mpz_init_set_d"/>
        /// <seealso cref="mpz_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MPFR - Combined Integer Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, 10);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 10);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10.
        /// Dim x As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init_set_si(x, 10)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 10)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_init_set_si(mpz_t rop, int /*long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_init_set_si(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value like <see cref="mpz_set_str"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="str">The source integer.</param>
        /// <param name="base">The base.</param>
        /// <returns>If the string is a correct base <paramref name="base"/> number, the function returns 0; if an error occurs it returns −1. <paramref name="rop"/> is initialized even if an error occurs.</returns>
        /// <remarks>
        /// <para>
        /// See <see cref="mpz_set_str"/> for details.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_init_set"/>
        /// <seealso cref="mpz_init_set_ui"/>
        /// <seealso cref="mpz_init_set_si"/>
        /// <seealso cref="mpz_init_set_d"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MPFR - Combined Integer Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x.
        /// mpz_t x = new mpz_t();
        /// char_ptr value = new char_ptr("  1 234 567 890 876 543 211 234 567 890 987 654 321  ");
        /// mpfr_lib.mpz_init_set_str(x, value, 10);
        /// 
        /// // Assert the value of x.
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == value.ToString().Replace(" ", ""));
        /// 
        /// // Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(value);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x.
        /// Dim x As New mpz_t()
        /// Dim value As New char_ptr("  1 234 567 890 876 543 211 234 567 890 987 654 321  ")
        /// mpfr_lib.mpz_init_set_str(x, value, 10)
        /// 
        /// ' Assert the value of x.
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x)
        /// 
        /// Assert.IsTrue(s.ToString() = value.ToString().Replace(" ", ""))
        /// ' Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(value)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static int mpz_init_set_str(mpz_t rop, /*const*/ char_ptr str, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.__mpfrz_init_set_str(rop.ToIntPtr(), str.ToIntPtr(), @base);
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> with limb space and set the initial numeric value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <seealso cref="mpz_init_set"/>
        /// <seealso cref="mpz_init_set_si"/>
        /// <seealso cref="mpz_init_set_d"/>
        /// <seealso cref="mpz_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Integer-Init-_0026-Assign.html#Simultaneous-Integer-Init-_0026-Assign">GNU MPFR - Combined Integer Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10U);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) == 10U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10UI)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) = 10UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_init_set_ui(mpz_t rop, uint /*unsigned long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_init_set_ui(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Input from stdio stream <paramref name="stream"/> in the format written by <see cref="mpz_out_raw"/>, and put the result in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result operand.</param>
        /// <param name="stream">Pointer to file stream.</param>
        /// <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// This routine can read the output from <see cref="mpz_out_raw"/> also from MPFR 1,
        /// in spite of changes necessary for compatibility between 32-bit and 64-bit machines. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_out_str"/>
        /// <seealso cref="mpz_inp_str"/>
        /// <seealso cref="mpz_out_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MPFR - I/O of Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 123456U);
        /// 
        /// // Write op to a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// Assert.IsTrue(mpfr_lib.mpz_out_raw(stream, op) == 7);
        /// fclose(stream.Value.Value);
        /// 
        /// // Read op from the temporary file, and assert that the number of bytes read is 6.
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpz_inp_raw(op, stream) == 7);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(op) == 123456U);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123456.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 123456UI)
        /// 
        /// ' Write op to a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "w")
        /// Assert.IsTrue(mpfr_lib.mpz_out_raw(stream, op) = 7)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Read op from the temporary file, and assert that the number of bytes read is 6.
        /// _wfopen_s(stream.Value.Value, pathname, "r")
        /// Assert.IsTrue(mpfr_lib.mpz_inp_raw(op, stream) = 7)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(op) = 123456UI)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpz_inp_raw(mpz_t rop, ptr<FILE> stream)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrz_inp_raw_x86(rop.ToIntPtr(), stream.Value.Value));
            else
                return new size_t(SafeNativeMethods.__mpfrz_inp_raw_x64(rop.ToIntPtr(), stream.Value.Value));
        }

        /// <summary>
        /// Input a possibly white-space preceded string in base <paramref name="base"/> from stdio stream <paramref name="stream"/>, and put the read integer in <paramref name="rop"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="stream">Pointer to file stream.</param>
        /// <param name="base">The base operand.</param>
        /// <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// The <paramref name="base"/> may vary from 2 to 62, or if base is 0,
        /// then the leading characters are used: 0x and 0X for hexadecimal,
        /// 0b and 0B for binary, 0 for octal, or decimal otherwise. 
        /// </para>
        /// <para>
        /// For bases up to 36, case is ignored; upper-case and lower-case letters have the same value.
        /// For bases 37 to 62, upper-case letter represent the usual 10..35 while
        /// lower-case letter represent 36..61. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_out_str"/>
        /// <seealso cref="mpz_out_raw"/>
        /// <seealso cref="mpz_inp_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MPFR - I/O of Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize op.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init(op);
        /// 
        /// // Write op to a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// System.IO.File.WriteAllText(pathname, "123456");
        /// 
        /// // Read op from the temporary file, and assert that the number of bytes read is 6.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpz_inp_str(op, stream, 10) == 6);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(op) == 123456U);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize op.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init(op)
        /// 
        /// ' Write op to a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// System.IO.File.WriteAllText(pathname, "123456")
        /// 
        /// ' Read op from the temporary file, and assert that the number of bytes read is 6.
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "r")
        /// Assert.IsTrue(mpfr_lib.mpz_inp_str(op, stream, 10) = 6)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(op) = 123456UI)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpz_inp_str(mpz_t rop, ptr<FILE> stream, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrz_inp_str_x86(rop.ToIntPtr(), stream.Value.Value, @base));
            else
                return new size_t(SafeNativeMethods.__mpfrz_inp_str_x64(rop.ToIntPtr(), stream.Value.Value, @base));
        }

        /// <summary>
        /// Compute the inverse of <paramref name="op1"/> modulo <paramref name="op2"/> and put the result in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <returns>If the inverse exists, the return value is non-zero. If an inverse doesn’t exist the return value is zero.</returns>
        /// <remarks>
        /// <para>
        /// If the inverse exists, the return value is non-zero and <paramref name="rop"/> will satisfy
        /// 0 &#8804; <paramref name="rop"/> &lt; | <paramref name="op2"/> | (with <paramref name="rop"/> = 0
        /// possible only when | <paramref name="op2"/> | = 1, i.e., in the somewhat degenerate zero ring).
        /// If an inverse doesn’t exist the return value is zero and <paramref name="rop"/> is undefined.
        /// The behaviour of this function is undefined when <paramref name="op2"/> is zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 3.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 3U);
        /// 
        /// // Create, initialize, and set the value of op2 to 11.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 11U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the modular inverse of op1 mod op2, i.e. b, where op1 * b mod op1 = 1.
        /// mpfr_lib.mpz_invert(rop, op1, op2);
        /// 
        /// // Assert that rop is 4,
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 4);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 3.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 3UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 11.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 11UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the modular inverse of op1 mod op2, i.e. b, where op1 * b mod op1 = 1.
        /// mpfr_lib.mpz_invert(rop, op1, op2)
        /// 
        /// ' Assert that rop is 4,
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 4)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_invert(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrz_invert(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> bitwise inclusive-or <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the bitwise inclusive or of op1 and op2.
        /// mpfr_lib.mpz_ior(rop, op1, op2);
        /// 
        /// // Assert that rop is 127.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 127);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the bitwise inclusive or of op1 and op2.
        /// mpfr_lib.mpz_ior(rop, op1, op2)
        /// 
        /// ' Assert that rop is 127.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 127)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_ior(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_ior(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>).
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>).</returns>
        /// <remarks>
        /// <para>
        /// This is defined only for <paramref name="b"/> odd. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_legendre"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of a to 11.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 11U);
        /// 
        /// // Create, initialize, and set the value of b to 9.
        /// mpz_t b = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(b, 9U);
        /// 
        /// // Assert that the Jacobi symbol of (a/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_jacobi(a, b) == 1);
        /// 
        /// // Release unmanaged memory allocated for a and b.
        /// mpfr_lib.mpz_clears(a, b, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of a to 11.
        /// Dim a As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(a, 11UI)
        /// 
        /// ' Create, initialize, and set the value of b to 9.
        /// Dim b As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(b, 9UI)
        /// 
        /// ' Assert that the Jacobi symbol of (a/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_jacobi(a, b) = 1)
        /// 
        /// ' Release unmanaged memory allocated for a and b.
        /// mpfr_lib.mpz_clears(a, b, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_jacobi(/*const*/ mpz_t a, /*const*/ mpz_t b)
        {
            if (a == null) throw new ArgumentNullException("a");
            if (b == null) throw new ArgumentNullException("b");
            return SafeNativeMethods.__mpfrz_jacobi(a.ToIntPtr(), b.ToIntPtr());
        }

        /// <summary>
        /// Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
        /// so <see cref="mpz_kronecker_ui"/>, etc. can be used for mixed precision Jacobi symbols too. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_kronecker_si"/>
        /// <seealso cref="mpz_kronecker_ui"/>
        /// <seealso cref="mpz_legendre"/>
        /// <seealso cref="mpz_si_kronecker"/>
        /// <seealso cref="mpz_ui_kronecker"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of a to 15.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 15U);
        /// 
        /// // Create, initialize, and set the value of b to 4.
        /// mpz_t b = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(b, 4U);
        /// 
        /// // Assert that the Kronecker symbol of (a/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_kronecker(a, b) == 1);
        /// 
        /// // Release unmanaged memory allocated for a and b.
        /// mpfr_lib.mpz_clears(a, b, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of a to 15.
        /// Dim a As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(a, 15UI)
        /// 
        /// ' Create, initialize, and set the value of b to 4.
        /// Dim b As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(b, 4UI)
        /// 
        /// ' Assert that the Kronecker symbol of (a/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_kronecker(a, b) = 1)
        /// 
        /// ' Release unmanaged memory allocated for a and b.
        /// mpfr_lib.mpz_clears(a, b, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_kronecker(/*const*/ mpz_t a, /*const*/ mpz_t b)
        {
            if (a == null) throw new ArgumentNullException("a");
            if (b == null) throw new ArgumentNullException("b");
            return SafeNativeMethods.__mpfrz_jacobi(a.ToIntPtr(), b.ToIntPtr());
        }

        /// <summary>
        /// Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
        /// so <see cref="mpz_kronecker_ui"/>, etc. can be used for mixed precision Jacobi symbols too. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_kronecker"/>
        /// <seealso cref="mpz_kronecker_ui"/>
        /// <seealso cref="mpz_legendre"/>
        /// <seealso cref="mpz_si_kronecker"/>
        /// <seealso cref="mpz_ui_kronecker"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of a to 15.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 15U);
        /// 
        /// // Assert that the Kronecker symbol of (a/4) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_kronecker_si(a, 4) == 1);
        /// 
        /// // Release unmanaged memory allocated for a.
        /// mpfr_lib.mpz_clear(a);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of a to 15.
        /// Dim a As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(a, 15UI)
        /// 
        /// ' Assert that the Kronecker symbol of (a/4) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_kronecker_si(a, 4) = 1)
        /// 
        /// ' Release unmanaged memory allocated for a.
        /// mpfr_lib.mpz_clear(a)
        /// </code> 
        /// </example>
        public static int mpz_kronecker_si(/*const*/ mpz_t a, int /*long int*/ b)
        {
            if (a == null) throw new ArgumentNullException("a");
            return SafeNativeMethods.__mpfrz_kronecker_si(a.ToIntPtr(), b);
        }

        /// <summary>
        /// Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
        /// so <see cref="mpz_kronecker_ui"/>, etc. can be used for mixed precision Jacobi symbols too. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_kronecker"/>
        /// <seealso cref="mpz_kronecker_si"/>
        /// <seealso cref="mpz_legendre"/>
        /// <seealso cref="mpz_si_kronecker"/>
        /// <seealso cref="mpz_ui_kronecker"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of a to 15.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 15U);
        /// 
        /// // Assert that the Kronecker symbol of (a/4) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_kronecker_ui(a, 4U) == 1);
        /// 
        /// // Release unmanaged memory allocated for a.
        /// mpfr_lib.mpz_clear(a);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of a to 15.
        /// Dim a As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(a, 15UI)
        /// 
        /// ' Assert that the Kronecker symbol of (a/4) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_kronecker_ui(a, 4UI) = 1)
        /// 
        /// ' Release unmanaged memory allocated for a.
        /// mpfr_lib.mpz_clear(a)
        /// </code> 
        /// </example>
        public static int mpz_kronecker_ui(/*const*/ mpz_t a, uint /*unsigned long int*/ b)
        {
            if (a == null) throw new ArgumentNullException("a");
            return SafeNativeMethods.__mpfrz_kronecker_ui(a.ToIntPtr(), b);
        }

        /// <summary>
        /// Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
        /// so <see cref="mpz_kronecker_ui"/>, etc. can be used for mixed precision Jacobi symbols too. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_kronecker"/>
        /// <seealso cref="mpz_kronecker_si"/>
        /// <seealso cref="mpz_kronecker_ui"/>
        /// <seealso cref="mpz_legendre"/>
        /// <seealso cref="mpz_ui_kronecker"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of b to 4.
        /// mpz_t b = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(b, 4U);
        /// 
        /// // Assert that the Kronecker symbol of (15/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_si_kronecker(15, b) == 1);
        /// 
        /// // Release unmanaged memory allocated for b.
        /// mpfr_lib.mpz_clear(b);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of b to 4.
        /// Dim b As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(b, 4UI)
        /// 
        /// ' Assert that the Kronecker symbol of (15/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_si_kronecker(15, b) = 1)
        /// 
        /// ' Release unmanaged memory allocated for b.
        /// mpfr_lib.mpz_clear(b)
        /// </code> 
        /// </example>
        public static int mpz_si_kronecker(int /*long int*/ a, /*const*/ mpz_t b)
        {
            if (b == null) throw new ArgumentNullException("b");
            return SafeNativeMethods.__mpfrz_si_kronecker(a, b.ToIntPtr());
        }

        /// <summary>
        /// Calculate the Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even. 
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="b">The second operand integer.</param>
        /// <returns>The Jacobi symbol (<paramref name="a"/>/<paramref name="b"/>) with the Kronecker extension (<paramref name="a"/>/2) = (2/<paramref name="a"/>) when <paramref name="a"/> odd, or (<paramref name="a"/>/2) = 0 when <paramref name="a"/> even.</returns>
        /// <remarks>
        /// <para>
        /// When <paramref name="b"/> is odd the Jacobi symbol and Kronecker symbol are identical, 
        /// so <see cref="mpz_kronecker_ui"/>, etc. can be used for mixed precision Jacobi symbols too. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_kronecker"/>
        /// <seealso cref="mpz_kronecker_si"/>
        /// <seealso cref="mpz_kronecker_ui"/>
        /// <seealso cref="mpz_legendre"/>
        /// <seealso cref="mpz_si_kronecker"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of b to 4.
        /// mpz_t b = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(b, 4U);
        /// 
        /// // Assert that the Kronecker symbol of (15/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_ui_kronecker(15U, b) == 1);
        /// 
        /// // Release unmanaged memory allocated for b.
        /// mpfr_lib.mpz_clear(b);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of b to 4.
        /// Dim b As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(b, 4UI)
        /// 
        /// ' Assert that the Kronecker symbol of (15/b) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_ui_kronecker(15UI, b) = 1)
        /// 
        /// ' Release unmanaged memory allocated for b.
        /// mpfr_lib.mpz_clear(b)
        /// </code> 
        /// </example>
        public static int mpz_ui_kronecker(uint /*unsigned long int*/ a, /*const*/ mpz_t b)
        {
            if (b == null) throw new ArgumentNullException("b");
            return SafeNativeMethods.__mpfrz_ui_kronecker(a, b.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the least common multiple of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// <paramref name="rop"/> is always positive, irrespective of the signs of <paramref name="op1"/> and <paramref name="op2"/>.
        /// <paramref name="rop"/> will be zero if either <paramref name="op1"/> or <paramref name="op2"/> is zero. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_lcm_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 2.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 2U);
        /// 
        /// // Create, initialize, and set the value of op2 to 3.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 3U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the least common multiple of op1 and op2.
        /// mpfr_lib.mpz_lcm(rop, op1, op2);
        /// 
        /// // Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 6);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 2.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 2UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 3.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 3UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the least common multiple of op1 and op2.
        /// mpfr_lib.mpz_lcm(rop, op1, op2)
        /// 
        /// ' Assert that rop is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 6)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_lcm(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_lcm(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the least common multiple of <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// <paramref name="rop"/> is always positive, irrespective of the signs of <paramref name="op1"/> and <paramref name="op2"/>.
        /// <paramref name="rop"/> will be zero if either <paramref name="op1"/> or <paramref name="op2"/> is zero. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_lcm"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpz_lcm_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_lcm_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Calculate the Legendre symbol (<paramref name="a"/>/<paramref name="p"/>).
        /// </summary>
        /// <param name="a">The first operand integer.</param>
        /// <param name="p">The second operand integer.</param>
        /// <returns>The Legendre symbol (<paramref name="a"/>/<paramref name="p"/>).</returns>
        /// <remarks>
        /// <para>
        /// This is defined only for <paramref name="p"/> an odd positive prime,
        /// and for such <paramref name="p"/> it’s identical to the Jacobi symbol. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_jacobi"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of a to 20.
        /// mpz_t a = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(a, 20U);
        /// 
        /// // Create, initialize, and set the value of p to 11.
        /// mpz_t p = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(p, 11U);
        /// 
        /// // Assert that the Legendre symbol of (a/p) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_legendre(a, p) == 1);
        /// 
        /// // Release unmanaged memory allocated for a and p.
        /// mpfr_lib.mpz_clears(a, p, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of a to 20.
        /// Dim a As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(a, 20UI)
        /// 
        /// ' Create, initialize, and set the value of p to 11.
        /// Dim p As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(p, 11UI)
        /// 
        /// ' Assert that the Legendre symbol of (a/p) is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_legendre(a, p) = 1)
        /// 
        /// ' Release unmanaged memory allocated for a and p.
        /// mpfr_lib.mpz_clears(a, p, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_legendre(/*const*/ mpz_t a, /*const*/ mpz_t p)
        {
            if (a == null) throw new ArgumentNullException("a");
            if (p == null) throw new ArgumentNullException("p");
            return SafeNativeMethods.__mpfrz_legendre(a.ToIntPtr(), p.ToIntPtr());
        }

        /// <summary>
        /// Sets <paramref name="ln"/> to to L[<paramref name="n"/>], the <paramref name="n"/>’th Lucas number. 
        /// </summary>
        /// <param name="ln">The L[<paramref name="n"/>] result.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
        /// <see cref="mpz_fib2_ui"/> and <see cref="mpz_lucnum2_ui"/>. 
        /// The formulas for going from Fibonacci to Lucas can be found in
        /// <a href="https://mpfrlib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MPFR - Lucas Numbers Algorithm</a>,
        /// the reverse is straightforward too.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_lucnum2_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of ln to 0.
        /// mpz_t ln = new mpz_t();
        /// mpfr_lib.mpz_init(ln);
        /// 
        /// // Set ln to the 9'th Lucas number.
        /// mpfr_lib.mpz_lucnum_ui(ln, 9U);
        /// 
        /// // Assert that ln is 76.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(ln) == 76);
        /// 
        /// // Release unmanaged memory allocated for ln.
        /// mpfr_lib.mpz_clear(ln);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of ln to 0.
        /// Dim ln As New mpz_t()
        /// mpfr_lib.mpz_init(ln)
        /// 
        /// ' Set ln to the 9'th Lucas number.
        /// mpfr_lib.mpz_lucnum_ui(ln, 9UI)
        /// 
        /// ' Assert that ln is 76.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(ln) = 76)
        /// 
        /// ' Release unmanaged memory allocated for ln.
        /// mpfr_lib.mpz_clear(ln)
        /// </code> 
        /// </example>
        public static void mpz_lucnum_ui(mpz_t ln, uint /*unsigned long int*/ n)
        {
            if (ln == null) throw new ArgumentNullException("ln");
            SafeNativeMethods.__mpfrz_lucnum_ui(ln.ToIntPtr(), n);
        }

        /// <summary>
        /// Sets <paramref name="ln"/> to L[<paramref name="n"/>], and <paramref name="lnsub1"/> to L[<paramref name="n"/> - 1]. 
        /// </summary>
        /// <param name="ln">The L[<paramref name="n"/>] result.</param>
        /// <param name="lnsub1">The L[<paramref name="n"/> - 1] result.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// This function is designed for calculating isolated Lucas numbers. 
        /// When a sequence of values is wanted it’s best to start with <see cref="mpz_lucnum2_ui"/> 
        /// and iterate the defining L[n + 1] = L[n] + L[n - 1] or similar.
        /// </para>
        /// <para>
        /// The Fibonacci numbers and Lucas numbers are related sequences, so it’s never necessary to call both
        /// <see cref="mpz_fib2_ui"/> and <see cref="mpz_lucnum2_ui"/>. 
        /// The formulas for going from Fibonacci to Lucas can be found in
        /// <a href="https://mpfrlib.org/manual/Lucas-Numbers-Algorithm.html#Lucas-Numbers-Algorithm">GNU MPFR - Lucas Numbers Algorithm</a>,
        /// the reverse is straightforward too.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_lucnum_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the values of lnsub1 and ln to 0.
        /// mpz_t ln = new mpz_t();
        /// mpz_t lnsub1 = new mpz_t();
        /// mpfr_lib.mpz_inits(ln, lnsub1, null);
        /// 
        /// // Set lnsub1 and ln to the 8'th and 9'th Lucas nunbers respectively.
        /// mpfr_lib.mpz_lucnum2_ui(ln, lnsub1, 9U);
        /// 
        /// // Assert that lnsub1 and ln are respectively 47 and 76.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(lnsub1) == 47);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(ln) == 76);
        /// 
        /// // Release unmanaged memory allocated for ln and lnsub1.
        /// mpfr_lib.mpz_clears(ln, lnsub1, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the values of lnsub1 and ln to 0.
        /// Dim ln As New mpz_t()
        /// Dim lnsub1 As New mpz_t()
        /// mpfr_lib.mpz_inits(ln, lnsub1, Nothing)
        /// 
        /// ' Set lnsub1 and ln to the 8'th and 9'th Lucas nunbers respectively.
        /// mpfr_lib.mpz_lucnum2_ui(ln, lnsub1, 9UI)
        /// 
        /// ' Assert that lnsub1 and ln are respectively 47 and 76.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(lnsub1) = 47)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(ln) = 76)
        /// 
        /// ' Release unmanaged memory allocated for ln and lnsub1.
        /// mpfr_lib.mpz_clears(ln, lnsub1, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_lucnum2_ui(mpz_t ln, mpz_t lnsub1, uint /*unsigned long int*/ n)
        {
            if (ln == null) throw new ArgumentNullException("ln");
            if (lnsub1 == null) throw new ArgumentNullException("lnsub1");
            SafeNativeMethods.__mpfrz_lucnum2_ui(ln.ToIntPtr(), lnsub1.ToIntPtr(), n);
        }

        /// <summary>
        /// An implementation of the probabilistic primality test found in Knuth's Seminumerical Algorithms book.
        /// </summary>
        /// <param name="n">The operand integer.</param>
        /// <param name="reps">The number of internal passes of the probabilistic algorithm.</param>
        /// <returns>If the function <see cref="mpz_millerrabin"/> returns 0 then <paramref name="n"/> is not prime. If it returns 1, then <paramref name="n"/> is 'probably' prime.</returns>
        /// <remarks>
        /// <para>
        /// The probability of a false positive is (1/4)^<paramref name="reps"/>, where <paramref name="reps"/>
        /// is the number of internal passes of the probabilistic algorithm.
        /// Knuth indicates that 25 passes are reasonable.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_probab_prime_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 12.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(n, 12U);
        /// 
        /// // Assert that n is a composite number.
        /// Assert.IsTrue(mpfr_lib.mpz_millerrabin(n, 25) == 0);
        /// 
        /// // Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 12.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(n, 12UI)
        /// 
        /// ' Assert that n is a composite number.
        /// Assert.IsTrue(mpfr_lib.mpz_millerrabin(n, 25) = 0)
        /// 
        /// ' Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n)
        /// </code> 
        /// </example>
        public static int mpz_millerrabin(/*const*/ mpz_t n, int reps)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_millerrabin(n.ToIntPtr(), reps);
        }

        /// <summary>
        /// Set <paramref name="r"/> to <paramref name="n"/> mod <paramref name="d"/>.
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <remarks>
        /// <para>
        /// The sign of the divisor is ignored; the result is always non-negative.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod_ui"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 12222.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 12222U);
        /// 
        /// // Create, initialize, and set the value of y to 10000.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 10000U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x mod y.
        /// mpfr_lib.mpz_mod(z, x, y);
        /// 
        /// // Assert that z is 12222 mod 10000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 12222 % 10000);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 12222.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of y to 10000.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x mod y.
        /// mpfr_lib.mpz_mod(z, x, y)
        /// 
        /// ' Assert that z is 12222 mod 10000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 12222 Mod 10000)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_mod(mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_mod(r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="r"/> to <paramref name="n"/> mod <paramref name="d"/>.
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>The remainder <paramref name="r"/>.</returns>
        /// <remarks>
        /// <para>
        /// The sign of the divisor is ignored; the result is always non-negative.
        /// </para>
        /// <para>
        /// <see cref="mpz_mod_ui"/> is identical to <see cref="mpz_fdiv_r_ui"/>, returning the remainder as well as setting <paramref name="r"/>.
        /// See <see cref="mpz_fdiv_ui"/> if only the return value is wanted. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 12222.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 12222U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x mod y, and return z.
        /// Assert.IsTrue(mpfr_lib.mpz_mod_ui(z, x, 10000U) == 12222 % 10000);
        /// 
        /// // Assert that z is 12222 mod 10000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 12222 % 10000);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 12222.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x mod y, and return z.
        /// Assert.IsTrue(mpfr_lib.mpz_mod_ui(z, x, 10000UI) = 12222 Mod 10000)
        /// 
        /// ' Assert that z is 12222 mod 10000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 12222 Mod 10000)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_mod_ui(mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_fdiv_r_ui(r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul_2exp"/>
        /// <seealso cref="mpz_mul_si"/>
        /// <seealso cref="mpz_mul_ui"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 12222.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 12222U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x * y.
        /// mpfr_lib.mpz_mul(z, x, y);
        /// 
        /// // Assert that z is the product of x and y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 12222.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x * y.
        /// mpfr_lib.mpz_mul(z, x, y)
        /// 
        /// ' Assert that z is the product of x and y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_mul(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_mul(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// This operation can also be defined as a left shift by <paramref name="op2"/> bits.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_mul_si"/>
        /// <seealso cref="mpz_mul_ui"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of x to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = -10000 * 2^2.
        /// mpfr_lib.mpz_mul_2exp(z, x, 2U);
        /// 
        /// // Assert that z is -40000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == -10000 * 4);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of x to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = -10000 * 2^2.
        /// mpfr_lib.mpz_mul_2exp(z, x, 2UI)
        /// 
        /// ' Assert that z is -40000.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = -10000 * 4)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_mul_2exp(mpz_t rop, /*const*/ mpz_t op1, mp_bitcnt_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_mul_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_mul_2exp"/>
        /// <seealso cref="mpz_mul_ui"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x * 12222.
        /// mpfr_lib.mpz_mul_si(z, x, 12222);
        /// 
        /// // Assert that z is the product of x and 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == -10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x * 12222.
        /// mpfr_lib.mpz_mul_si(z, x, 12222)
        /// 
        /// ' Assert that z is the product of x and 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = -10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_mul_si(mpz_t rop, /*const*/ mpz_t op1, int /*long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_mul_si(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_mul_2exp"/>
        /// <seealso cref="mpz_mul_si"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x * 12222.
        /// mpfr_lib.mpz_mul_ui(z, x, 12222);
        /// 
        /// // Assert that z is the product of x and 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == -10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x * 12222.
        /// mpfr_lib.mpz_mul_ui(z, x, 12222)
        /// 
        /// ' Assert that z is the product of x and 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = -10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_mul_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_mul_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to -<paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = -x.
        /// mpfr_lib.mpz_neg(z, x);
        /// 
        /// // Assert that z is -x.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 10000);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = -x.
        /// mpfr_lib.mpz_neg(z, x)
        /// 
        /// ' Assert that z is -x.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 10000)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_neg(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_neg(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the next prime greater than <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result prime integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// This function uses a probabilistic algorithm to identify primes.
        /// For practical purposes it’s adequate, the chance of a composite passing will be extremely small.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_probab_prime_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 12.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 12U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the next following op.
        /// mpfr_lib.mpz_nextprime(rop, op);
        /// 
        /// // Assert that rop is 13.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 13);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpz_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 12.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 12UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the next following op.
        /// mpfr_lib.mpz_nextprime(rop, op)
        /// 
        /// ' Assert that rop is 13.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 13)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpz_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_nextprime(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_nextprime(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Determine whether <paramref name="op"/> is odd.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return non-zero if odd, zero if even.</returns>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpz_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 427294.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 427294);
        /// 
        /// // Assert that op is not odd but even.
        /// Assert.IsTrue(mpfr_lib.mpz_even_p(op) > 0);
        /// Assert.IsTrue(mpfr_lib.mpz_odd_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 427294.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 427294)
        /// 
        /// ' Assert that op is not odd but even.
        /// Assert.IsTrue(mpfr_lib.mpz_even_p(op) > 0)
        /// Assert.IsTrue(mpfr_lib.mpz_odd_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_odd_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_size != 0 && (op._mp_d[0] & 1) == 0 ? 0 : 1;
        }

        /// <summary>
        /// Output <paramref name="op"/> on stdio stream <paramref name="stream"/>, in raw binary format.
        /// </summary>
        /// <param name="stream">Pointer to file streama.</param>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return the number of bytes written, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// The integer is written in a portable format, with 4 bytes of size information, and that many bytes of limbs.
        /// Both the size and the limbs are written in decreasing significance order (i.e., in big-endian).
        /// </para>
        /// <para>
        /// The output can be read with <see cref="mpz_inp_raw"/>. 
        /// </para>
        /// <para>
        /// The output of this can not be read by <c>mpz_inp_raw</c> from MPFR 1,
        /// because of changes necessary for compatibility between 32-bit and 64-bit machines. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_out_str"/>
        /// <seealso cref="mpz_inp_str"/>
        /// <seealso cref="mpz_inp_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MPFR - I/O of Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456 (0x1E240).
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 0x1E240);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Write op to temporary file, and assert that the number of bytes written is 7.
        /// Assert.IsTrue(mpfr_lib.mpz_out_raw(stream, op) == 7);
        /// 
        /// // Close temporary file.
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that the content of the temporary file.
        /// byte[] r = System.IO.File.ReadAllBytes(pathname);
        /// Assert.IsTrue(r[0] == 0 &amp;&amp; r[1] == 0 &amp;&amp; r[2] == 0 &amp;&amp; r[3] == 3 &amp;&amp; r[4] == 0x01 &amp;&amp; r[5] == 0xE2 &amp;&amp; r[6] == 0x40);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123456 (0x1E240).
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, &amp;H1e240)
        /// 
        /// ' Get a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// 
        /// ' Open temporary file for writing.
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "w")
        /// 
        /// ' Write op to temporary file, and assert that the number of bytes written is 7.
        /// Assert.IsTrue(mpfr_lib.mpz_out_raw(stream, op) = 7)
        /// 
        /// ' Close temporary file.
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that the content of the temporary file.
        /// Dim r As Byte() = System.IO.File.ReadAllBytes(pathname)
        /// Assert.IsTrue(r(0) = 0 AndAlso r(1) = 0 AndAlso r(2) = 0 AndAlso r(3) = 3 AndAlso r(4) = &amp;H1 AndAlso r(5) = &amp;He2 AndAlso r(6) = &amp;H40)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpz_out_raw(ptr<FILE> stream, /*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrz_out_raw_x86(stream.Value.Value, op.ToIntPtr()));
            else
                return new size_t(SafeNativeMethods.__mpfrz_out_raw_x64(stream.Value.Value, op.ToIntPtr()));
        }

        /// <summary>
        /// Output <paramref name="op"/> on stdio stream <paramref name="stream"/>, as a string of digits in base <paramref name="base"/>.
        /// </summary>
        /// <param name="stream">Pointer to file stream.</param>
        /// <param name="base">The base operand.</param>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return the number of bytes written, or if an error occurred, return 0. </returns>
        /// <remarks>
        /// <para>
        /// The <paramref name="base"/> argument may vary from 2 to 62 or from -2 to -36. 
        /// </para>
        /// <para>
        /// For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used;
        /// for -2..-36, digits and upper-case letters are used; for 37..62, digits, upper-case letters,
        /// and lower-case letters (in that significance order) are used. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_inp_str"/>
        /// <seealso cref="mpz_out_raw"/>
        /// <seealso cref="mpz_inp_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Integers.html#I_002fO-of-Integers">GNU MPFR - I/O of Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 123456U);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Write op to temporary file, and assert that the number of bytes written is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_out_str(stream, 10, op) == 6);
        /// 
        /// // Close temporary file.
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that the content of the temporary file is "123456".
        /// string result = System.IO.File.ReadAllText(pathname);
        /// Assert.IsTrue(result == "123456");
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123456.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 123456UI)
        /// 
        /// ' Get a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// 
        /// ' Open temporary file for writing.
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "w")
        /// 
        /// ' Write op to temporary file, and assert that the number of bytes written is 6.
        /// Assert.IsTrue(mpfr_lib.mpz_out_str(stream, 10, op) = 6)
        /// 
        /// ' Close temporary file.
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that the content of the temporary file is "123456".
        /// Dim result As String = System.IO.File.ReadAllText(pathname)
        /// Assert.IsTrue(result = "123456")
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpz_out_str(ptr<FILE> stream, int @base, /*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrz_out_str_x86(stream.Value.Value, @base, op.ToIntPtr()));
            else
                return new size_t(SafeNativeMethods.__mpfrz_out_str_x64(stream.Value.Value, @base, op.ToIntPtr()));
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <paramref name="op"/> = a^b. 
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Non-zero if <paramref name="op"/> is a perfect power, i.e., if there exist integers a and b, with b &gt; 1, such that <paramref name="op"/> = a^b.</returns>
        /// <remarks>
        /// <para>
        /// Under this definition both 0 and 1 are considered to be perfect powers. Negative values of <paramref name="op"/> are accepted, but of course can only be odd perfect powers. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_perfect_square_p"/>
        /// <seealso cref="mpz_root"/>
        /// <seealso cref="mpz_rootrem"/>
        /// <seealso cref="mpz_sqrt"/>
        /// <seealso cref="mpz_sqrtrem"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Roots.html#Integer-Roots">GNU MPFR - Integer Roots</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, 10000);
        /// 
        /// // Assert that op is a perfect power.
        /// Assert.IsTrue(mpfr_lib.mpz_perfect_power_p(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, 10000)
        /// 
        /// ' Assert that op is a perfect power.
        /// Assert.IsTrue(mpfr_lib.mpz_perfect_power_p(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_perfect_power_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_perfect_power_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is a perfect square, i.e., if the square root of <paramref name="op"/> is an integer.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Non-zero if <paramref name="op"/> is a perfect square, i.e., if the square root of <paramref name="op"/> is an integer.</returns>
        /// <remarks>
        /// <para>
        /// Under this definition both 0 and 1 are considered to be perfect squares. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_perfect_power_p"/>
        /// <seealso cref="mpz_root"/>
        /// <seealso cref="mpz_rootrem"/>
        /// <seealso cref="mpz_sqrt"/>
        /// <seealso cref="mpz_sqrtrem"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Roots.html#Integer-Roots">GNU MPFR - Integer Roots</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, 10000);
        /// 
        /// // Assert that op is a perfect square.
        /// Assert.IsTrue(mpfr_lib.mpz_perfect_square_p(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, 10000)
        /// 
        /// ' Assert that op is a perfect square.
        /// Assert.IsTrue(mpfr_lib.mpz_perfect_square_p(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_perfect_square_p(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_perfect_square_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return the population count of <paramref name="op"/>.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>If <paramref name="op"/> &#8805; 0, return the population count of <paramref name="op"/>, which is the number of 1 bits in the binary representation. If <paramref name="op"/> &lt; 0, the number of 1s is infinite, and the return value is the largest possible <see cref="mp_bitcnt_t"/>.</returns>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 63.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 63U);
        /// 
        /// // Assert that op has 6 one bits.
        /// Assert.IsTrue(mpfr_lib.mpz_popcount(op) == 6U);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clears(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 63.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 63UI)
        /// 
        /// ' Assert that op has 6 one bits.
        /// Assert.IsTrue(mpfr_lib.mpz_popcount(op) = 6UI)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpz_popcount(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrz_popcount(op.ToIntPtr()));
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="base"/>^<paramref name="exp"/>. The case 0^0 yields 1. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="base">The base integer.</param>
        /// <param name="exp">The exponent integer.</param>
        /// <seealso cref="mpz_powm"/>
        /// <seealso cref="mpz_powm_ui"/>
        /// <seealso cref="mpz_powm_sec"/>
        /// <seealso cref="mpz_ui_pow_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MPFR - Integer Exponentiation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of base to 2.
        /// mpz_t @base = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(@base, 2U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = base^4.
        /// mpfr_lib.mpz_pow_ui(rop, @base, 4U);
        /// 
        /// // Assert that rop is 16.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 16);
        /// 
        /// // Release unmanaged memory allocated for rop and base.
        /// mpfr_lib.mpz_clears(rop, @base, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of base to 2.
        /// Dim base As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(base, 2UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = base^4.
        /// mpfr_lib.mpz_pow_ui(rop, base, 4UI)
        /// 
        /// ' Assert that rop is 16.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 16)
        /// 
        /// ' Release unmanaged memory allocated for rop and base.
        /// mpfr_lib.mpz_clears(rop, base, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_pow_ui(mpz_t rop, /*const*/ mpz_t @base, uint /*unsigned long int*/ exp)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (@base == null) throw new ArgumentNullException("base");
            SafeNativeMethods.__mpfrz_pow_ui(rop.ToIntPtr(), @base.ToIntPtr(), exp);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="base"/>^<paramref name="exp"/>) modulo <paramref name="mod"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="base">The base integer.</param>
        /// <param name="exp">The exponent integer.</param>
        /// <param name="mod">The modulo integer.</param>
        /// <remarks>
        /// <para>
        /// Negative <paramref name="exp"/> is supported if an inverse <paramref name="base"/>^-1 modulo <paramref name="mod"/> exists (see <see cref="mpz_invert"/>).
        /// If an inverse doesn’t exist then a divide by zero is raised.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_powm_ui"/>
        /// <seealso cref="mpz_powm_sec"/>
        /// <seealso cref="mpz_pow_ui"/>
        /// <seealso cref="mpz_ui_pow_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MPFR - Integer Exponentiation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of base to 2.
        /// mpz_t @base = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(@base, 2U);
        /// 
        /// // Create, initialize, and set the value of exp to 4.
        /// mpz_t exp = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(exp, 4U);
        /// 
        /// // Create, initialize, and set the value of mod to 3.
        /// mpz_t mod = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(mod, 3U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = base^exp mod mod.
        /// mpfr_lib.mpz_powm(rop, @base, exp, mod);
        /// 
        /// // Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop, base, exp, and mod.
        /// mpfr_lib.mpz_clears(rop, @base, exp, mod, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of base to 2.
        /// Dim base As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(base, 2UI)
        /// 
        /// ' Create, initialize, and set the value of exp to 4.
        /// Dim exp As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(exp, 4UI)
        /// 
        /// ' Create, initialize, and set the value of mod to 3.
        /// Dim[mod] As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui([mod], 3UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = base^exp mod mod.
        /// mpfr_lib.mpz_powm(rop, base, exp, [mod])
        /// 
        /// ' Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop, base, exp, and mod.
        /// mpfr_lib.mpz_clears(rop, base, exp, [mod], Nothing)
        /// </code> 
        /// </example>
        public static void mpz_powm(mpz_t rop, /*const*/ mpz_t @base, /*const*/ mpz_t exp, /*const*/ mpz_t mod)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (@base == null) throw new ArgumentNullException("base");
            if (exp == null) throw new ArgumentNullException("exp");
            if (mod == null) throw new ArgumentNullException("mod");
            SafeNativeMethods.__mpfrz_powm(rop.ToIntPtr(), @base.ToIntPtr(), exp.ToIntPtr(), mod.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="base"/>^<paramref name="exp"/>) modulo <paramref name="mod"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="base">The base integer.</param>
        /// <param name="exp">The exponent integer.</param>
        /// <param name="mod">The modulo integer.</param>
        /// <remarks>
        /// <para>
        /// It is required that <paramref name="exp"/> &gt; 0 and that <paramref name="mod"/> is odd.
        /// </para>
        /// <para>
        /// This function is designed to take the same time and have the same cache access patterns for any two same-size arguments,
        /// assuming that function arguments are placed at the same position and that the machine state is identical upon function entry.
        /// This function is intended for cryptographic purposes, where resilience to side-channel attacks is desired. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_powm"/>
        /// <seealso cref="mpz_powm_ui"/>
        /// <seealso cref="mpz_pow_ui"/>
        /// <seealso cref="mpz_ui_pow_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MPFR - Integer Exponentiation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of base to 2.
        /// mpz_t @base = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(@base, 2U);
        /// 
        /// // Create, initialize, and set the value of exp to 4.
        /// mpz_t exp = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(exp, 4U);
        /// 
        /// // Create, initialize, and set the value of mod to 3.
        /// mpz_t mod = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(mod, 3U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = base^exp mod mod.
        /// mpfr_lib.mpz_powm_sec(rop, @base, exp, mod);
        /// 
        /// // Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop, base, exp, and mod.
        /// mpfr_lib.mpz_clears(rop, @base, exp, mod, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of base to 2.
        /// Dim base As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(base, 2UI)
        /// 
        /// ' Create, initialize, and set the value of exp to 4.
        /// Dim exp As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(exp, 4UI)
        /// 
        /// ' Create, initialize, and set the value of mod to 3.
        /// Dim[mod] As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui([mod], 3UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = base^exp mod mod.
        /// mpfr_lib.mpz_powm_sec(rop, base, exp, [mod])
        /// 
        /// ' Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop, base, exp, and mod.
        /// mpfr_lib.mpz_clears(rop, base, exp, [mod], Nothing)
        /// </code> 
        /// </example>
        public static void mpz_powm_sec(mpz_t rop, /*const*/ mpz_t @base, /*const*/ mpz_t exp, /*const*/ mpz_t mod)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (@base == null) throw new ArgumentNullException("base");
            if (exp == null) throw new ArgumentNullException("exp");
            if (mod == null) throw new ArgumentNullException("mod");
            SafeNativeMethods.__mpfrz_powm_sec(rop.ToIntPtr(), @base.ToIntPtr(), exp.ToIntPtr(), mod.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to (<paramref name="base"/>^<paramref name="exp"/>) modulo <paramref name="mod"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="base">The base integer.</param>
        /// <param name="exp">The exponent integer.</param>
        /// <param name="mod">The modulo integer.</param>
        /// <remarks>
        /// <para>
        /// Negative <paramref name="exp"/> is supported if an inverse <paramref name="base"/>^-1 modulo <paramref name="mod"/> exists (see <see cref="mpz_invert"/>).
        /// If an inverse doesn’t exist then a divide by zero is raised.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_powm"/>
        /// <seealso cref="mpz_powm_sec"/>
        /// <seealso cref="mpz_pow_ui"/>
        /// <seealso cref="mpz_ui_pow_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MPFR - Integer Exponentiation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of base to 2.
        /// mpz_t @base = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(@base, 2U);
        /// 
        /// mpz_t mod = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(mod, 3U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = base^4 mod mod.
        /// mpfr_lib.mpz_powm_ui(rop, @base, 4U, mod);
        /// 
        /// // Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 1);
        /// 
        /// // Release unmanaged memory allocated for rop, base, and mod.
        /// mpfr_lib.mpz_clears(rop, @base, mod, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of base to 2.
        /// Dim base As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(base, 2UI)
        /// Dim[mod] As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui([mod], 3UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = base^4 mod mod.
        /// mpfr_lib.mpz_powm_ui(rop, base, 4UI, [mod])
        /// 
        /// ' Assert that rop is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 1)
        /// 
        /// ' Release unmanaged memory allocated for rop, base, and mod.
        /// mpfr_lib.mpz_clears(rop, base, [mod], Nothing)
        /// </code> 
        /// </example>
        public static void mpz_powm_ui(mpz_t rop, /*const*/ mpz_t @base, uint /*unsigned long int*/ exp, /*const*/ mpz_t mod)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (@base == null) throw new ArgumentNullException("base");
            if (mod == null) throw new ArgumentNullException("mod");
            SafeNativeMethods.__mpfrz_powm_ui(rop.ToIntPtr(), @base.ToIntPtr(), exp, mod.ToIntPtr());
        }

        /// <summary>
        /// Determine whether <paramref name="n"/> is prime.
        /// </summary>
        /// <param name="n">The operand integer.</param>
        /// <param name="reps">The number of Miller-Rabin probabilistic primality tests to perform.</param>
        /// <returns>Return 2 if <paramref name="n"/> is definitely prime, return 1 if <paramref name="n"/> is probably prime (without being certain), or return 0 if <paramref name="n"/> is definitely non-prime.</returns>
        /// <remarks>
        /// <para>
        /// This function performs some trial divisions, then <paramref name="reps"/> Miller-Rabin probabilistic primality tests.
        /// A higher <paramref name="reps"/> value will reduce the chances of a non-prime being identified as “probably prime”.
        /// A composite number will be identified as a prime with a probability of less than 4^(-reps).
        /// Reasonable values of <paramref name="reps"/> are between 15 and 50.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_millerrabin"/>
        /// <seealso cref="mpz_nextprime"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 12.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(n, 12U);
        /// 
        /// // Assert that n is a composite number.
        /// Assert.IsTrue(mpfr_lib.mpz_probab_prime_p(n, 25) == 0);
        /// 
        /// // Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 12.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(n, 12UI)
        /// 
        /// ' Assert that n is a composite number.
        /// Assert.IsTrue(mpfr_lib.mpz_probab_prime_p(n, 25) = 0)
        /// 
        /// ' Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n)
        /// </code> 
        /// </example>
        public static int mpz_probab_prime_p(/*const*/ mpz_t n, int reps)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_probab_prime_p(n.ToIntPtr(), reps);
        }

        /// <summary>
        /// Generate a random integer of at most <paramref name="max_size"/> limbs.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="max_size">The maximum number of limbs.</param>
        /// <remarks>
        /// <para>
        /// The generated random number doesn’t satisfy any particular requirements of randomness.
        /// Negative random numbers are generated when <paramref name="max_size"/> is negative.
        /// </para>
        /// <para>
        /// This function is obsolete. Use <see cref="mpz_urandomb"/> or <see cref="mpz_urandomm"/> instead.
        /// </para>
        /// <para>
        /// The random number functions of MPFR come in two groups; older function that rely on a global state, 
        /// and newer functions that accept a state parameter that is read and modified.
        /// Please see the <a href="https://mpfrlib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MPFR - Random Number Functions</a>
        /// for more information on how to use and not to use random number functions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_urandomb"/>
        /// <seealso cref="mpz_urandomm"/>
        /// <seealso cref="mpz_rrandomb"/>
        /// <seealso cref="mpz_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MPFR - Integer Random Numbers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Generate a random integer.
        /// mpfr_lib.mpz_random(rop, 500);
        /// 
        /// // Free all memory occupied by state and rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Generate a random integer.
        /// mpfr_lib.mpz_random(rop, 500)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_random(mpz_t rop, mp_size_t max_size)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_random(rop.ToIntPtr(), max_size);
        }

        /// <summary>
        /// Generate a random integer of at most <paramref name="max_size"/> limbs, with long strings of zeros and ones in the binary representation.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="max_size">The maximum number of limbs.</param>
        /// <remarks>
        /// <para>
        /// Useful for testing functions and algorithms, since this kind of random numbers have proven to be more likely to trigger corner-case bugs.
        /// Negative random numbers are generated when <paramref name="max_size"/> is negative. 
        /// </para>
        /// <para>
        /// This function is obsolete. Use <see cref="mpz_rrandomb"/> instead.
        /// </para>
        /// <para>
        /// The random number functions of MPFR come in two groups; older function that rely on a global state, 
        /// and newer functions that accept a state parameter that is read and modified.
        /// Please see the <a href="https://mpfrlib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MPFR - Random Number Functions</a>
        /// for more information on how to use and not to use random number functions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_urandomb"/>
        /// <seealso cref="mpz_urandomm"/>
        /// <seealso cref="mpz_rrandomb"/>
        /// <seealso cref="mpz_random"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MPFR - Integer Random Numbers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Generate a random integer.
        /// mpfr_lib.mpz_random(rop, 100);
        /// 
        /// // Free all memory occupied by rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Generate a random integer.
        /// mpfr_lib.mpz_random(rop, 100)
        /// 
        /// ' Free all memory occupied by rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_random2(mpz_t rop, mp_size_t max_size)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_random2(rop.ToIntPtr(), max_size);
        }

        /// <summary>
        /// Change the space allocated for <paramref name="x"/> to <paramref name="n"/> bits.
        /// </summary>
        /// <param name="x">The integer.</param>
        /// <param name="n">The number of bits.</param>
        /// <remarks>
        /// <para>
        /// The value in <paramref name="x"/> is preserved if it fits, or is set to 0 if not.
        /// </para>
        /// <para>
        /// Calling this function is never necessary; reallocation is handled automatically by MPFR when
        /// needed. But this function can be used to increase the space for a variable in order to avoid
        /// repeated automatic reallocations, or to decrease it to give memory back to the heap.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_clear"/>
        /// <seealso cref="mpz_clears"/>
        /// <seealso cref="mpz_init"/>
        /// <seealso cref="mpz_inits"/>
        /// <seealso cref="mpz_init2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Integers.html#Initializing-Integers">GNU MPFR - Initializing Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x to a 77-bit integer.
        /// char_ptr value = new char_ptr("1000 0000 0000 0000 0000");
        /// mpfr_lib.mpz_set_str(x, value, 16);
        /// 
        /// // Resize x to 512 bits, and assert that its value has not changed.
        /// mpfr_lib.mpz_realloc2(x, 512U);
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, 16, x);
        /// Assert.IsTrue(s.ToString() == "1000 0000 0000 0000 0000".Replace(" ", ""));
        /// 
        /// // Resize x to 2 bits, and assert that its value has changed to 0.
        /// mpfr_lib.mpz_realloc2(x, 2U);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 0);
        /// 
        /// // Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(value);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x to a 77-bit integer.
        /// Dim value As New char_ptr("1000 0000 0000 0000 0000")
        /// mpfr_lib.mpz_set_str(x, value, 16)
        /// 
        /// ' Resize x to 512 bits, and assert that its value has not changed.
        /// mpfr_lib.mpz_realloc2(x, 512UI)
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 16, x)
        /// Assert.IsTrue(s.ToString() = "1000 0000 0000 0000 0000".Replace(" ", ""))
        /// 
        /// ' Resize x to 2 bits, and assert that its value has changed to 0.
        /// mpfr_lib.mpz_realloc2(x, 2UI)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(value)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static void mpz_realloc2(mpz_t x, mp_bitcnt_t n)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_realloc2(x.ToIntPtr(), n);
        }

        /// <summary>
        /// Remove all occurrences of the factor <paramref name="f"/> from <paramref name="op"/> and store the result in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <param name="f">The factor operand integer.</param>
        /// <returns>The return value is how many such occurrences were removed.</returns>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions">GNU MPFR - Number Theoretic Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 45.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 45U);
        /// 
        /// // Create, initialize, and set the value of f to 3.
        /// mpz_t f = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(f, 3U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = op / f^n, and return n, the largest integer greater than or equal to 0, such that f^n divides op.
        /// Assert.IsTrue(mpfr_lib.mpz_remove(rop, op, f) == 2);
        /// 
        /// // Assert that rop is 5.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 5);
        /// 
        /// // Release unmanaged memory allocated for rop, op, and f.
        /// mpfr_lib.mpz_clears(rop, op, f, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 45.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 45UI)
        /// 
        /// ' Create, initialize, and set the value of f to 3.
        /// Dim f As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(f, 3UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = op / f^n, and return n, the largest integer greater than or equal to 0, such that f^n divides op.
        /// Assert.IsTrue(mpfr_lib.mpz_remove(rop, op, f) = 2)
        /// 
        /// ' Assert that rop is 5.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 5)
        /// 
        /// ' Release unmanaged memory allocated for rop, op, and f.
        /// mpfr_lib.mpz_clears(rop, op, f, Nothing)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpz_remove(mpz_t rop, /*const*/ mpz_t op, /*const*/ mpz_t f)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            if (f == null) throw new ArgumentNullException("f");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrz_remove(rop.ToIntPtr(), op.ToIntPtr(), f.ToIntPtr()));
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the truncated integer part of the <paramref name="n"/>th root of <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result root integer.</param>
        /// <param name="op">The first operand integer.</param>
        /// <param name="n">The second operand integer.</param>
        /// <returns>Return non-zero if the computation was exact, i.e., if <paramref name="op"/> is <paramref name="rop"/> to the <paramref name="n"/>th power.</returns>
        /// <seealso cref="mpz_perfect_power_p"/>
        /// <seealso cref="mpz_perfect_square_p"/>
        /// <seealso cref="mpz_rootrem"/>
        /// <seealso cref="mpz_sqrt"/>
        /// <seealso cref="mpz_sqrtrem"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Roots.html#Integer-Roots">GNU MPFR - Integer Roots</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 10000.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, 10000);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = trunc(cbrt(10000)).
        /// mpfr_lib.mpz_root(rop, op, 3U);
        /// 
        /// // Assert that rop is 21.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 21);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 10000.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, 10000)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = trunc(cbrt(10000)).
        /// mpfr_lib.mpz_root(rop, op, 3UI)
        /// 
        /// ' Assert that rop is 21.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 21)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static int mpz_root(mpz_t rop, /*const*/ mpz_t op, uint /*unsigned long int*/ n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_root(rop.ToIntPtr(), op.ToIntPtr(), n);
        }

        /// <summary>
        /// Set <paramref name="root"/> to the truncated integer part of the <paramref name="n"/>th root of <paramref name="u"/>. Set <paramref name="rem"/> to the remainder, <paramref name="u"/> - <paramref name="root"/>^<paramref name="n"/>. 
        /// </summary>
        /// <param name="root">The result root integer.</param>
        /// <param name="rem">The result remainder integer.</param>
        /// <param name="u">The first operand integer.</param>
        /// <param name="n">The second operand integer.</param>
        /// <seealso cref="mpz_perfect_power_p"/>
        /// <seealso cref="mpz_perfect_square_p"/>
        /// <seealso cref="mpz_root"/>
        /// <seealso cref="mpz_sqrt"/>
        /// <seealso cref="mpz_sqrtrem"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Roots.html#Integer-Roots">GNU MPFR - Integer Roots</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of u to 10000.
        /// mpz_t u = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(u, 10000);
        /// 
        /// // Create, initialize, and set the values of root and rem to 0.
        /// mpz_t root = new mpz_t();
        /// mpz_t rem = new mpz_t();
        /// mpfr_lib.mpz_inits(root, rem, null);
        /// 
        /// // Set root = trunc(cbrt(10000)) and rem = u - root.
        /// mpfr_lib.mpz_rootrem(root, rem, u, 3U);
        /// 
        /// // Assert that root is 21, and rem is 739.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(root) == 21);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rem) == 739);
        /// 
        /// // Release unmanaged memory allocated for root, rem, and u.
        /// mpfr_lib.mpz_clears(root, rem, u, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of u to 10000.
        /// Dim u As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(u, 10000)
        /// 
        /// ' Create, initialize, and set the values of root and rem to 0.
        /// Dim root As New mpz_t()
        /// Dim[rem] As New mpz_t()
        /// mpfr_lib.mpz_inits(root, [rem], Nothing)
        /// 
        /// ' Set root = trunc(cbrt(10000)) and rem = u - root.
        /// mpfr_lib.mpz_rootrem(root, [rem], u, 3UI)
        /// 
        /// ' Assert that root is 21, and rem is 739.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(root) = 21)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si([rem]) = 739)
        /// 
        /// ' Release unmanaged memory allocated for root, rem, and u.
        /// mpfr_lib.mpz_clears(root, [rem], u, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_rootrem(mpz_t root, mpz_t rem, /*const*/ mpz_t u, uint /*unsigned long int*/ n)
        {
            if (root == null) throw new ArgumentNullException("root");
            if (rem == null) throw new ArgumentNullException("rem");
            if (u == null) throw new ArgumentNullException("u");
            SafeNativeMethods.__mpfrz_rootrem(root.ToIntPtr(), rem.ToIntPtr(), u.ToIntPtr(), n);
        }

        /// <summary>
        /// Generate a random integer with long strings of zeros and ones in the binary representation.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="state">The random number generator state.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// Useful for testing functions and algorithms, since this kind of random numbers have proven to be more
        /// likely to trigger corner-case bugs. The random number will be in the
        /// range 2^(<paramref name="n"/> - 1) to 2^<paramref name="n"/> - 1, inclusive. 
        /// </para>
        /// <para>
        /// The variable <paramref name="state"/> must be initialized by calling one of the <c>mpfr_randinit</c>
        /// functions (<a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a>) before invoking this function. 
        /// </para>
        /// <para>
        /// The random number functions of MPFR come in two groups; older function that rely on a global state, 
        /// and newer functions that accept a state parameter that is read and modified.
        /// Please see the <a href="https://mpfrlib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MPFR - Random Number Functions</a>
        /// for more information on how to use and not to use random number functions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_urandomb"/>
        /// <seealso cref="mpz_urandomm"/>
        /// <seealso cref="mpz_random"/>
        /// <seealso cref="mpz_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MPFR - Integer Random Numbers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// mpfr_lib.mpfr_randseed_ui(state, 100000U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Generate a random integer in the range [2^(50-1), (2^50)-1].
        /// mpfr_lib.mpz_rrandomb(rop, state, 50);
        /// 
        /// // Free all memory occupied by state and rop.
        /// mpfr_lib.mpfr_randclear(state);
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As New mpfr_randstate_t()
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// mpfr_lib.mpfr_randseed_ui(state, 100000UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Generate a random integer in the range [2^(50-1), (2^50)-1].
        /// mpfr_lib.mpz_rrandomb(rop, state, 50)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// mpfr_lib.mpfr_randclear(state)
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_rrandomb(mpz_t rop, mpfr_randstate_t state, mp_bitcnt_t n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfrz_rrandomb(rop.ToIntPtr(), state.ToIntPtr(), n);
        }

        /// <summary>
        /// Scan <paramref name="op"/> for 0 bit.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <param name="starting_bit">The start bit index position.</param>
        /// <returns>Return the index of the found bit.</returns>
        /// <remarks>
        /// <para>
        /// Scan <paramref name="op"/>, starting from bit <paramref name="starting_bit"/>, towards more significant bits,
        /// until the first 0 bit is found. Return the index of the found bit.
        /// </para>
        /// <para>
        /// If the bit at <paramref name="starting_bit"/> is already what’s sought,
        /// then <paramref name="starting_bit"/> is returned. 
        /// </para>
        /// <para>
        /// If there’s no bit found, then the largest possible <see cref="mp_bitcnt_t"/> is returned.
        /// This will happen in <see cref="mpz_scan0"/> past the end of a negative number,
        /// or <see cref="mpz_scan1"/> past the end of a nonnegative number. 
        /// </para>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 70.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 70U);
        /// 
        /// // Assert that the first 0 bit starting from bit 1 in op is bit 3.
        /// Assert.IsTrue(mpfr_lib.mpz_scan0(op, 1U) == 3U);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 70.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 70UI)
        /// 
        /// ' Assert that the first 0 bit starting from bit 1 in op is bit 3.
        /// Assert.IsTrue(mpfr_lib.mpz_scan0(op, 1UI) = 3UI)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpz_scan0(/*const*/ mpz_t op, mp_bitcnt_t starting_bit)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_scan0(op.ToIntPtr(), starting_bit);
        }

        /// <summary>
        /// Scan <paramref name="op"/> for 1 bit.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <param name="starting_bit">The start bit index position.</param>
        /// <returns>Return the index of the found bit.</returns>
        /// <remarks>
        /// <para>
        /// Scan <paramref name="op"/>, starting from bit <paramref name="starting_bit"/>, towards more significant bits,
        /// until the first 1 bit is found. Return the index of the found bit.
        /// </para>
        /// <para>
        /// If the bit at <paramref name="starting_bit"/> is already what’s sought,
        /// then <paramref name="starting_bit"/> is returned. 
        /// </para>
        /// <para>
        /// If there’s no bit found, then the largest possible <see cref="mp_bitcnt_t"/> is returned.
        /// This will happen in <see cref="mpz_scan0"/> past the end of a negative number,
        /// or <see cref="mpz_scan1"/> past the end of a nonnegative number. 
        /// </para>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 70.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op, 70U);
        /// 
        /// // Assert that the first 1 bit starting from bit 3 in op is bit 6.
        /// Assert.IsTrue(mpfr_lib.mpz_scan1(op, 3U) == 6U);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 70.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op, 70UI)
        /// 
        /// ' Assert that the first 1 bit starting from bit 3 in op is bit 6.
        /// Assert.IsTrue(mpfr_lib.mpz_scan1(op, 3UI) = 6UI)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpz_scan1(/*const*/ mpz_t op, mp_bitcnt_t starting_bit)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_scan1(op.ToIntPtr(), starting_bit);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer x to 10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// mpfr_lib.mpz_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new integer y to -210.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init(y);
        /// mpfr_lib.mpz_set_si(y, -210);
        /// 
        /// // Assign the value of y to x.
        /// mpfr_lib.mpz_set(x, y);
        /// 
        /// // Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == -210);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer x to 10.
        /// Dim x As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init(x)
        /// mpfr_lib.mpz_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new integer y to -210.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init(y)
        /// mpfr_lib.mpz_set_si(y, -210)
        /// 
        /// ' Assign the value of y to x.
        /// mpfr_lib.mpz_set(x, y)
        /// 
        /// ' Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = -210)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_set(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_set(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <remarks>
        /// <para>
        /// <see cref="mpz_set_d"/> truncate <paramref name="op"/> to make it an integer.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x to the truncation of 10.7.
        /// mpfr_lib.mpz_set_d(x, 10.7D);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 10);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x to the truncation of 10.7.
        /// mpfr_lib.mpz_set_d(x, 10.7)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 10)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_set_d(mpz_t rop, double op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_set_d(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <remarks>
        /// <para>
        /// <see cref="mpz_set_f"/> truncate <paramref name="op"/> to make it an integer.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x, and float y.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// mpf_t y = "1.7007e3";
        /// 
        /// // Set the value of x to the truncation of 1700.7.
        /// mpfr_lib.mpz_set_f(x, y);
        /// 
        /// // Assert that the value of x is 1700.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 1700);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.mpf_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x, and float y.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// Dim y As mpf_t = "1.7007e3"
        /// 
        /// ' Set the value of x to the truncation of 1700.7.
        /// mpfr_lib.mpz_set_f(x, y)
        /// 
        /// ' Assert that the value of x is 1700.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 1700)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.mpf_clear(y)
        /// </code> 
        /// </example>
        public static void mpz_set_f(mpz_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_set_f(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <remarks>
        /// <para>
        /// <see cref="mpz_set_q"/> truncate <paramref name="op"/> to make it an integer.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x, and rational y.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// mpq_t y = "100/3";
        /// 
        /// // Set the value of x to the truncation of 100/3.
        /// mpfr_lib.mpz_set_q(x, y);
        /// 
        /// // Assert that the value of x is 33.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == 33);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.mpq_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x, and rational y.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// Dim y As mpq_t = "100/3"
        /// 
        /// ' Set the value of x to the truncation of 100/3.
        /// mpfr_lib.mpz_set_q(x, y)
        /// 
        /// ' Assert that the value of x is 33.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = 33)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.mpq_clear(y)
        /// </code> 
        /// </example>
        public static void mpz_set_q(mpz_t rop, /*const*/ mpq_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_set_q(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x to -10.
        /// mpfr_lib.mpz_set_si(x, -10);
        /// 
        /// // Assert that the value of x is -10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == -10);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x to -10.
        /// mpfr_lib.mpz_set_si(x, -10)
        /// 
        /// ' Assert that the value of x is -10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = -10)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_set_si(mpz_t rop, int /*long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_set_si(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="str"/>, a null-terminated C string in base <paramref name="base"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="str">The source integer.</param>
        /// <param name="base">The base.</param>
        /// <returns>This function returns 0 if the entire string is a valid number in base <paramref name="base"/>. Otherwise it returns −1.</returns>
        /// <remarks>
        /// <para>
        /// White space is allowed in the string, and is simply ignored.
        /// </para>
        /// <para>
        /// The base may vary from 2 to 62, or if base is 0, then the leading characters are
        /// used: 0x and 0X for hexadecimal, 0b and 0B for binary, 0 for octal,
        /// or decimal otherwise.
        /// </para>
        /// <para>
        /// For bases up to 36, case is ignored; upper-case and lower-case letters have the same value.
        /// For bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case
        /// letter represent 36..61.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x.
        /// char_ptr value = new char_ptr("12 345 678 909 876 543 211 234 567 890 987 654 321");
        /// mpfr_lib.mpz_set_str(x, value, 10);
        /// 
        /// // Assert the value of x.
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == value.ToString().Replace(" ", ""));
        /// 
        /// // Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(value);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x.
        /// Dim value As New char_ptr("12 345 678 909 876 543 211 234 567 890 987 654 321")
        /// mpfr_lib.mpz_set_str(x, value, 10)
        /// 
        /// ' Assert the value of x.
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, 10, x)
        /// Assert.IsTrue(s.ToString() = value.ToString().Replace(" ", ""))
        /// 
        /// ' Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(value)
        /// mpfr_lib.free(s) 
        /// </code> 
        /// </example>
        public static int mpz_set_str(mpz_t rop, /*const*/ char_ptr str, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.__mpfrz_set_str(rop.ToIntPtr(), str.ToIntPtr(), @base);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The destination integer.</param>
        /// <param name="op">The source integer.</param>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpz_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x to 10.
        /// mpfr_lib.mpz_set_ui(x, 10U);
        /// 
        /// // Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) == 10U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new integer x.
        /// Dim x As New mpz_t()
        /// 
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x to 10.
        /// mpfr_lib.mpz_set_ui(x, 10UI)
        /// 
        /// ' Assert that the value of x is 10.
        /// Assert.IsTrue(mpfr_lib.mpz_get_ui(x) = 10UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpz_clear(x)
        /// </code> 
        /// </example>
        public static void mpz_set_ui(mpz_t rop, uint /*unsigned long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_set_ui(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set bit <paramref name="bit_index"/> in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="bit_index">The index of the bit to set.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 70.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(rop, 70);
        /// 
        /// // Set bit 3 of rop.
        /// mpfr_lib.mpz_setbit(rop, 3U);
        /// 
        /// // Assert that rop is 78.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 78);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 70.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(rop, 70)
        /// 
        /// ' Set bit 3 of rop.
        /// mpfr_lib.mpz_setbit(rop, 3UI)
        /// 
        /// ' Assert that rop is 78.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 78)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_setbit(mpz_t rop, mp_bitcnt_t bit_index)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_setbit(rop.ToIntPtr(), bit_index);
        }

        /// <summary>
        /// Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0.</returns>
        /// <seealso cref="mpz_cmp"/>
        /// <seealso cref="mpz_cmp_d"/>
        /// <seealso cref="mpz_cmp_si"/>
        /// <seealso cref="mpz_cmp_ui"/>
        /// <seealso cref="mpz_cmpabs"/>
        /// <seealso cref="mpz_cmpabs_d"/>
        /// <seealso cref="mpz_cmpabs_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Comparisons.html#Integer-Comparisons">GNU MPFR - Integer Comparisons</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -10.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, -10);
        /// 
        /// // Assert that the sign of op is -1.
        /// Assert.IsTrue(mpfr_lib.mpz_sgn(op) == -1);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -10.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, -10)
        /// 
        /// ' Assert that the sign of op is -1.
        /// Assert.IsTrue(mpfr_lib.mpz_sgn(op) = -1)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static int mpz_sgn(mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_size < 0 ? -1 : (op._mp_size > 0 ? 1 : 0);
        }

        /// <summary>
        /// Return the size of <paramref name="op"/> measured in number of limbs.
        /// </summary>
        /// <param name="op">The operand integer.</param>
        /// <returns>The size of <paramref name="op"/> measured in number of limbs.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is zero, the returned value will be zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t op = new mpz_t();
        /// char_ptr value = new char_ptr("1000 ABCD 1234 7AB8 24FD");
        /// mpfr_lib.mpz_init_set_str(op, value, 16);
        ///
        /// // Assert the value of the limbs of op.
        /// if (mpfr_lib.mp_bytes_per_limb == 4)
        ///     Assert.IsTrue(mpfr_lib.mpz_size(op) == 3);
        /// else // mpfr_lib.mp_bytes_per_limb == 8
        ///     Assert.IsTrue(mpfr_lib.mpz_size(op) == 2);
        /// 
        /// // Release unmanaged memory allocated for op and value.
        /// mpfr_lib.mpz_clear(op);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim op As New mpz_t()
        /// Dim value As New char_ptr("1000 ABCD 1234 7AB8 24FD")
        /// mpfr_lib.mpz_init_set_str(op, value, 16)
        /// 
        /// ' Assert the value of the limbs of op.
        /// If mpfr_lib.mp_bytes_per_limb = 4 Then
        ///     Assert.IsTrue(mpfr_lib.mpz_size(op) = 3)
        /// Else ' mpfr_lib.mp_bytes_per_limb == 8
        ///     Assert.IsTrue(mpfr_lib.mpz_size(op) = 2)
        /// End If
        /// 
        /// ' Release unmanaged memory allocated for op and value.
        /// mpfr_lib.mpz_clear(op)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static mp_size_t mpz_size(/*const*/ mpz_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return new mp_size_t(SafeNativeMethods.__mpfrz_size(op.ToIntPtr()));
        }

        /// <summary>
        /// Return the size of <paramref name="op"/> measured in number of digits in the given <paramref name="base"/>.
        /// </summary>
        /// <param name="op">The operand integer</param>
        /// <param name="base">The base.</param>
        /// <returns>The size of <paramref name="op"/> measured in number of digits in the given <paramref name="base"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="base"/> can vary from 2 to 62.
        /// The sign of <paramref name="op"/> is ignored, just the absolute value is used.
        /// The result will be either exact or 1 too big.
        /// If <paramref name="base"/> is a power of 2, the result is always exact.
        /// If <paramref name="op"/> is zero the return value is always 1.
        /// </para>
        /// <para>
        /// This function can be used to determine the space required when converting <paramref name="op"/> to a string.
        /// The right amount of allocation is normally two more than the value returned by <see cref="mpz_sizeinbase"/>,
        /// one extra for a minus sign and one for the null-terminator. 
        /// </para>
        /// <para>
        /// It will be noted that mpz_sizeinbase(<paramref name="op"/>, 2) can be used to locate the most
        /// significant 1 bit in <paramref name="op"/>, counting from 1.
        /// (Unlike the bitwise functions which start from 0,
        /// see <a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Logical and Bit Manipulation Functions</a>.)
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_fits_ulong_p"/>
        /// <seealso cref="mpz_fits_slong_p"/>
        /// <seealso cref="mpz_fits_uint_p"/>
        /// <seealso cref="mpz_fits_sint_p"/>
        /// <seealso cref="mpz_fits_ushort_p"/>
        /// <seealso cref="mpz_fits_sshort_p"/>
        /// <seealso cref="mpz_odd_p"/>
        /// <seealso cref="mpz_even_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Integer-Functions.html#Miscellaneous-Integer-Functions">GNU MPFR - Miscellaneous Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 10000.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, 10000);
        /// 
        /// // Assert size in different bases.
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 2) == 14);
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 8) == 5);
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 10) == 5);
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 16) == 4);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 10000.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, 10000)
        /// 
        /// ' Assert size in different bases.
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 2) = 14)
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 8) = 5)
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 10) = 5)
        /// Assert.IsTrue(mpfr_lib.mpz_sizeinbase(op, 16) = 4)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpz_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpz_sizeinbase(/*const*/ mpz_t op, int @base)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrz_sizeinbase_x86(op.ToIntPtr(), @base));
            else
                return new size_t(SafeNativeMethods.__mpfrz_sizeinbase_x64(op.ToIntPtr(), @base));
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the truncated integer part of the square root of <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result square root integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <seealso cref="mpz_perfect_power_p"/>
        /// <seealso cref="mpz_perfect_square_p"/>
        /// <seealso cref="mpz_root"/>
        /// <seealso cref="mpz_rootrem"/>
        /// <seealso cref="mpz_sqrtrem"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Roots.html#Integer-Roots">GNU MPFR - Integer Roots</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 10000.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, 10000);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = trunc(sqrt(op)).
        /// mpfr_lib.mpz_sqrt(rop, op);
        /// 
        /// // Assert that rop is 100.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 100);
        /// 
        /// // Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpz_clears(rop, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 10000.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, 10000)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = trunc(sqrt(op)).
        /// mpfr_lib.mpz_sqrt(rop, op)
        /// 
        /// ' Assert that rop is 100.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 100)
        /// 
        /// ' Release unmanaged memory allocated for rop and op.
        /// mpfr_lib.mpz_clears(rop, op, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_sqrt(mpz_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_sqrt(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop1"/> to the truncated integer part of the square root of <paramref name="op"/>, like <see cref="mpz_sqrt"/>. Set <paramref name="rop2"/> to the remainder <paramref name="op"/> - <paramref name="rop1"/> * <paramref name="rop1"/>, which will be zero if <paramref name="op"/> is a perfect square.
        /// </summary>
        /// <param name="rop1">The result square root integer.</param>
        /// <param name="rop2">The result remainder integer.</param>
        /// <param name="op">The operand integer.</param>
        /// <seealso cref="mpz_perfect_power_p"/>
        /// <seealso cref="mpz_perfect_square_p"/>
        /// <seealso cref="mpz_root"/>
        /// <seealso cref="mpz_rootrem"/>
        /// <seealso cref="mpz_sqrt"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Roots.html#Integer-Roots">GNU MPFR - Integer Roots</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 10000.
        /// mpz_t op = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(op, 10000);
        /// 
        /// // Create, initialize, and set the values of root and rem to 0.
        /// mpz_t root = new mpz_t();
        /// mpz_t rem = new mpz_t();
        /// mpfr_lib.mpz_inits(root, rem);
        /// 
        /// // Set root = trunc(sqrt(op)), and rem = op - root.
        /// mpfr_lib.mpz_sqrtrem(root, rem, op);
        /// 
        /// // Assert that root is 100, and rem is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(root) == 100);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rem) == 0);
        /// 
        /// // Release unmanaged memory allocated for root, rem, and op.
        /// mpfr_lib.mpz_clears(root, rem, op, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 10000.
        /// Dim op As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(op, 10000)
        /// 
        /// ' Create, initialize, and set the values of root and rem to 0.
        /// Dim root As New mpz_t()
        /// Dim[rem] As New mpz_t()
        /// mpfr_lib.mpz_inits(root, [rem])
        /// 
        /// ' Set root = trunc(sqrt(op)), and rem = op - root.
        /// mpfr_lib.mpz_sqrtrem(root, [rem], op)
        /// 
        /// ' Assert that root is 100, and rem is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(root) = 100)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si([rem]) = 0)
        /// 
        /// ' Release unmanaged memory allocated for root, rem, and op.
        /// mpfr_lib.mpz_clears(root, [rem], op, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_sqrtrem(mpz_t rop1, mpz_t rop2, /*const*/ mpz_t op)
        {
            if (rop1 == null) throw new ArgumentNullException("rop1");
            if (rop2 == null) throw new ArgumentNullException("rop2");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrz_sqrtrem(rop1.ToIntPtr(), rop2.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub_ui"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpz_ui_sub"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 12222.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 12222U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x - y.
        /// mpfr_lib.mpz_sub(z, x, y);
        /// 
        /// // Assert that z = x - y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == -2222);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 12222.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x - y.
        /// mpfr_lib.mpz_sub(z, x, y)
        /// 
        /// ' Assert that z = x - y.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = -2222)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_sub(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_sub(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpz_ui_sub"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = x - 12222.
        /// mpfr_lib.mpz_sub_ui(z, x, 12222U);
        /// 
        /// // Assert that z = x - 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == -2222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = x - 12222.
        /// mpfr_lib.mpz_sub_ui(z, x, 12222UI)
        /// 
        /// ' Assert that z = x - 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = -2222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_sub_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_sub_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_sub_ui"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of z to 0.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init(z);
        /// 
        /// // Set z = 12222 - x.
        /// mpfr_lib.mpz_ui_sub(z, 12222U, x);
        /// 
        /// // Assert that z = 12222 - x.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 2222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of z to 0.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init(z)
        /// 
        /// ' Set z = 12222 - x.
        /// mpfr_lib.mpz_ui_sub(z, 12222UI, x)
        /// 
        /// ' Assert that z = 12222 - x.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 2222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_ui_sub(mpz_t rop, uint /*unsigned long int*/ op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_ui_sub(rop.ToIntPtr(), op1, op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="rop"/> - <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 10000U);
        /// 
        /// // Create, initialize, and set the value of y to 12222.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(y, 12222U);
        /// 
        /// // Create, initialize, and set the value of z to 20000.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(z, 20000);
        /// 
        /// // Set z -= x * y.
        /// mpfr_lib.mpz_submul(z, x, y);
        /// 
        /// // Assert that z has been decremented by 10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 20000 - 10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 10000UI)
        /// 
        /// ' Create, initialize, and set the value of y to 12222.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(y, 12222UI)
        /// 
        /// ' Create, initialize, and set the value of z to 20000.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(z, 20000)
        /// 
        /// ' Set z -= x * y.
        /// mpfr_lib.mpz_submul(z, x, y)
        /// 
        /// ' Assert that z has been decremented by 10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 20000 - 10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpz_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_submul(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_submul(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="rop"/> - <paramref name="op1"/> * <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <seealso cref="mpz_abs"/>
        /// <seealso cref="mpz_add"/>
        /// <seealso cref="mpz_addmul"/>
        /// <seealso cref="mpz_mul"/>
        /// <seealso cref="mpz_neg"/>
        /// <seealso cref="mpz_sub"/>
        /// <seealso cref="mpz_submul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Arithmetic.html#Integer-Arithmetic">GNU MPFR - Integer Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -10000.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, -10000);
        /// 
        /// // Create, initialize, and set the value of z to 20000.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(z, 20000);
        /// 
        /// // Set z -= x * 12222U.
        /// mpfr_lib.mpz_submul_ui(z, x, 12222U);
        /// 
        /// // Assert that z has been decremented by -10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) == 20000 - -10000 * 12222);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -10000.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, -10000)
        /// 
        /// ' Create, initialize, and set the value of z to 20000.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(z, 20000)
        /// 
        /// ' Set z -= x * 12222U.
        /// mpfr_lib.mpz_submul_ui(z, x, 12222UI)
        /// 
        /// ' Assert that z has been decremented by -10000 * 12222.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(z) = 20000 - -10000 * 12222)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpz_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_submul_ui(mpz_t rop, /*const*/ mpz_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrz_submul_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Swap the values <paramref name="rop1"/> and <paramref name="rop2"/> efficiently.
        /// </summary>
        /// <param name="rop1">The first integer.</param>
        /// <param name="rop2">The second integer.</param>
        /// <seealso cref="mpz_set"/>
        /// <seealso cref="mpz_set_ui"/>
        /// <seealso cref="mpz_set_si"/>
        /// <seealso cref="mpz_set_d"/>
        /// <seealso cref="mpz_set_q"/>
        /// <seealso cref="mpz_set_f"/>
        /// <seealso cref="mpz_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer x to 10.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new integer x to -210.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(y, -210);
        /// 
        /// // Swap the values of x and y.
        /// mpfr_lib.mpz_swap(x, y);
        /// 
        /// // Assert that the values have been swapped.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) == -210);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(y) == 10);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer x to 10.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new integer x to -210.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(y, -210)
        /// 
        /// ' Swap the values of x and y.
        /// mpfr_lib.mpz_swap(x, y)
        /// 
        /// ' Assert that the values have been swapped.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(x) = -210)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(y) = 10)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpz_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_swap(mpz_t rop1, mpz_t rop2)
        {
            if (rop1 == null) throw new ArgumentNullException("rop1");
            if (rop2 == null) throw new ArgumentNullException("rop2");
            SafeNativeMethods.__mpfrz_swap(rop1.ToIntPtr(), rop2.ToIntPtr());
        }

        /// <summary>
        /// Return the remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = trunc(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>The remainder | r | where r = <paramref name="n"/> - q * <paramref name="d"/>, and where q = trunc(<paramref name="n"/> / <paramref name="d"/>).</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Assert that returned value is |n - 3 * trunc(n / 3)|.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_ui(n, 3U) == 1U);
        /// 
        /// // Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Assert that returned value is |n - 3 * trunc(n / 3)|.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_ui(n, 3UI) = 1UI)
        /// 
        /// ' Release unmanaged memory allocated for n.
        /// mpfr_lib.mpz_clear(n)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_tdiv_ui(/*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_tdiv_ui(n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = trunc(n / d).
        /// mpfr_lib.mpz_tdiv_q(q, n, d);
        /// 
        /// // Assert that q is trunc(10000 / 3).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// 
        /// // Release unmanaged memory allocated for n, d, and q.
        /// mpfr_lib.mpz_clears(n, d, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = trunc(n / d).
        /// mpfr_lib.mpz_tdiv_q(q, n, d)
        /// 
        /// ' Assert that q is trunc(10000 / 3).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and q.
        /// mpfr_lib.mpz_clears(n, d, q, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_tdiv_q(mpz_t q, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_tdiv_q(q.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / 2^<paramref name="b"/>).
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10001);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = trunc(n / 2^2).
        /// mpfr_lib.mpz_tdiv_q_2exp(q, n, 2U);
        /// 
        /// // Assert that q is trunc(10001 / 4).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 2500);
        /// 
        /// // Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10001)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = trunc(n / 2^2).
        /// mpfr_lib.mpz_tdiv_q_2exp(q, n, 2UI)
        /// 
        /// ' Assert that q is trunc(10001 / 4).
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 2500)
        /// 
        /// ' Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_tdiv_q_2exp(mpz_t q, /*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_tdiv_q_2exp(q.ToIntPtr(), n.ToIntPtr(), b);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>), and return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return the remainder r = | <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/> |.</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of q to 0.
        /// mpz_t q = new mpz_t();
        /// mpfr_lib.mpz_init(q);
        /// 
        /// // Set q = trunc(n / 3) and return r = n - 3 * q.
        /// // Assert q and r values.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_q_ui(q, n, 3U) == 1U);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// 
        /// // Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of q to 0.
        /// Dim q As New mpz_t()
        /// mpfr_lib.mpz_init(q)
        /// 
        /// ' Set q = trunc(n / 3) and return r = n - 3 * q.
        /// ' Assert q and r values.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_q_ui(q, n, 3UI) = 1UI)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// 
        /// ' Release unmanaged memory allocated for n and q.
        /// mpfr_lib.mpz_clears(n, q, Nothing)
        /// </code> 
        /// </example>
        public static ulong mpz_tdiv_q_ui(mpz_t q, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_tdiv_q_ui(q.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>), and set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the values of q and r to 0.
        /// mpz_t q = new mpz_t();
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_inits(q, r, null);
        /// 
        /// // Set q = trunc(n / 3) and r = n - d * q.
        /// mpfr_lib.mpz_tdiv_qr(q, r, n, d);
        /// 
        /// // Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n, d, q, and r.
        /// mpfr_lib.mpz_clears(n, d, q, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the values of q and r to 0.
        /// Dim q As New mpz_t()
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_inits(q, r, Nothing)
        /// 
        /// ' Set q = trunc(n / 3) and r = n - d * q.
        /// mpfr_lib.mpz_tdiv_qr(q, r, n, d)
        /// 
        /// ' Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n, d, q, and r.
        /// mpfr_lib.mpz_clears(n, d, q, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_tdiv_qr(mpz_t q, mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_tdiv_qr(q.ToIntPtr(), r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set quotient <paramref name="q"/> to trunc(<paramref name="n"/> / <paramref name="d"/>), set the remainder <paramref name="r"/> to <paramref name="n"/> - <paramref name="q"/> * <paramref name="d"/>, and return | <paramref name="r"/> |.
        /// </summary>
        /// <param name="q">The result quotient integer.</param>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return | <paramref name="r"/> |.</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the values of q and r to 0.
        /// mpz_t q = new mpz_t();
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_inits(q, r, null);
        /// 
        /// // Set q = trunc(n / 3), r = n - d * q, and return r.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_qr_ui(q, r, n, 3U) == 1U);
        /// 
        /// // Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) == 3333);
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n, q, and r.
        /// mpfr_lib.mpz_clears(n, q, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the values of q and r to 0.
        /// Dim q As New mpz_t()
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_inits(q, r, Nothing)
        /// 
        /// ' Set q = trunc(n / 3), r = n - d * q, and return r.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_qr_ui(q, r, n, 3UI) = 1UI)
        /// 
        /// ' Assert that q is 3333, and that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(q) = 3333)
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n, q, and r.
        /// mpfr_lib.mpz_clears(n, q, r, Nothing)
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpz_tdiv_qr_ui(mpz_t q, mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (q == null) throw new ArgumentNullException("q");
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_tdiv_qr_ui(q.ToIntPtr(), r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = trunc(<paramref name="n"/> / <paramref name="d"/>).
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of d to 3.
        /// mpz_t d = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(d, 3);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - d * trunc(n / d).
        /// mpfr_lib.mpz_tdiv_r(r, n, d);
        /// 
        /// // Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n, d, and r.
        /// mpfr_lib.mpz_clears(n, d, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of d to 3.
        /// Dim d As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(d, 3)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - d * trunc(n / d).
        /// mpfr_lib.mpz_tdiv_r(r, n, d)
        /// 
        /// ' Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n, d, and r.
        /// mpfr_lib.mpz_clears(n, d, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_tdiv_r(mpz_t r, /*const*/ mpz_t n, /*const*/ mpz_t d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            if (d == null) throw new ArgumentNullException("d");
            SafeNativeMethods.__mpfrz_tdiv_r(r.ToIntPtr(), n.ToIntPtr(), d.ToIntPtr());
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * 2^<paramref name="b"/> where q = trunc(<paramref name="n"/> / 2^<paramref name="b"/>).
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="b">The exponent of the power of two denominator.</param>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_r_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10001.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10001);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - 2^2 * trunc(n / 2^2)
        /// mpfr_lib.mpz_tdiv_r_2exp(r, n, 2U);
        /// 
        /// // Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10001.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10001)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - 2^2 * trunc(n / 2^2)
        /// mpfr_lib.mpz_tdiv_r_2exp(r, n, 2UI)
        /// 
        /// ' Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_tdiv_r_2exp(mpz_t r, /*const*/ mpz_t n, mp_bitcnt_t b)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_tdiv_r_2exp(r.ToIntPtr(), n.ToIntPtr(), b);
        }

        /// <summary>
        /// Set the remainder <paramref name="r"/> to <paramref name="n"/> - q * <paramref name="d"/> where q = trunc(<paramref name="n"/> / <paramref name="d"/>), and return | <paramref name="r"/> |.
        /// </summary>
        /// <param name="r">The result remainder integer.</param>
        /// <param name="n">The numerator integer.</param>
        /// <param name="d">The denominator integer.</param>
        /// <returns>Return | <paramref name="r"/> |.</returns>
        /// <seealso cref="mpz_cdiv_qr"/>
        /// <seealso cref="mpz_congruent_p"/>
        /// <seealso cref="mpz_divexact"/>
        /// <seealso cref="mpz_divisible_p"/>
        /// <seealso cref="mpz_fdiv_qr"/>
        /// <seealso cref="mpz_mod"/>
        /// <seealso cref="mpz_tdiv_q"/>
        /// <seealso cref="mpz_tdiv_r"/>
        /// <seealso cref="mpz_tdiv_qr"/>
        /// <seealso cref="mpz_tdiv_q_ui"/>
        /// <seealso cref="mpz_tdiv_qr_ui"/>
        /// <seealso cref="mpz_tdiv_ui"/>
        /// <seealso cref="mpz_tdiv_q_2exp"/>
        /// <seealso cref="mpz_tdiv_r_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Division.html#Integer-Division">GNU MPFR - Integer Division</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of n to 10000.
        /// mpz_t n = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(n, 10000);
        /// 
        /// // Create, initialize, and set the value of r to 0.
        /// mpz_t r = new mpz_t();
        /// mpfr_lib.mpz_init(r);
        /// 
        /// // Set r = n - 3 * trunc(n / 3), and return |r|.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_r_ui(r, n, 3U) == 1U);
        /// 
        /// // Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) == 1);
        /// 
        /// // Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of n to 10000.
        /// Dim n As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(n, 10000)
        /// 
        /// ' Create, initialize, and set the value of r to 0.
        /// Dim r As New mpz_t()
        /// mpfr_lib.mpz_init(r)
        /// 
        /// ' Set r = n - 3 * trunc(n / 3), and return |r|.
        /// Assert.IsTrue(mpfr_lib.mpz_tdiv_r_ui(r, n, 3UI) = 1UI)
        /// 
        /// ' Assert that r is 1.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(r) = 1)
        /// 
        /// ' Release unmanaged memory allocated for n and r.
        /// mpfr_lib.mpz_clears(n, r, Nothing)
        /// </code> 
        /// </example>
        public static ulong mpz_tdiv_r_ui(mpz_t r, /*const*/ mpz_t n, uint /*unsigned long int*/ d)
        {
            if (r == null) throw new ArgumentNullException("r");
            if (n == null) throw new ArgumentNullException("n");
            return SafeNativeMethods.__mpfrz_tdiv_r_ui(r.ToIntPtr(), n.ToIntPtr(), d);
        }

        /// <summary>
        /// Test bit <paramref name="bit_index"/> in <paramref name="op"/> and return 0 or 1 accordingly. 
        /// </summary>
        /// <param name="op"></param>
        /// <param name="bit_index"></param>
        /// <returns>Test bit <paramref name="bit_index"/> in <paramref name="op"/> and return 0 or 1 accordingly.</returns>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_xor"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 70.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(rop, 70);
        /// 
        /// // Assert that bit 3 of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_tstbit(rop, 3U) == 0);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 70.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(rop, 70)
        /// 
        /// ' Assert that bit 3 of rop is 0.
        /// Assert.IsTrue(mpfr_lib.mpz_tstbit(rop, 3UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static int mpz_tstbit(/*const*/ mpz_t op, mp_bitcnt_t bit_index)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrz_tstbit(op.ToIntPtr(), bit_index);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="base"/>^<paramref name="exp"/>. The case 0^0 yields 1.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="base">The base integer.</param>
        /// <param name="exp">The exponent integer.</param>
        /// <seealso cref="mpz_powm"/>
        /// <seealso cref="mpz_powm_ui"/>
        /// <seealso cref="mpz_powm_sec"/>
        /// <seealso cref="mpz_pow_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Exponentiation.html#Integer-Exponentiation">GNU MPFR - Integer Exponentiation</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop = 2^4.
        /// mpfr_lib.mpz_ui_pow_ui(rop, 2U, 4U);
        /// 
        /// // Assert that rop is 16.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 16);
        /// 
        /// // Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop = 2^4.
        /// mpfr_lib.mpz_ui_pow_ui(rop, 2UI, 4UI)
        /// 
        /// ' Assert that rop is 16.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 16)
        /// 
        /// ' Release unmanaged memory allocated for rop.
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_ui_pow_ui(mpz_t rop, uint /*unsigned long int*/ @base, uint /*unsigned long int*/ exp)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrz_ui_pow_ui(rop.ToIntPtr(), @base, exp);
        }

        /// <summary>
        /// Generate a uniformly distributed random integer in the range 0 to 2^<paramref name="n"/> - 1, inclusive.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="state">The random number generator state.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The variable <paramref name="state"/> must be initialized by calling one of the <c>mpfr_randinit</c>
        /// functions (<a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a>) before invoking this function.
        /// </para>
        /// <para>
        /// The random number functions of MPFR come in two groups; older function that rely on a global state, 
        /// and newer functions that accept a state parameter that is read and modified.
        /// Please see the <a href="https://mpfrlib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MPFR - Random Number Functions</a>
        /// for more information on how to use and not to use random number functions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_urandomm"/>
        /// <seealso cref="mpz_rrandomb"/>
        /// <seealso cref="mpz_random"/>
        /// <seealso cref="mpz_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MPFR - Integer Random Numbers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// mpfr_lib.mpfr_randseed_ui(state, 100000U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Generate a random integer in the range [0, (2^50)-1].
        /// mpfr_lib.mpz_urandomb(rop, state, 50);
        /// 
        /// // Free all memory occupied by state and rop.
        /// mpfr_lib.mpfr_randclear(state);
        /// mpfr_lib.mpz_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As New mpfr_randstate_t()
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// mpfr_lib.mpfr_randseed_ui(state, 100000UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Generate a random integer in the range [0, (2^50)-1].
        /// mpfr_lib.mpz_urandomb(rop, state, 50)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// mpfr_lib.mpfr_randclear(state)
        /// mpfr_lib.mpz_clear(rop)
        /// </code> 
        /// </example>
        public static void mpz_urandomb(mpz_t rop, mpfr_randstate_t state, mp_bitcnt_t n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfrz_urandomb(rop.ToIntPtr(), state.ToIntPtr(), n);
        }

        /// <summary>
        /// Generate a uniform random integer in the range 0 to <paramref name="n"/> - 1, inclusive.
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="state">The random number generator state.</param>
        /// <param name="n">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The variable <paramref name="state"/> must be initialized by calling one of the <c>mpfr_randinit</c>
        /// functions (<a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a>) before invoking this function. 
        /// </para>
        /// <para>
        /// The random number functions of MPFR come in two groups; older function that rely on a global state, 
        /// and newer functions that accept a state parameter that is read and modified.
        /// Please see the <a href="https://mpfrlib.org/manual/Random-Number-Functions.html#Random-Number-Functions">GNU MPFR - Random Number Functions</a>
        /// for more information on how to use and not to use random number functions.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_urandomb"/>
        /// <seealso cref="mpz_rrandomb"/>
        /// <seealso cref="mpz_random"/>
        /// <seealso cref="mpz_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Random-Numbers.html#Integer-Random-Numbers">GNU MPFR - Integer Random Numbers</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// mpfr_lib.mpfr_randseed_ui(state, 100000U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Create, initialize, and set a large integer.
        /// mpz_t n = new mpz_t();
        /// char_ptr value = new char_ptr("123 456 789 012 345 678 901");
        /// mpfr_lib.mpz_init_set_str(n, value, 10);
        /// 
        /// // Generate a random integer in the range [0, n-1].
        /// mpfr_lib.mpz_urandomm(rop, state, n);
        /// 
        /// // Free all memory occupied by state, rop, and n.
        /// mpfr_lib.mpfr_randclear(state);
        /// mpfr_lib.mpz_clears(rop, n, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As New mpfr_randstate_t()
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// mpfr_lib.mpfr_randseed_ui(state, 100000UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Create, initialize, and set a large integer.
        /// Dim n As New mpz_t()
        /// Dim value As New char_ptr("123 456 789 012 345 678 901")
        /// mpfr_lib.mpz_init_set_str(n, value, 10)
        /// 
        /// ' Generate a random integer in the range [0, n-1].
        /// mpfr_lib.mpz_urandomm(rop, state, n)
        /// 
        /// ' Free all memory occupied by state, rop, and n.
        /// mpfr_lib.mpfr_randclear(state)
        /// mpfr_lib.mpz_clears(rop, n, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_urandomm(mpz_t rop, mpfr_randstate_t state, /*const*/ mpz_t n)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            if (n == null) throw new ArgumentNullException("n");
            SafeNativeMethods.__mpfrz_urandomm(rop.ToIntPtr(), state.ToIntPtr(), n.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> bitwise exclusive-or <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result integer.</param>
        /// <param name="op1">The first operand integer.</param>
        /// <param name="op2">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// The function behaves as if twos complement arithmetic were used (although sign-magnitude is the actual implementation).
        /// The least significant bit is number 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpz_and"/>
        /// <seealso cref="mpz_ior"/>
        /// <seealso cref="mpz_com"/>
        /// <seealso cref="mpz_popcount"/>
        /// <seealso cref="mpz_hamdist"/>
        /// <seealso cref="mpz_scan0"/>
        /// <seealso cref="mpz_scan1"/>
        /// <seealso cref="mpz_setbit"/>
        /// <seealso cref="mpz_clrbit"/>
        /// <seealso cref="mpz_combit"/>
        /// <seealso cref="mpz_tstbit"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Logic-and-Bit-Fiddling.html#Integer-Logic-and-Bit-Fiddling">GNU MPFR - Integer Logic and Bit Fiddling</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 63.
        /// mpz_t op1 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op1, 63U);
        /// 
        /// // Create, initialize, and set the value of op2 to 70.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(op2, 70U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpz_t rop = new mpz_t();
        /// mpfr_lib.mpz_init(rop);
        /// 
        /// // Set rop to the bitwise exclusive or of op1 and op2.
        /// mpfr_lib.mpz_xor(rop, op1, op2);
        /// 
        /// // Assert that rop is 121.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) == 121);
        /// 
        /// // Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 63.
        /// Dim op1 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op1, 63UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 70.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(op2, 70UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpz_t()
        /// mpfr_lib.mpz_init(rop)
        /// 
        /// ' Set rop to the bitwise exclusive or of op1 and op2.
        /// mpfr_lib.mpz_xor(rop, op1, op2)
        /// 
        /// ' Assert that rop is 121.
        /// Assert.IsTrue(mpfr_lib.mpz_get_si(rop) = 121)
        /// 
        /// ' Release unmanaged memory allocated for rop, op1, and op2.
        /// mpfr_lib.mpz_clears(rop, op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static void mpz_xor(mpz_t rop, /*const*/ mpz_t op1, /*const*/ mpz_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrz_xor(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return a pointer to the limb array representing the absolute value of <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The integer.</param>
        /// <returns>A pointer to the limb array representing the absolute value of <paramref name="x"/>.</returns>
        /// <remarks>
        /// <para>
        /// The size of the array is <see cref="mpz_size"/>(x). Intended for read access only.
        /// </para>
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Set the value of x.
        /// char_ptr value = new char_ptr("10000 00000000000000000000000000000000");
        /// mpfr_lib.mpz_set_str(x, value, mpfr_lib.mp_bytes_per_limb == 4 ? 2 : 4);
        /// 
        /// // Get pointer to the limbs of x.
        /// mp_ptr limbs = mpfr_lib.mpz_limbs_read(x);
        /// 
        /// // Assert the values of the limbs based on current architecture (x86 or x64).
        /// Assert.IsTrue(limbs[0] == 0);
        /// Assert.IsTrue(limbs[1] == (mpfr_lib.mp_bytes_per_limb == 4 ? 16U : 256U));
        /// 
        /// // Release unmanaged memory allocated for x and value.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Set the value of x.
        /// Dim value As New char_ptr("10000 00000000000000000000000000000000")
        /// mpfr_lib.mpz_set_str(x, value, If(mpfr_lib.mp_bytes_per_limb = 4, 2, 4))
        /// 
        /// ' Get pointer to the limbs of x.
        /// Dim limbs As mp_ptr = mpfr_lib.mpz_limbs_read(x)
        /// 
        /// ' Assert the values of the limbs based on current architecture (x86 or x64).
        /// Assert.IsTrue(limbs(0) = 0)
        /// Assert.IsTrue(limbs(1) = (If(mpfr_lib.mp_bytes_per_limb = 4, 16UI, 256UI)))
        /// 
        /// ' Release unmanaged memory allocated for x and value.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static mp_ptr /*mp_limb_t**/ mpz_limbs_read(/*const*/ mpz_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_limbs_read(x.ToIntPtr());
            return x._mp_d; // new mp_ptr(SafeNativeMethods.__mpfrz_limbs_read(x));
        }

        /// <summary>
        /// Return a pointer to the limb array of <paramref name="x"/>, intended for write access.
        /// </summary>
        /// <param name="x">The operand integer.</param>
        /// <param name="n">The number of limbs.</param>
        /// <returns>A pointer to the limb array of <paramref name="x"/>, intended for write access.</returns>
        /// <remarks>
        /// <para>
        /// The array is reallocated as needed, to make room for <paramref name="n"/> limbs.
        /// Requires <paramref name="n"/> &gt; 0.
        /// The <see cref="mpz_limbs_write"/> function may destroy the old value and
        /// return an array with unspecified contents.
        /// </para>
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Resize x to 3 limbs, and get pointer to the limbs.
        /// mpfr_lib.mpz_set_ui(x, 2U);
        /// mp_ptr limbs = mpfr_lib.mpz_limbs_write(x, 3);
        /// 
        /// // Set the values of the limbs.
        /// limbs[0] = 0U;
        /// limbs[1] = 0U;
        /// limbs[2] = (mpfr_lib.mp_bytes_per_limb == 4 ? 2U : 4U);
        /// mpfr_lib.mpz_limbs_finish(x, -3);
        /// 
        /// // Assert the value of x based on current architecture (x86 or x64).
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, mpfr_lib.mp_bytes_per_limb == 4 ? 2 : 4, x);
        /// Assert.IsTrue(s.ToString() == "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""));
        /// 
        /// // Release unmanaged memory allocated for x and s.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Resize x to 3 limbs, and get pointer to the limbs.
        /// mpfr_lib.mpz_set_ui(x, 2UI)
        /// Dim limbs As mp_ptr = mpfr_lib.mpz_limbs_write(x, 3)
        /// 
        /// ' Set the values of the limbs.
        /// limbs(0) = 0UI
        /// limbs(1) = 0UI
        /// limbs(2) = (If(mpfr_lib.mp_bytes_per_limb = 4, 2UI, 4UI))
        /// mpfr_lib.mpz_limbs_finish(x, -3)
        /// 
        /// ' Assert the value of x based on current architecture (x86 or x64).
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, If(mpfr_lib.mp_bytes_per_limb = 4, 2, 4), x)
        /// Assert.IsTrue(s.ToString() = "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""))
        /// 
        /// ' Release unmanaged memory allocated for x and s.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static mp_ptr /*mp_limb_t**/ mpz_limbs_write(/*const*/ mpz_t x, mp_size_t n)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_limbs_write(x.ToIntPtr(), n);
            return x._mp_d; // new mp_ptr(SafeNativeMethods.__mpfrz_limbs_write(x, n));
        }

        /// <summary>
        /// Return a pointer to the limb array of <paramref name="x"/>, intended for write access.
        /// </summary>
        /// <param name="x">The operand integer.</param>
        /// <param name="n">The number of limbs.</param>
        /// <returns>A pointer to the limb array of <paramref name="x"/>, intended for write access.</returns>
        /// <remarks>
        /// <para>
        /// The array is reallocated as needed, to make room for <paramref name="n"/> limbs.
        /// Requires <paramref name="n"/> &gt; 0.
        /// The <see cref="mpz_limbs_modify"/> function returns an array that holds the old absolute
        /// value of <paramref name="x"/>
        /// </para>
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 2.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(x, 2U);
        /// 
        /// // Resize x to 3 limbs, and get pointer to the limbs.
        /// mp_ptr limbs = mpfr_lib.mpz_limbs_modify(x, 3);
        /// 
        /// // Set the value of x.
        /// limbs[0] = 0;
        /// limbs[1] = 0;
        /// limbs[2] = (IntPtr.Size == 4 ? 8U : 64U);
        /// mpfr_lib.mpz_limbs_finish(x, -3);
        /// 
        /// // Assert the value of x based on current architecture (x86 or x64).
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, mpfr_lib.mp_bytes_per_limb == 4 ? 2 : 4, x);
        /// Assert.IsTrue(s.ToString() == "-1000 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""));
        /// 
        /// // Release unmanaged memory allocated for x and s.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 2.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(x, 2UI)
        /// 
        /// ' Resize x to 3 limbs, and get pointer to the limbs.
        /// Dim limbs As mp_ptr = mpfr_lib.mpz_limbs_modify(x, 3)
        /// 
        /// ' Set the value of x.
        /// limbs(0) = 0
        /// limbs(1) = 0
        /// limbs(2) = (If(IntPtr.Size = 4, 8UI, 64UI))
        /// mpfr_lib.mpz_limbs_finish(x, -3)
        /// 
        /// ' Assert the value of x based on current architecture (x86 or x64).
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, If(mpfr_lib.mp_bytes_per_limb = 4, 2, 4), x)
        /// Assert.IsTrue(s.ToString() = "-1000 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""))
        /// 
        /// ' Release unmanaged memory allocated for x and s.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static mp_ptr /*mp_limb_t**/ mpz_limbs_modify(/*const*/ mpz_t x, mp_size_t n)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_limbs_modify(x.ToIntPtr(), n);
            return x._mp_d; // new mp_ptr(SafeNativeMethods.__mpfrz_limbs_modify(x, n));
        }

        /// <summary>
        /// Updates the internal size field of <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The operand integer.</param>
        /// <param name="s">The number of limbs and the sign of <paramref name="x"/>.</param>
        /// <remarks>
        /// <para>
        /// Used after writing to the limb array pointer returned by <see cref="mpz_limbs_write"/>
        /// or <see cref="mpz_limbs_modify"/> is completed. The array should contain | <paramref name="s"/> |
        /// valid limbs, representing the new absolute value for <paramref name="x"/>, and the sign of <paramref name="x"/>
        /// is taken from the sign of <paramref name="s"/>.
        /// This function never reallocates <paramref name="x"/>, so the limb pointer remains valid.
        /// </para>
        /// <code language="C++">
        /// void foo (mpz_t x)
        /// {
        ///     mp_size_t n, i;
        ///     mp_limb_t* xp;
        /// 
        ///     n = mpz_size(x);
        ///     xp = mpz_limbs_modify(x, 2 * n);
        ///     for (i = 0; i &lt; n; i++)
        ///         xp[n + i] = xp[n - 1 - i];
        ///     mpz_limbs_finish(x, mpz_sgn(x) &lt; 0 ? - 2 * n : 2 * n);
        /// }
        /// </code> 
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_roinit_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        public static void mpz_limbs_finish(/*const*/ mpz_t x, mp_size_t s)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrz_limbs_finish(x.ToIntPtr(), s);
        }

        /// <summary>
        /// Special initialization of <paramref name="x"/>, using the given limb array and size.
        /// </summary>
        /// <param name="x">The operand integer.</param>
        /// <param name="xp">The limbs array.</param>
        /// <param name="xs">The number of limbs and the sign.</param>
        /// <returns>For convenience, the function returns <paramref name="x"/>, but cast to a const pointer type.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="x"/> should be treated as readonly: it can be passed safely as input to any mpz function, but not as an output.
        /// The array <paramref name="xp"/> must point to at least a readable limb, its size is | <paramref name="xs"/> |, and the
        /// sign of <paramref name="x"/> is the sign of <paramref name="xs"/>.
        /// </para>
        /// <code language="C++">
        /// void foo (mpz_t x)
        /// {
        ///     static const mp_limb_t y[3] = { 0x1, 0x2, 0x3 };
        ///     mpz_t tmp;
        ///     mpz_add(x, x, mpz_roinit_n(tmp, y, 3));
        /// }
        /// </code> 
        /// </remarks>
        /// <seealso cref="_mpz_realloc"/>
        /// <seealso cref="mpz_getlimbn"/>
        /// <seealso cref="mpz_size"/>
        /// <seealso cref="mpz_limbs_read"/>
        /// <seealso cref="mpz_limbs_write"/>
        /// <seealso cref="mpz_limbs_modify"/>
        /// <seealso cref="mpz_limbs_finish"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Integer-Special-Functions.html#Integer-Special-Functions">GNU MPFR - Integer Special Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize new integer x.
        /// mpz_t x = new mpz_t();
        /// mpfr_lib.mpz_init(x);
        /// 
        /// // Prepare new limbs for x.
        /// mp_ptr limbs;
        /// if (mpfr_lib.mp_bytes_per_limb == 4)
        ///     limbs = new mp_ptr(new uint[] { 0U, 0U, 2U });
        /// else
        ///     limbs = new mp_ptr(new ulong[] { 0UL, 0UL, 4UL });
        /// 
        /// // Assign new limbs to x, and make x negative.
        /// x = mpfr_lib.mpz_roinit_n(x, limbs, -3);
        /// 
        /// // Assert new value of x.
        /// char_ptr s = mpfr_lib.mpz_get_str(char_ptr.Zero, mpfr_lib.mp_bytes_per_limb == 4 ? 2 : 4, x);
        /// Assert.IsTrue(s.ToString() == "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""));
        /// 
        /// // Release unmanaged memory allocated for x and s.
        /// mpfr_lib.mpz_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize new integer x.
        /// Dim x As New mpz_t()
        /// mpfr_lib.mpz_init(x)
        /// 
        /// ' Prepare new limbs for x.
        /// Dim limbs As mp_ptr
        /// If mpfr_lib.mp_bytes_per_limb = 4 Then
        ///     limbs = New mp_ptr(New UInteger() { 0UI, 0UI, 2UI})
        /// Else
        ///     limbs = New mp_ptr(New ULong() { 0UL, 0UL, 4UL})
        /// End If
        /// 
        /// ' Assign new limbs to x, and make x negative.
        /// x = mpfr_lib.mpz_roinit_n(x, limbs, -3)
        /// 
        /// ' Assert new value of x.
        /// Dim s As char_ptr = mpfr_lib.mpz_get_str(char_ptr.Zero, If(mpfr_lib.mp_bytes_per_limb = 4, 2, 4), x)
        /// Assert.IsTrue(s.ToString() = "-10 00000000000000000000000000000000 00000000000000000000000000000000".Replace(" ", ""))
        /// 
        /// ' Release unmanaged memory allocated for x and s.
        /// mpfr_lib.mpz_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static /*const*/ mpz_t mpz_roinit_n(mpz_t x, /*const*/ mp_ptr /*mp_limb_t **/ xp, mp_size_t xs)
        {
            if (x == null) throw new ArgumentNullException("x");
            if (xp == null) throw new ArgumentNullException("xp");
            SafeNativeMethods.__mpfrz_roinit_n(x.ToIntPtr(), xp.ToIntPtr(), xs);
            return x;
        }

        #endregion

        #region "Rational (i.e. Q) routines."

        /// <summary>
        /// Set <paramref name="rop"/> to the absolute value of <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op">The operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_abs(mpq_t rop, /*const*/ mpq_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrq_abs(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="sum"/> to <paramref name="addend1"/> + <paramref name="addend2"/>. 
        /// </summary>
        /// <param name="sum">The result rational.</param>
        /// <param name="addend1">The first operand rational.</param>
        /// <param name="addend2">The second operand rational.</param>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_add(mpq_t sum, /*const*/ mpq_t addend1, /*const*/ mpq_t addend2)
        {
            if (sum == null) throw new ArgumentNullException("sum");
            if (addend1 == null) throw new ArgumentNullException("addend1");
            if (addend2 == null) throw new ArgumentNullException("addend2");
            SafeNativeMethods.__mpfrq_add(sum.ToIntPtr(), addend1.ToIntPtr(), addend2.ToIntPtr());
        }

        /// <summary>
        /// Remove any factors that are common to the numerator and denominator of <paramref name="op"/>, and make the denominator positive.
        /// </summary>
        /// <param name="op">The operand rational.</param>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_canonicalize(mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrq_canonicalize(op.ToIntPtr());
        }

        /// <summary>
        /// Free the space occupied by <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The operand rational.</param>
        /// <remarks>
        /// <para>
        /// Make sure to call this function for all <see cref="mpq_t"/> variables when you are done with them. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new rational x.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// 
        /// // Assert that the value of x is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new rational x.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// 
        /// ' Assert that the value of x is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x)
        /// </code> 
        /// </example>
        public static void mpq_clear(mpq_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrq_clear(x.ToIntPtr());
        }

        /// <summary>
        /// Free the space occupied by a NULL-terminated list of <see cref="mpq_t"/> variables. 
        /// </summary>
        /// <param name="x">The operand rational.</param>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new rationals x1, x2 and x3.
        /// mpq_t x1 = new mpq_t();
        /// mpq_t x2 = new mpq_t();
        /// mpq_t x3 = new mpq_t();
        /// 
        /// // Initialize the rationals.
        /// mpfr_lib.mpq_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x1) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x2) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x3) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for the rationals.
        /// mpfr_lib.mpq_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new rationals x1, x2 and x3.
        /// Dim x1 As New mpq_t()
        /// Dim x2 As New mpq_t()
        /// Dim x3 As New mpq_t()
        /// 
        /// ' Initialize the rationals.
        /// mpfr_lib.mpq_inits(x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x1) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x2) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x3) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for the rationals.
        /// mpfr_lib.mpq_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpq_clears(params mpq_t[] x)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpq_t a in x) { if (a != null) mpq_clear(a); }
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// To determine if two rationals are equal, <see cref="mpq_equal"/> is faster than <see cref="mpq_cmp"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_cmp_z"/>
        /// <seealso cref="mpq_cmp_ui"/>
        /// <seealso cref="mpq_cmp_si"/>
        /// <seealso cref="mpq_sgn"/>
        /// <seealso cref="mpq_equal"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MPFR - Comparing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 1 / 2.
        /// mpq_t op1 = new mpq_t();
        /// mpfr_lib.mpq_init(op1);
        /// mpfr_lib.mpq_set_si(op1, 1, 2U);
        /// 
        /// // Create, initialize, and set the value of op2 to 1 / 3.
        /// mpq_t op2 = new mpq_t();
        /// mpfr_lib.mpq_init(op2);
        /// mpfr_lib.mpq_set_si(op2, 1, 3U);
        /// 
        /// // Assert that op1 > op2.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp(op1, op2) > 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpq_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 1 / 2.
        /// Dim op1 As New mpq_t()
        /// mpfr_lib.mpq_init(op1)
        /// mpfr_lib.mpq_set_si(op1, 1, 2UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 1 / 3.
        /// Dim op2 As New mpq_t()
        /// mpfr_lib.mpq_init(op2)
        /// mpfr_lib.mpq_set_si(op2, 1, 3UI)
        /// 
        /// ' Assert that op1 > op2.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp(op1, op2) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpq_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpq_cmp(/*const*/ mpq_t op1, /*const*/ mpq_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrq_cmp(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="num2"/> / <paramref name="den2"/>.
        /// </summary>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="num2">The second operand numerator integer.</param>
        /// <param name="den2">The second operand denominator integer.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="num2"/> / <paramref name="den2"/>, zero if <paramref name="op1"/> = <paramref name="num2"/> / <paramref name="den2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="num2"/> / <paramref name="den2"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="num2"/> and <paramref name="den2"/> are allowed to have common factors. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_cmp"/>
        /// <seealso cref="mpq_cmp_z"/>
        /// <seealso cref="mpq_cmp_ui"/>
        /// <seealso cref="mpq_sgn"/>
        /// <seealso cref="mpq_equal"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MPFR - Comparing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 1 / 2.
        /// mpq_t op1 = new mpq_t();
        /// mpfr_lib.mpq_init(op1);
        /// mpfr_lib.mpq_set_si(op1, 1, 2U);
        /// 
        /// // Assert that op1 &lt; 5/6.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op1, 5, 6U) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpq_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 1 / 2.
        /// Dim op1 As New mpq_t()
        /// mpfr_lib.mpq_init(op1)
        /// mpfr_lib.mpq_set_si(op1, 1, 2UI)
        /// 
        /// ' Assert that op1 &lt; 5/6.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op1, 5, 6UI) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpq_clear(op1)
        /// </code> 
        /// </example>
        public static int mpq_cmp_si(/*const*/ mpq_t op1, int /*long int*/ num2, uint /*unsigned long int*/ den2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrq_cmp_si(op1.ToIntPtr(), num2, den2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="num2"/> / <paramref name="den2"/>.
        /// </summary>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="num2">The second operand numerator integer.</param>
        /// <param name="den2">The second operand denominator integer.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="num2"/> / <paramref name="den2"/>, zero if <paramref name="op1"/> = <paramref name="num2"/> / <paramref name="den2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="num2"/> / <paramref name="den2"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="num2"/> and <paramref name="den2"/> are allowed to have common factors. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_cmp"/>
        /// <seealso cref="mpq_cmp_z"/>
        /// <seealso cref="mpq_cmp_si"/>
        /// <seealso cref="mpq_sgn"/>
        /// <seealso cref="mpq_equal"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MPFR - Comparing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 1 / 2.
        /// mpq_t op1 = new mpq_t();
        /// mpfr_lib.mpq_init(op1);
        /// mpfr_lib.mpq_set_si(op1, 1, 2U);
        /// 
        /// // Assert that op1 == 3/6.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_ui(op1, 3, 6U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpq_clear(op1);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 1 / 2.
        /// Dim op1 As New mpq_t()
        /// mpfr_lib.mpq_init(op1)
        /// mpfr_lib.mpq_set_si(op1, 1, 2UI)
        /// 
        /// ' Assert that op1 == 3/6.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_ui(op1, 3, 6UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op1.
        /// mpfr_lib.mpq_clear(op1)
        /// </code> 
        /// </example>
        public static int mpq_cmp_ui(/*const*/ mpq_t op1, uint /*unsigned long int*/ num2, uint /*unsigned long int*/ den2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrq_cmp_ui(op1.ToIntPtr(), num2, den2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <returns>Return a positive value if <paramref name="op1"/> &gt; <paramref name="op2"/>, zero if <paramref name="op1"/> = <paramref name="op2"/>, and a negative value if <paramref name="op1"/> &lt; <paramref name="op2"/>.</returns>
        /// <remarks>
        /// <para>
        /// To determine if two rationals are equal, <see cref="mpq_equal"/> is faster than <see cref="mpq_cmp"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_cmp"/>
        /// <seealso cref="mpq_cmp_ui"/>
        /// <seealso cref="mpq_cmp_si"/>
        /// <seealso cref="mpq_sgn"/>
        /// <seealso cref="mpq_equal"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MPFR - Comparing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 1 / 2.
        /// mpq_t op1 = new mpq_t();
        /// mpfr_lib.mpq_init(op1);
        /// mpfr_lib.mpq_set_si(op1, 1, 2U);
        /// 
        /// // Create, initialize, and set the value of op2 to 3.
        /// mpz_t op2 = new mpz_t();
        /// mpfr_lib.mpz_init(op2);
        /// mpfr_lib.mpz_set_si(op2, 3);
        /// 
        /// // Assert that op1 &lt; op2.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_z(op1, op2) &lt; 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpq_clear(op1);
        /// mpfr_lib.mpz_clear(op2);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 1 / 2.
        /// Dim op1 As New mpq_t()
        /// mpfr_lib.mpq_init(op1)
        /// mpfr_lib.mpq_set_si(op1, 1, 2UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 3.
        /// Dim op2 As New mpz_t()
        /// mpfr_lib.mpz_init(op2)
        /// mpfr_lib.mpz_set_si(op2, 3)
        /// 
        /// ' Assert that op1 &lt; op2.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_z(op1, op2) &lt; 0)
        /// 
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpq_clear(op1)
        /// mpfr_lib.mpz_clear(op2)
        /// </code> 
        /// </example>
        public static int mpq_cmp_z(/*const*/ mpq_t op1, /*const*/ mpz_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrq_cmp_z(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Return a reference to the denominator <paramref name="op"/>.
        /// </summary>
        /// <param name="op">The operand rational.</param>
        /// <returns>Return a reference to the denominator <paramref name="op"/>.</returns>
        /// <remarks>
        /// <para>
        /// The <c>mpz</c> functions can be used on the returned reference. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_numref"/>
        /// <seealso cref="mpq_get_num"/>
        /// <seealso cref="mpq_get_den "/>
        /// <seealso cref="mpq_set_num"/>
        /// <seealso cref="mpq_set_den"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MPFR - Applying Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -1 / 3.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -1, 3U);
        /// 
        /// // Get reference to denominator, and increment it by 2.
        /// mpz_t num = mpfr_lib.mpq_denref(op);
        /// mpfr_lib.mpz_add_ui(num, num, 2U);
        /// 
        /// // Assert that op is -1 / 5.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 5U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -1 / 3.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -1, 3UI)
        /// 
        /// ' Get reference to denominator, and increment it by 2.
        /// Dim num As mpz_t = mpfr_lib.mpq_denref(op)
        /// mpfr_lib.mpz_add_ui(num, num, 2UI)
        /// 
        /// ' Assert that op is -1 / 5.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 5UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static mpz_t mpq_denref(/*const*/ mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_den;
        }

        /// <summary>
        /// Set <paramref name="quotient"/> to <paramref name="dividend"/> / <paramref name="divisor"/>. 
        /// </summary>
        /// <param name="quotient">The result rational.</param>
        /// <param name="dividend">The first operand rational.</param>
        /// <param name="divisor">The second operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_div(mpq_t quotient, /*const*/ mpq_t dividend, /*const*/ mpq_t divisor)
        {
            if (quotient == null) throw new ArgumentNullException("quotient");
            if (dividend == null) throw new ArgumentNullException("dividend");
            if (divisor == null) throw new ArgumentNullException("divisor");
            SafeNativeMethods.__mpfrq_div(quotient.ToIntPtr(), dividend.ToIntPtr(), divisor.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / 2^<paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_div_2exp(mpq_t rop, /*const*/ mpq_t op1, uint /*mp_bitcnt_t*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrq_div_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are equal, zero if they are non-equal. 
        /// </summary>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <returns>Return non-zero if <paramref name="op1"/> and <paramref name="op2"/> are equal, zero if they are non-equal.</returns>
        /// <remarks>
        /// <para>
        /// Although <see cref="mpq_cmp"/> can be used for the same purpose, this function is much faster. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_cmp"/>
        /// <seealso cref="mpq_cmp_z"/>
        /// <seealso cref="mpq_cmp_ui"/>
        /// <seealso cref="mpq_cmp_si"/>
        /// <seealso cref="mpq_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MPFR - Comparing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op1 to 1 / 2.
        /// mpq_t op1 = new mpq_t();
        /// mpfr_lib.mpq_init(op1);
        /// mpfr_lib.mpq_set_si(op1, 1, 2U);
        /// 
        /// // Create, initialize, and set the value of op2 to 1 / 3.
        /// mpq_t op2 = new mpq_t();
        /// mpfr_lib.mpq_init(op2);
        /// mpfr_lib.mpq_set_si(op2, 1, 3U);
        /// 
        /// // Assert that op1 != op2.
        /// Assert.IsTrue(mpfr_lib.mpq_equal(op1, op2) == 0);
        /// 
        /// // Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpq_clears(op1, op2, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op1 to 1 / 2.
        /// Dim op1 As New mpq_t()
        /// mpfr_lib.mpq_init(op1)
        /// mpfr_lib.mpq_set_si(op1, 1, 2UI)
        /// 
        /// ' Create, initialize, and set the value of op2 to 1 / 3.
        /// Dim op2 As New mpq_t()
        /// mpfr_lib.mpq_init(op2)
        /// mpfr_lib.mpq_set_si(op2, 1, 3UI)
        /// 
        /// ' Assert that op1 != op2.
        /// Assert.IsTrue(mpfr_lib.mpq_equal(op1, op2) = 0)
        ///  
        /// ' Release unmanaged memory allocated for op1 and op2.
        /// mpfr_lib.mpq_clears(op1, op2, Nothing)
        /// </code> 
        /// </example>
        public static int mpq_equal(/*const*/ mpq_t op1, /*const*/ mpq_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrq_equal(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="numerator"/> to the numerator of <paramref name="rational"/>.
        /// </summary>
        /// <param name="numerator">The result integer.</param>
        /// <param name="rational">The operand rational.</param>
        /// <remarks>
        /// <para>
        /// The function is equivalent to calling <see cref="mpz_set"/> with <see cref="mpq_numref"/>.
        /// Direct use of <see cref="mpq_numref"/> is recommended instead of this functions. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_numref"/>
        /// <seealso cref="mpq_denref"/>
        /// <seealso cref="mpq_get_den "/>
        /// <seealso cref="mpq_set_num"/>
        /// <seealso cref="mpq_set_den"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MPFR - Applying Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -1 / 3.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -1, 3U);
        /// 
        /// // Create and initialize a new integer.
        /// mpz_t num = new mpz_t();
        /// mpfr_lib.mpz_init(num);
        /// 
        /// // Set integer to numerator of rational, and increment integer by 2.
        /// mpfr_lib.mpq_get_num(num, op);
        /// mpfr_lib.mpz_add_ui(num, num, 2U);
        /// 
        /// // Assert that num is 1, and op is -1 / 3.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_si(num, 1) == 0);
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 3U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op);
        /// mpfr_lib.mpz_clear(num);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -1 / 3.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -1, 3UI)
        /// 
        /// ' Create and initialize a new integer.
        /// Dim num As New mpz_t()
        /// mpfr_lib.mpz_init(num)
        /// 
        /// ' Set integer to numerator of rational, and increment integer by 2.
        /// mpfr_lib.mpq_get_num(num, op)
        /// mpfr_lib.mpz_add_ui(num, num, 2UI)
        /// 
        /// ' Assert that num is 1, and op is -1 / 3.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_si(num, 1) = 0)
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 3UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op)
        /// mpfr_lib.mpz_clear(num)
        /// </code> 
        /// </example>
        public static void mpq_get_num(mpz_t numerator, /*const*/ mpq_t rational)
        {
            if (numerator == null) throw new ArgumentNullException("numerator");
            if (rational == null) throw new ArgumentNullException("rational");
            SafeNativeMethods.__mpfrq_get_num(numerator.ToIntPtr(), rational.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="denominator"/> to the denominator of <paramref name="rational"/>.
        /// </summary>
        /// <param name="denominator">The result integer.</param>
        /// <param name="rational">The operand rational.</param>
        /// <remarks>
        /// <para>
        /// The function is equivalent to calling <see cref="mpz_set"/> with <see cref="mpq_denref"/>.
        /// Direct use of <see cref="mpq_denref"/> is recommended instead of this functions. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_numref"/>
        /// <seealso cref="mpq_denref"/>
        /// <seealso cref="mpq_get_num"/>
        /// <seealso cref="mpq_get_den "/>
        /// <seealso cref="mpq_set_num"/>
        /// <seealso cref="mpq_set_den"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MPFR - Applying Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -1 / 3.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -1, 3U);
        /// 
        /// // Create and initialize a new integer.
        /// mpz_t den = new mpz_t();
        /// mpfr_lib.mpz_init(den);
        /// 
        /// // Set integer to numerator of rational, and increment integer by 2..
        /// mpfr_lib.mpq_get_den(den, op);
        /// mpfr_lib.mpz_add_ui(den, den, 2U);
        /// 
        /// // Assert that num is 1, and op is -1 / 3.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_si(den, 5) == 0);
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 3U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op);
        /// mpfr_lib.mpz_clear(den);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -1 / 3.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -1, 3UI)
        /// 
        /// ' Create and initialize a new integer.
        /// Dim den As New mpz_t()
        /// mpfr_lib.mpz_init(den)
        /// 
        /// ' Set integer to numerator of rational, and increment integer by 2..
        /// mpfr_lib.mpq_get_den(den, op)
        /// mpfr_lib.mpz_add_ui(den, den, 2UI)
        /// 
        /// ' Assert that num is 1, and op is -1 / 3.
        /// Assert.IsTrue(mpfr_lib.mpz_cmp_si(den, 5) = 0)
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 3UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op)
        /// mpfr_lib.mpz_clear(den)
        /// </code> 
        /// </example>
        public static void mpq_get_den(mpz_t denominator, /*const*/ mpq_t rational)
        {
            if (denominator == null) throw new ArgumentNullException("denominator");
            if (rational == null) throw new ArgumentNullException("rational");
            SafeNativeMethods.__mpfrq_get_den(denominator.ToIntPtr(), rational.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a <see cref="double"/>, truncating if necessary (i.e. rounding towards zero). 
        /// </summary>
        /// <param name="op">The operand rational.</param>
        /// <returns>The converted <see cref="double"/>.</returns>
        /// <remarks>
        /// <para>
        /// If the exponent from the conversion is too big or too small to fit a <see cref="double"/> then the result is system dependent.
        /// For too big an infinity is returned when available.
        /// For too small 0.0 is normally returned.
        /// Hardware overflow, underflow and denorm traps may or may not occur. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_set_d"/>
        /// <seealso cref="mpq_set_f"/>
        /// <seealso cref="mpq_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MPFR - Rational Conversions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to 10 / 11.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// mpfr_lib.mpq_set_si(x, 10, 11U);
        /// 
        /// // Assert that the value of x is 10.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x) == 10.0 / 11.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to 10 / 11.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// mpfr_lib.mpq_set_si(x, 10, 11UI)
        /// 
        /// ' Assert that the value of x is 10.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x) = 10.0 / 11.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x)
        /// </code> 
        /// </example>
        public static double mpq_get_d(/*const*/ mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrq_get_d(op.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
        /// </summary>
        /// <param name="str">The result string.</param>
        /// <param name="base">The base.</param>
        /// <param name="op">The operand rational.</param>
        /// <returns>A pointer to the result string is returned, being either the allocated block, or the given <paramref name="str"/>.</returns>
        /// <remarks>
        /// <para>
        /// The base may vary from 2 to 36. The string will be of the form "num/den", or if the denominator is 1 then just "num". 
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is NULL, the result string is allocated using the current allocation function
        /// (see <a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a>).
        /// The block will be strlen(<paramref name="str"/>) + 1 bytes, that being exactly enough for the string and null-terminator. 
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is not NULL, it should point to a block of storage large enough for the result, that being 
        /// </para>
        /// <code language="C++">
        /// mpz_sizeinbase(mpq_numref(op), base) + mpz_sizeinbase(mpq_denref(op), base) + 3
        /// </code> 
        /// <para>
        /// The three extra bytes are for a possible minus sign, possible slash, and the null-terminator.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_get_d"/>
        /// <seealso cref="mpq_set_d"/>
        /// <seealso cref="mpq_set_f"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MPFR - Rational Conversions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of x to -210 / 13.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// mpfr_lib.mpq_set_si(x, -210, 13U);
        /// 
        /// // Retrieve the string value of x, and assert that it is "-210/13".
        /// char_ptr s = mpfr_lib.mpq_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == "-210/13");
        /// 
        /// // Release unmanaged memory allocated for x and the string value.
        /// mpfr_lib.mpq_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of x to -210 / 13.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// mpfr_lib.mpq_set_si(x, -210, 13UI)
        /// 
        /// ' Retrieve the string value of x, and assert that it is "-210/13".
        /// Dim s As char_ptr = mpfr_lib.mpq_get_str(char_ptr.Zero, 10, x)
        /// Assert.IsTrue(s.ToString() = "-210/13")
        /// 
        /// ' Release unmanaged memory allocated for x and the string value.
        /// mpfr_lib.mpq_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static char_ptr mpq_get_str(char_ptr str, int @base, /*const*/ mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return new Native.char_ptr(SafeNativeMethods.__mpfrq_get_str(str.ToIntPtr(), @base, op.ToIntPtr()));
        }

        /// <summary>
        /// Initialize <paramref name="x"/> and set it to 0/1.
        /// </summary>
        /// <param name="x">The operand rational.</param>
        /// <remarks>
        /// <para>
        ///  Each variable should normally only be initialized once, or at least cleared out
        ///  (using the function <see cref="mpq_clear"/>) between each initialization. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new rational x.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// 
        /// // Assert that the value of x is 0.
        /// char_ptr s = mpfr_lib.mpq_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == "0");
        /// 
        /// // Release unmanaged memory allocated for x and its string value.
        /// mpfr_lib.mpq_clear(x);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new rational x.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// 
        /// ' Assert that the value of x is 0.
        /// Dim s As char_ptr = mpfr_lib.mpq_get_str(char_ptr.Zero, 10, x)
        /// Assert.IsTrue(s.ToString() = "0")
        /// 
        /// ' Release unmanaged memory allocated for x and its string value.
        /// mpfr_lib.mpq_clear(x)
        /// mpfr_lib.free(s)
        /// </code> 
        /// </example>
        public static void mpq_init(mpq_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrq_init(x.ToIntPtr());
        }

        /// <summary>
        /// Initialize a NULL-terminated list of <see cref="mpq_t"/> variables, and set their values to 0/1. 
        /// </summary>
        /// <param name="x">The operand rational.</param>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new rationals x1, x2 and x3.
        /// mpq_t x1 = new mpq_t();
        /// mpq_t x2 = new mpq_t();
        /// mpq_t x3 = new mpq_t();
        /// 
        /// // Initialize the rationals.
        /// mpfr_lib.mpq_inits(x1, x2, x3);
        /// 
        /// // Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x1) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x2) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x3) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for the rationals.
        /// mpfr_lib.mpq_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new rationals x1, x2 and x3.
        /// Dim x1 As New mpq_t()
        /// Dim x2 As New mpq_t()
        /// Dim x3 As New mpq_t()
        /// 
        /// ' Initialize the rationals.
        /// mpfr_lib.mpq_inits(x1, x2, x3)
        /// 
        /// ' Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x1) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x2) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x3) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for the rationals.
        /// mpfr_lib.mpq_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpq_inits(params mpq_t[] x)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpq_t a in x) { if (a != null) mpq_init(a); }
        }

        /// <summary>
        /// Read a string of digits from <paramref name="stream"/> and convert them to a rational in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="stream">Pointer to file stream.</param>
        /// <param name="base">The base.</param>
        /// <returns>Return the number of characters read (including white space), or 0 if a rational could not be read.</returns>
        /// <remarks>
        /// <para>
        /// Any initial white-space characters are read and discarded.
        /// </para>
        /// <para>
        /// The input can be a fraction like "17/63" or just an integer like "123".
        /// Reading stops at the first character not in this form, and white space is not permitted within the string.
        /// If the input might not be in canonical form, then <see cref="mpq_canonicalize"/> must be called
        /// (see <a href="https://mpfrlib.org/manual/Rational-Number-Functions.html#Rational-Number-Functions">GNU MPFR - Rational Number Functions</a>). 
        /// </para>
        /// <para>
        /// The base can be between 2 and 36, or can be 0 in which case the leading characters
        /// of the string determine the base, "0x" or "0X" for hexadecimal, "0" for octal, or decimal otherwise.
        /// The leading characters are examined separately for the numerator and denominator of a fraction, so for instance
        /// "0x10/11" is 16/11, whereas "0x10/0x11" is 16/17. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_out_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Rationals.html#I_002fO-of-Rationals">GNU MPFR - I/O of Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123/456.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// 
        /// // Write rational to a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// System.IO.File.WriteAllText(pathname, "123/456");
        /// 
        /// // Read op from the temporary file, and assert that the number of bytes read is 7.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpq_inp_str(op, stream, 10) == 7);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123/456.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_ui(op, 123, 456U) == 0);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123/456.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// 
        /// ' Write rational to a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// System.IO.File.WriteAllText(pathname, "123/456")
        /// 
        /// ' Read op from the temporary file, and assert that the number of bytes read is 7.
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "r")
        /// Assert.IsTrue(mpfr_lib.mpq_inp_str(op, stream, 10) = 7)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123/456.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_ui(op, 123, 456UI) = 0)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpq_inp_str(mpq_t rop, ptr<FILE> stream, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrq_inp_str_x86(rop.ToIntPtr(), stream.Value.Value, @base));
            else
                return new size_t(SafeNativeMethods.__mpfrq_inp_str_x64(rop.ToIntPtr(), stream.Value.Value, @base));
        }

        /// <summary>
        /// Set <paramref name="inverted_number"/> to 1 / <paramref name="number"/>.
        /// </summary>
        /// <param name="inverted_number">The result rational.</param>
        /// <param name="number">The operand rational.</param>
        /// <remarks>
        /// <para>
        /// If the new denominator is zero, this routine will divide by zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_inv(mpq_t inverted_number, /*const*/ mpq_t number)
        {
            if (inverted_number == null) throw new ArgumentNullException("inverted_number");
            if (number == null) throw new ArgumentNullException("number");
            SafeNativeMethods.__mpfrq_inv(inverted_number.ToIntPtr(), number.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="product"/> to <paramref name="multiplier"/> * <paramref name="multiplicand"/>. 
        /// </summary>
        /// <param name="product">The result rational.</param>
        /// <param name="multiplier">The first operand rational.</param>
        /// <param name="multiplicand">The second operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_mul(mpq_t product, /*const*/ mpq_t multiplier, /*const*/ mpq_t multiplicand)
        {
            if (product == null) throw new ArgumentNullException("product");
            if (multiplier == null) throw new ArgumentNullException("multiplier");
            if (multiplicand == null) throw new ArgumentNullException("multiplicand");
            SafeNativeMethods.__mpfrq_mul(product.ToIntPtr(), multiplier.ToIntPtr(), multiplicand.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * 2*<paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_mul_2exp(mpq_t rop, /*const*/ mpq_t op1, uint /*mp_bitcnt_t*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrq_mul_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="negated_operand"/> to -<paramref name="operand"/>.
        /// </summary>
        /// <param name="negated_operand">The result rational.</param>
        /// <param name="operand">The operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_sub"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_neg(mpq_t negated_operand, /*const*/ mpq_t operand)
        {
            if (negated_operand == null) throw new ArgumentNullException("negated_operand");
            if (operand == null) throw new ArgumentNullException("operand");
            SafeNativeMethods.__mpfrq_neg(negated_operand.ToIntPtr(), operand.ToIntPtr());
        }

        /// <summary>
        /// Return a reference to the numerator <paramref name="op"/>.
        /// </summary>
        /// <param name="op">The operand rational.</param>
        /// <returns>Return a reference to the numerator <paramref name="op"/>.</returns>
        /// <remarks>
        /// <para>
        /// The <c>mpz</c> functions can be used on the returned reference. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_denref"/>
        /// <seealso cref="mpq_get_num"/>
        /// <seealso cref="mpq_get_den "/>
        /// <seealso cref="mpq_set_num"/>
        /// <seealso cref="mpq_set_den"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MPFR - Applying Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -1 / 3.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -1, 3U);
        /// 
        /// // Get reference to numerator, and increment it by 2.
        /// mpz_t num = mpfr_lib.mpq_numref(op);
        /// mpfr_lib.mpz_add_ui(num, num, 2U);
        /// 
        /// // Assert that op is 1 / 3.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, 1, 3U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -1 / 3.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -1, 3UI)
        /// 
        /// ' Get reference to numerator, and increment it by 2.
        /// Dim num As mpz_t = mpfr_lib.mpq_numref(op)
        /// mpfr_lib.mpz_add_ui(num, num, 2UI)
        /// 
        /// ' Assert that op is 1 / 3.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, 1, 3UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static mpz_t mpq_numref(/*const*/ mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_num;
        }

        /// <summary>
        /// Output <paramref name="op"/> on stdio stream <paramref name="stream"/>, as a string of digits in base <paramref name="base"/>.
        /// </summary>
        /// <param name="stream">Pointer to file stream.</param>
        /// <param name="base">The base.</param>
        /// <param name="op">The operand rational.</param>
        /// <returns>Return the number of bytes written, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// The <paramref name="base"/> may vary from 2 to 36.
        /// Output is in the form "num/den" or if the denominator is 1 then just "num". 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_inp_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Rationals.html#I_002fO-of-Rationals">GNU MPFR - I/O of Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123/456.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_ui(op, 123, 456U);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Write op to temporary file, and assert that the number of bytes written is 7.
        /// Assert.IsTrue(mpfr_lib.mpq_out_str(stream, 10, op) == 7);
        /// 
        /// // Close temporary file.
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that the content of the temporary file is "123/456".
        /// string result = System.IO.File.ReadAllText(pathname);
        /// Assert.IsTrue(result == "123/456");
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to 123/456.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_ui(op, 123, 456UI)
        /// 
        /// ' Get a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// 
        /// ' Open temporary file for writing.
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "w")
        /// 
        /// ' Write op to temporary file, and assert that the number of bytes written is 7.
        /// Assert.IsTrue(mpfr_lib.mpq_out_str(stream, 10, op) = 7)
        /// 
        /// ' Close temporary file.
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that the content of the temporary file is "123/456".
        /// Dim result As String = System.IO.File.ReadAllText(pathname)
        /// 
        /// Assert.IsTrue(result = "123/456")
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpq_out_str(ptr<FILE> stream, int @base, /*const*/ mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrq_out_str_x86(stream.Value.Value, @base, op.ToIntPtr()));
            else
                return new size_t(SafeNativeMethods.__mpfrq_out_str_x64(stream.Value.Value, @base, op.ToIntPtr()));
        }

        /// <summary>
        /// Assign <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op">The operand rational.</param>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational x to 10 / 11.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// mpfr_lib.mpq_set_si(x, 10, 11);
        /// 
        /// // Create, initialize, and set a new rational y to -210 / 13.
        /// mpq_t y = new mpq_t();
        /// mpfr_lib.mpq_init(y);
        /// mpfr_lib.mpq_set_si(y, -210, 13);
        /// 
        /// // Assign the value of y to x.
        /// mpfr_lib.mpq_set(x, y);
        /// 
        /// // Assert that the value of x is -210 / 13.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 13) == 0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational x to 10 / 11.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// mpfr_lib.mpq_set_si(x, 10, 11)
        /// 
        /// ' Create, initialize, and set a new rational y to -210 / 13.
        /// Dim y As New mpq_t()
        /// mpfr_lib.mpq_init(y)
        /// mpfr_lib.mpq_set_si(y, -210, 13)
        /// 
        /// ' Assign the value of y to x.
        /// mpfr_lib.mpq_set(x, y)
        /// 
        /// ' Assert that the value of x is -210 / 13.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 13) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpq_set(mpq_t rop, /*const*/ mpq_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrq_set(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of <paramref name="op"/>. There is no rounding, this conversion is exact. 
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op">The operand <see cref="double"/>.</param>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_get_d"/>
        /// <seealso cref="mpq_set_f"/>
        /// <seealso cref="mpq_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MPFR - Rational Conversions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new rational.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// 
        /// // Set the value of x to 10.0 / 11.0.
        /// mpfr_lib.mpq_set_d(x, 10.0D / 11.0);
        /// 
        /// // Assert that the value of x is 10.0 / 11.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x) == 10.0D / 11.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new rational.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// 
        /// ' Set the value of x to 10.0 / 11.0.
        /// mpfr_lib.mpq_set_d(x, 10.0 / 11.0)
        /// 
        /// ' Assert that the value of x is 10.0 / 11.0.
        /// Assert.IsTrue(mpfr_lib.mpq_get_d(x) = 10.0 / 11.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x)
        /// </code> 
        /// </example>
        public static void mpq_set_d(mpq_t rop, double op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrq_set_d(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set the denominator of <paramref name="rational"/> to <paramref name="denominator"/>.
        /// </summary>
        /// <param name="rational">The result rational.</param>
        /// <param name="denominator">The operand integer.</param>
        /// <remarks>
        /// The function is equivalent to calling <see cref="mpz_set"/> with <see cref="mpq_denref"/>.
        /// Direct use of <see cref="mpq_denref"/> is recommended instead of this functions. 
        /// </remarks>
        /// <seealso cref="mpq_numref"/>
        /// <seealso cref="mpq_denref"/>
        /// <seealso cref="mpq_get_num"/>
        /// <seealso cref="mpq_get_den "/>
        /// <seealso cref="mpq_set_num"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MPFR - Applying Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -1 / 3.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -1, 3U);
        /// 
        /// // Create, initialize, and set the value of a new integer to 5.
        /// mpz_t den = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(den, 5U);
        /// 
        /// // Set the denominator of op.
        /// mpfr_lib.mpq_set_den(op, den);
        /// 
        /// // Assert that op is -1 / 5.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 5U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op);
        /// mpfr_lib.mpz_clear(den);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -1 / 3.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -1, 3UI)
        /// 
        /// ' Create, initialize, and set the value of a new integer to 5.
        /// Dim den As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(den, 5UI)
        /// 
        /// ' Set the denominator of op.
        /// mpfr_lib.mpq_set_den(op, den)
        /// 
        /// ' Assert that op is -1 / 5.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, -1, 5UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op)
        /// mpfr_lib.mpz_clear(den)
        /// </code> 
        /// </example>
        public static void mpq_set_den(mpq_t rational, /*const*/ mpz_t denominator)
        {
            if (rational == null) throw new ArgumentNullException("rational");
            if (denominator == null) throw new ArgumentNullException("denominator");
            SafeNativeMethods.__mpfrq_set_den(rational.ToIntPtr(), denominator.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the value of <paramref name="op"/>. There is no rounding, this conversion is exact. 
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op">The operand <see cref="float"/>.</param>
        /// <seealso cref="mpq_get_d"/>
        /// <seealso cref="mpq_set_d"/>
        /// <seealso cref="mpq_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Conversions.html#Rational-Conversions">GNU MPFR - Rational Conversions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational x to 10 / 11.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// mpfr_lib.mpq_set_si(x, 10, 11);
        /// 
        /// // Create, initialize, and set a new float y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init(y);
        /// mpfr_lib.mpf_set_si(y, -210);
        /// 
        /// // Assign the value of y to x.
        /// mpfr_lib.mpq_set_f(x, y);
        /// 
        /// // Assert that the value of x is -210 / 1.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 1) == 0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clear(x);
        /// mpfr_lib.mpf_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational x to 10 / 11.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// mpfr_lib.mpq_set_si(x, 10, 11)
        /// 
        /// ' Create, initialize, and set a new float y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init(y)
        /// mpfr_lib.mpf_set_si(y, -210)
        /// 
        /// ' Assign the value of y to x.
        /// mpfr_lib.mpq_set_f(x, y)
        /// 
        /// ' Assert that the value of x is -210 / 1.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clear(x)
        /// mpfr_lib.mpf_clear(y)
        /// </code> 
        /// </example>
        public static void mpq_set_f(mpq_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrq_set_f(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set the numerator of <paramref name="rational"/> to <paramref name="numerator"/>.
        /// </summary>
        /// <param name="rational">The result rational.</param>
        /// <param name="numerator">The operand integer.</param>
        /// <remarks>
        /// <para>
        /// The function is equivalent to calling <see cref="mpz_set"/> with <see cref="mpq_numref"/>.
        /// Direct use of <see cref="mpq_numref"/> is recommended instead of this functions. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_numref"/>
        /// <seealso cref="mpq_denref"/>
        /// <seealso cref="mpq_get_num"/>
        /// <seealso cref="mpq_get_den "/>
        /// <seealso cref="mpq_set_den"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Applying-Integer-Functions.html#Applying-Integer-Functions">GNU MPFR - Applying Integer Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -1 / 3.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -1, 3U);
        /// 
        /// // Create, initialize, and set the value of a new integer to 5.
        /// mpz_t num = new mpz_t();
        /// mpfr_lib.mpz_init_set_ui(num, 5U);
        /// 
        /// // Set the numerator of op.
        /// mpfr_lib.mpq_set_num(op, num);
        /// 
        /// // Assert that op is 5 / 3.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, 5, 3U) == 0);
        /// 
        /// // Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op);
        /// mpfr_lib.mpz_clear(num);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -1 / 3.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -1, 3UI)
        /// 
        /// ' Create, initialize, and set the value of a new integer to 5.
        /// Dim num As New mpz_t()
        /// mpfr_lib.mpz_init_set_ui(num, 5UI)
        /// 
        /// ' Set the numerator of op.
        /// mpfr_lib.mpq_set_num(op, num)
        /// 
        /// ' Assert that op is 5 / 3.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(op, 5, 3UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op and num.
        /// mpfr_lib.mpq_clear(op)
        /// mpfr_lib.mpz_clear(num)
        /// </code> 
        /// </example>
        public static void mpq_set_num(mpq_t rational, /*const*/ mpz_t numerator)
        {
            if (rational == null) throw new ArgumentNullException("rational");
            if (numerator == null) throw new ArgumentNullException("numerator");
            SafeNativeMethods.__mpfrq_set_num(rational.ToIntPtr(), numerator.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <remarks>
        /// <para>
        /// Note that if <paramref name="op1"/> and <paramref name="op2"/> have common factors,
        /// <paramref name="rop"/> has to be passed to <see cref="mpq_canonicalize"/> before any
        /// operations are performed on <paramref name="rop"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new rational x.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// 
        /// // Set the value of x to -10 / 11.
        /// mpfr_lib.mpq_set_si(x, -10, 11);
        /// 
        /// // Assert that the value of x is -10 / 1.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -10, 11U) == 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new rational x.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// 
        /// ' Set the value of x to -10 / 11.
        /// mpfr_lib.mpq_set_si(x, -10, 11)
        /// 
        /// ' Assert that the value of x is -10 / 1.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -10, 11UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x)
        /// </code> 
        /// </example>
        public static void mpq_set_si(mpq_t rop, int /*long int*/ op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrq_set_si(rop.ToIntPtr(), op1, op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> from a null-terminated string <paramref name="str"/> in the given <paramref name="base"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="str">The source string.</param>
        /// <param name="base">The base,</param>
        /// <returns>The return value is 0 if the entire string is a valid number, or -1 if not.</returns>
        /// <remarks>
        /// <para>
        /// The string can be an integer like "41" or a fraction like "41/152".
        /// The fraction must be in canonical form
        /// (see <a href="https://mpfrlib.org/manual/Rational-Number-Functions.html#Rational-Number-Functions">GNU MPFR - Rational Number Functions</a>),
        /// or if not then <see cref="mpq_canonicalize"/> must be called.
        /// </para>
        /// <para>
        /// The numerator and optional denominator are parsed the same as in <see cref="mpz_set_str"/>
        /// (see <a href="https://mpfrlib.org/manual/Assigning-Integers.html#Assigning-Integers">GNU MPFR - Assigning Integers</a>).
        /// White space is allowed in the string, and is simply ignored.
        /// The base can vary from 2 to 62, or if <paramref name="base"/> is 0 then the leading characters are used:
        /// 0x or 0X for hex, 0b or 0B for binary, 0 for octal, or decimal otherwise.
        /// Note that this is done separately for the numerator and denominator, so for instance 0xEF/100 is 239/100,
        /// whereas 0xEF/0x100 is 239/256.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new rational x.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// 
        /// // Set the value of x.
        /// char_ptr value = new char_ptr("12 345 678 909 876 543 211 234 567 890 987 654 321 / 234 567 890");
        /// mpfr_lib.mpq_set_str(x, value, 10);
        /// 
        /// // Assert the value of x.
        /// char_ptr s = mpfr_lib.mpq_get_str(char_ptr.Zero, 10, x);
        /// Assert.IsTrue(s.ToString() == value.ToString().Replace(" ", ""));
        /// 
        /// // Release unmanaged memory allocated for x and string values.
        /// mpfr_lib.mpq_clear(x);
        /// mpfr_lib.free(value);
        /// mpfr_lib.free(s);
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpq_set_str(mpq_t rop, /*const*/ char_ptr str, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.__mpfrq_set_str(rop.ToIntPtr(), str.ToIntPtr(), @base);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op1">The first operand rational.</param>
        /// <param name="op2">The second operand rational.</param>
        /// <remarks>
        /// <para>
        /// Note that if <paramref name="op1"/> and <paramref name="op2"/> have common factors,
        /// <paramref name="rop"/> has to be passed to <see cref="mpq_canonicalize"/> before any
        /// operations are performed on <paramref name="rop"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new rational x.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// 
        /// // Set the value of x to 10 / 11.
        /// mpfr_lib.mpq_set_ui(x, 10U, 11U);
        /// 
        /// // Assert that the value of x is 10 / 11.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_ui(x, 10U, 11U) == 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new rational x.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// 
        /// ' Set the value of x to 10 / 11.
        /// mpfr_lib.mpq_set_ui(x, 10UI, 11UI)
        /// 
        /// ' Assert that the value of x is 10 / 11.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_ui(x, 10UI, 11UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpq_clear(x)
        /// </code> 
        /// </example>
        public static void mpq_set_ui(mpq_t rop, uint /*unsigned long int*/ op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrq_set_ui(rop.ToIntPtr(), op1, op2);
        }

        /// <summary>
        /// Assign <paramref name="rop"/> from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result rational.</param>
        /// <param name="op">The operand integer.</param>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpq_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational x to 10 / 11.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// mpfr_lib.mpq_set_si(x, 10, 11);
        /// 
        /// // Create, initialize, and set a new integer y to -210.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init(y);
        /// mpfr_lib.mpz_set_si(y, -210);
        /// 
        /// // Assign the value of y to x.
        /// mpfr_lib.mpq_set_z(x, y);
        /// 
        /// // Assert that the value of x is -210 / 1.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 1) == 0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clear(x);
        /// mpfr_lib.mpz_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational x to 10 / 11.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// mpfr_lib.mpq_set_si(x, 10, 11)
        /// 
        /// ' Create, initialize, and set a new integer y to -210.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init(y)
        /// mpfr_lib.mpz_set_si(y, -210)
        /// 
        /// ' Assign the value of y to x.
        /// mpfr_lib.mpq_set_z(x, y)
        /// 
        /// ' Assert that the value of x is -210 / 1.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 1) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clear(x)
        /// mpfr_lib.mpz_clear(y)
        /// </code> 
        /// </example>
        public static void mpq_set_z(mpq_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrq_set_z(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0. 
        /// </summary>
        /// <param name="op">The operand rational.</param>
        /// <returns>Return +1 if <paramref name="op"/> &gt; 0, 0 if <paramref name="op"/> = 0, and -1 if <paramref name="op"/> &lt; 0.</returns>
        /// <seealso cref="mpq_cmp"/>
        /// <seealso cref="mpq_cmp_z"/>
        /// <seealso cref="mpq_cmp_ui"/>
        /// <seealso cref="mpq_cmp_si"/>
        /// <seealso cref="mpq_equal"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Comparing-Rationals.html#Comparing-Rationals">GNU MPFR - Comparing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational x to -10 / 11.
        /// mpq_t op = new mpq_t();
        /// mpfr_lib.mpq_init(op);
        /// mpfr_lib.mpq_set_si(op, -10, 11);
        /// 
        /// // Assert that op is negative.
        /// Assert.IsTrue(mpfr_lib.mpq_sgn(op) == -1);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational x to -10 / 11.
        /// Dim op As New mpq_t()
        /// mpfr_lib.mpq_init(op)
        /// mpfr_lib.mpq_set_si(op, -10, 11)
        /// 
        /// ' Assert that op is negative.
        /// Assert.IsTrue(mpfr_lib.mpq_sgn(op) = -1)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clear(op)
        /// </code> 
        /// </example>
        public static int mpq_sgn(/*const*/ mpq_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_num._mp_size < 0 ? -1 : (op._mp_num._mp_size > 0 ? 1 : 0);
        }

        /// <summary>
        /// Set <paramref name="difference"/> to <paramref name="minuend"/> - <paramref name="subtrahend"/>.
        /// </summary>
        /// <param name="difference">The result rational.</param>
        /// <param name="minuend">The first operand rational.</param>
        /// <param name="subtrahend">The second operand rational.</param>
        /// <seealso cref="mpq_add"/>
        /// <seealso cref="mpq_mul"/>
        /// <seealso cref="mpq_mul_2exp"/>
        /// <seealso cref="mpq_div"/>
        /// <seealso cref="mpq_div_2exp"/>
        /// <seealso cref="mpq_neg"/>
        /// <seealso cref="mpq_abs"/>
        /// <seealso cref="mpq_inv"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Rational-Arithmetic.html#Rational-Arithmetic">GNU MPFR - Rational Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpq_sub(mpq_t difference, /*const*/ mpq_t minuend, /*const*/ mpq_t subtrahend)
        {
            if (difference == null) throw new ArgumentNullException("difference");
            if (minuend == null) throw new ArgumentNullException("minuend");
            if (subtrahend == null) throw new ArgumentNullException("subtrahend");
            SafeNativeMethods.__mpfrq_sub(difference.ToIntPtr(), minuend.ToIntPtr(), subtrahend.ToIntPtr());
        }

        /// <summary>
        /// Swap the values <paramref name="rop1"/> and <paramref name="rop2"/> efficiently. 
        /// </summary>
        /// <param name="rop1">The first rational.</param>
        /// <param name="rop2">The second rational.</param>
        /// <seealso cref="mpq_canonicalize"/>
        /// <seealso cref="mpq_init"/>
        /// <seealso cref="mpq_inits"/>
        /// <seealso cref="mpq_clear"/>
        /// <seealso cref="mpq_clears"/>
        /// <seealso cref="mpq_set"/>
        /// <seealso cref="mpq_set_z"/>
        /// <seealso cref="mpq_set_ui"/>
        /// <seealso cref="mpq_set_si"/>
        /// <seealso cref="mpq_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Rationals.html#Initializing-Rationals">GNU MPFR - Initializing Rationals</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational x to 10 / 11.
        /// mpq_t x = new mpq_t();
        /// mpfr_lib.mpq_init(x);
        /// mpfr_lib.mpq_set_si(x, 10, 11U);
        /// 
        /// // Create, initialize, and set a new rational x to -210 / 13.
        /// mpq_t y = new mpq_t();
        /// mpfr_lib.mpq_init(y);
        /// mpfr_lib.mpq_set_si(y, -210, 13U);
        /// 
        /// // Swap the values of x and y.
        /// mpfr_lib.mpq_swap(x, y);
        /// 
        /// // Assert that the values have been swapped.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 13U) == 0);
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(y, 10, 11U) == 0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational x to 10 / 11.
        /// Dim x As New mpq_t()
        /// mpfr_lib.mpq_init(x)
        /// mpfr_lib.mpq_set_si(x, 10, 11UI)
        /// 
        /// ' Create, initialize, and set a new rational x to -210 / 13.
        /// Dim y As New mpq_t()
        /// mpfr_lib.mpq_init(y)
        /// mpfr_lib.mpq_set_si(y, -210, 13UI)
        /// 
        /// ' Swap the values of x and y.
        /// mpfr_lib.mpq_swap(x, y)
        /// 
        /// ' Assert that the values have been swapped.
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(x, -210, 13UI) = 0)
        /// Assert.IsTrue(mpfr_lib.mpq_cmp_si(y, 10, 11UI) = 0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpq_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpq_swap(mpq_t rop1, mpq_t rop2)
        {
            if (rop1 == null) throw new ArgumentNullException("rop1");
            if (rop2 == null) throw new ArgumentNullException("rop2");
            SafeNativeMethods.__mpfrq_swap(rop1.ToIntPtr(), rop2.ToIntPtr());
        }

        #endregion

        #region "Float (i.e. F) routines."

        /// <summary>
        /// Set <paramref name="rop"/> to | <paramref name="op"/> |. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to -10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, -10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = |x|.
        /// mpfr_lib.mpf_neg(z, x);
        /// 
        /// // Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to -10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, -10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = |x|.
        /// mpfr_lib.mpf_neg(z, x)
        /// 
        /// ' Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_abs(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_abs(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add_ui"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x + y.
        /// mpfr_lib.mpf_add(z, x, y);
        /// 
        /// // Assert that the value of z is -200.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == -200.0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(y, -210)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x + y.
        /// mpfr_lib.mpf_add(z, x, y)
        /// 
        /// ' Assert that the value of z is -200.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = -200.0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_add(mpf_t rop, /*const*/ mpf_t op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_add(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> + <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x + 210.
        /// mpfr_lib.mpf_add_ui(z, x, 210U);
        /// 
        /// // Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x + 210.
        /// mpfr_lib.mpf_add_ui(z, x, 210UI)
        /// 
        /// ' Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_add_ui(mpf_t rop, /*const*/ mpf_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_add_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next higher integer. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand float.</param>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.4.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, 10.4);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = ceil(x).
        /// mpfr_lib.mpf_ceil(z, x);
        /// 
        /// // Assert that the value of z is 11.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 11.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.4.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, 10.4)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = ceil(x).
        /// mpfr_lib.mpf_ceil(z, x)
        /// 
        /// ' Assert that the value of z is 11.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 11.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_ceil(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_ceil(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Free the space occupied by <paramref name="x"/>.
        /// </summary>
        /// <param name="x">The operand float.</param>
        /// <remarks>
        /// <para>
        /// Make sure to call this function for all <see cref="mpf_t"/> variables when you are done with them. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create and initialize a new floating-point number x.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// 
        /// // Assert that the value of x is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init(x)
        /// 
        /// ' Assert that the value of x is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_clear(mpf_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            x._initialized = false;
            SafeNativeMethods.__mpfrf_clear(x.ToIntPtr());
        }

        /// <summary>
        /// Free the space occupied by a NULL-terminated list of <see cref="mpf_t"/> variables. 
        /// </summary>
        /// <param name="x">The operand float.</param>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new floating-point numbers x1, x2 and x3.
        /// mpf_t x1 = new mpf_t();
        /// mpf_t x2 = new mpf_t();
        /// mpf_t x3 = new mpf_t();
        /// 
        /// // Initialize the floating-point numbers.
        /// mpfr_lib.mpf_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x1) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x2) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x3) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpf_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create new floating-point numbers x1, x2 and x3.
        /// Dim x1 As New mpf_t()
        /// Dim x2 As New mpf_t()
        /// Dim x3 As New mpf_t()
        /// 
        /// ' Initialize the floating-point numbers.
        /// mpfr_lib.mpf_inits(x1, x2, x3, Nothing)
        /// 
        /// ' Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x1) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x2) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x3) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpf_clears(x1, x2, x3, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_clears(params mpf_t[] x)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpf_t a in x) { if (a != null) mpf_clear(a); }
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand float.</param>
        /// <param name="op2">The second operand float.</param>
        /// <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_z"/>
        /// <seealso cref="mpf_cmp_d"/>
        /// <seealso cref="mpf_cmp_ui"/>
        /// <seealso cref="mpf_cmp_si"/>
        /// <seealso cref="mpf_reldiff"/>
        /// <seealso cref="mpf_sgn"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Comparison.html#Float-Comparison">GNU MPFR - Float Comparison</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 512.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 512);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(z, 128);
        /// 
        /// // Assert that x > z.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp(x, z) > 0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 512.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 512)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(z, 128)
        /// 
        /// ' Assert that x > z.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp(x, z) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static int mpf_cmp(/*const*/ mpf_t op1, /*const*/ mpf_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrf_cmp(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand float.</param>
        /// <param name="op2">The second operand float.</param>
        /// <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_d"/>
        /// <seealso cref="mpf_cmp_ui"/>
        /// <seealso cref="mpf_cmp_si"/>
        /// <seealso cref="mpf_reldiff"/>
        /// <seealso cref="mpf_sgn"/>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 512.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 512);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpz_t z = new mpz_t();
        /// mpfr_lib.mpz_init_set_si(z, 128);
        /// 
        /// // Assert that x > z.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_z(x, z) > 0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.mpz_clear(z);
        /// /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 512.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 512)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpz_t()
        /// mpfr_lib.mpz_init_set_si(z, 128)
        /// 
        /// ' Assert that x > z.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_z(x, z) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.mpz_clear(z)
        /// </code> 
        /// </example>
        public static int mpf_cmp_z(/*const*/ mpf_t op1, /*const*/ mpz_t op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            return SafeNativeMethods.__mpfrf_cmp_z(op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand float.</param>
        /// <param name="op2">The second operand float.</param>
        /// <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
        /// <remarks>
        /// <para>
        /// <see cref="mpf_cmp_d"/> can be called with an infinity, but results are undefined for a NaN. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_z"/>
        /// <seealso cref="mpf_cmp_ui"/>
        /// <seealso cref="mpf_cmp_si"/>
        /// <seealso cref="mpf_reldiff"/>
        /// <seealso cref="mpf_sgn"/>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 512.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 512);
        /// 
        /// // Assert that x > 128.0.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_d(x, 128.0) > 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 512.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 512)
        /// 
        /// ' Assert that x > 128.0.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_d(x, 128.0) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static int mpf_cmp_d(/*const*/ mpf_t op1, double op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrf_cmp_d(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand float.</param>
        /// <param name="op2">The second operand float.</param>
        /// <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_z"/>
        /// <seealso cref="mpf_cmp_d"/>
        /// <seealso cref="mpf_cmp_ui"/>
        /// <seealso cref="mpf_reldiff"/>
        /// <seealso cref="mpf_sgn"/>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 512.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 512);
        /// 
        /// // Assert that x > 128.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_si(x, 128) > 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 512.
        /// Dim x As New mpf_t()
        /// 
        /// mpfr_lib.mpf_init_set_si(x, 512)
        /// 
        /// ' Assert that x > 128.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_si(x, 128) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static int mpf_cmp_si(/*const*/ mpf_t op1, int /*long int*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrf_cmp_si(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Compare <paramref name="op1"/> and <paramref name="op2"/>.
        /// </summary>
        /// <param name="op1">The first operand float.</param>
        /// <param name="op2">The second operand float.</param>
        /// <returns>Return a positive value if op1 &gt; op2, zero if op1 = op2, and a negative value if op1 &lt; op2.</returns>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_z"/>
        /// <seealso cref="mpf_cmp_d"/>
        /// <seealso cref="mpf_cmp_si"/>
        /// <seealso cref="mpf_reldiff"/>
        /// <seealso cref="mpf_sgn"/>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 512.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 512);
        /// 
        /// // Assert that x > 128.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_ui(x, 128) > 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 512.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 512)
        /// 
        /// ' Assert that x > 128.
        /// Assert.IsTrue(mpfr_lib.mpf_cmp_ui(x, 128) > 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static int mpf_cmp_ui(/*const*/ mpf_t op1, uint /*unsigned long int*/ op2)
        {
            if (op1 == null) throw new ArgumentNullException("op1");
            return SafeNativeMethods.__mpfrf_cmp_ui(op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <remarks>
        /// <para>
        /// Division is undefined if the divisor is zero, and passing a zero divisor to the divide
        /// functions will make it intentionally divide by zero.
        /// This lets the user handle arithmetic exceptions in division functions in the same manner
        /// as other arithmetic exceptions. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_ui_div"/>
        /// <seealso cref="mpf_div_ui"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpf_div_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = y / x.
        /// mpfr_lib.mpf_div(z, y, x);
        /// 
        /// // Assert that the value of z is -21.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(y, -210)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = y / x.
        /// mpfr_lib.mpf_div(z, y, x)
        /// 
        /// ' Assert that the value of z is -21.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = -21.0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_div(mpf_t rop, /*const*/ mpf_t op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_div(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / 2^<paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The fisrt operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_ui_div"/>
        /// <seealso cref="mpf_div_ui"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 512.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 512);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x / 2^8.
        /// mpfr_lib.mpf_div_2exp(z, x, 8U);
        /// 
        /// // Assert that the value of z is 2.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 2.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 512.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 512)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x / 2^8.
        /// mpfr_lib.mpf_div_2exp(z, x, 8UI)
        /// 
        /// ' Assert that the value of z is 2.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 2.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_div_2exp(mpf_t rop, /*const*/ mpf_t op1, uint /*mp_bitcnt_t*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_div_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <remarks>
        /// <para>
        /// Division is undefined if the divisor is zero, and passing a zero divisor to the divide
        /// functions will make it intentionally divide by zero.
        /// This lets the user handle arithmetic exceptions in division functions in the same manner
        /// as other arithmetic exceptions. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_ui_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpf_div_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = y / 10.
        /// mpfr_lib.mpf_div_ui(z, y, 10U);
        /// 
        /// // Assert that the value of z is -21.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == -21.0);
        /// 
        /// // Release unmanaged memory allocated for y and z.
        /// mpfr_lib.mpf_clears(y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpf_div_ui(mpf_t rop, /*const*/ mpf_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_div_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_sint_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_sint_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_fits_sint_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_fits_sint_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> fits in a 32-bit integer, when truncated to an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in long.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_slong_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in long.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_slong_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_fits_slong_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_fits_slong_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> fits in a 16-bit integer, when truncated to an integer. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> fits in a 16-bit integer, when truncated to an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in short.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_sshort_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in short.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_sshort_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_fits_sshort_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_fits_sshort_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in uint.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_uint_p(op) > 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in uint.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_uint_p(op) > 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_fits_uint_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_fits_uint_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> fits in an unsigned 32-bit integer, when truncated to an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_sint_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in int.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_sint_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_fits_ulong_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_fits_ulong_p(op.ToIntPtr());
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> fits in an unsigned 16-bit integer, when truncated to an integer. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> fits in an unsigned 16-bit integer, when truncated to an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// // Create, initialize, and set the value of op 4294967295.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, uint.MaxValue);
        /// 
        /// // Assert that op does not fit in ushort.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_ushort_p(op) == 0);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// ' Create, initialize, and set the value of op 4294967295.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(op, UInteger.MaxValue)
        /// 
        /// ' Assert that op does not fit in ushort.
        /// Assert.IsTrue(mpfr_lib.mpf_fits_ushort_p(op) = 0)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_fits_ushort_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_fits_ushort_p(op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the next lower integer.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand float.</param>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// / Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.4.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, 10.4);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = floor(x).
        /// mpfr_lib.mpf_floor(z, x);
        /// 
        /// // Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.4.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, 10.4)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = floor(x).
        /// mpfr_lib.mpf_floor(z, x)
        /// 
        /// ' Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_floor(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_floor(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a <see cref="double"/>, truncating if necessary (i.e. rounding towards zero). 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>The cpnverted <see cref="double"/>.</returns>
        /// <remarks>
        /// <para>
        /// If the exponent in <paramref name="op"/> is too big or too small to fit a <see cref="double"/> then the result is system dependent.
        /// For too big an infinity is returned when available.
        /// For too small 0.0 is normally returned.
        /// Hardware overflow, underflow and denorm traps may or may not occur. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_get_d_2exp"/>
        /// <seealso cref="mpf_get_si"/>
        /// <seealso cref="mpf_get_ui"/>
        /// <seealso cref="mpf_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Floats.html#Converting-Floats">GNU MPFR - Converting Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number to -123.0
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, -123.0);
        /// 
        /// // Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number to -123.0
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, -123.0)
        /// 
        /// ' Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static double mpf_get_d(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_get_d(op.ToIntPtr());
        }

        /// <summary>
        /// Convert op to a double, truncating if necessary (i.e. rounding towards zero), and with an exponent returned separately. 
        /// </summary>
        /// <param name="exp">Pointer to 32-bit signed integer.</param>
        /// <param name="op">The operand float.</param>
        /// <returns>The return value is in the range 0.5 &#8804; | d | &lt; 1 and the exponent is stored at <paramref name="exp"/>. d * 2^<paramref name="exp"/> is the (truncated) <paramref name="op"/> value. If <paramref name="op"/> is zero, the return is 0.0 and 0 is stored at <paramref name="exp"/>.</returns>
        /// <remarks>
        /// <para>
        /// This is similar to the standard C <c>frexp</c> function
        /// (see <a href="https://www.gnu.org/software/libc/manual/html_node/Normalization-Functions.html#Normalization-Functions">GNU C - Normalization Functions</a> in The GNU C Library Reference Manual). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_get_d"/>
        /// <seealso cref="mpf_get_si"/>
        /// <seealso cref="mpf_get_ui"/>
        /// <seealso cref="mpf_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Floats.html#Converting-Floats">GNU MPFR - Converting Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, -8.0);
        /// 
        /// // Assert that the absolute value of x is 0.5 x 2^4.
        /// ptr&lt;int&gt; exp = new ptr&lt;int&gt;(0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_d_2exp(exp, x) == 0.5);
        /// Assert.IsTrue(exp.Value == 4);
        /// 
        /// // Release unmanaged memory allocated for x and exp.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, -8.0)
        /// 
        /// ' Assert that the absolute value of x is 0.5 x 2^4.
        /// Dim exp As New ptr(Of Integer)(0)
        /// Assert.IsTrue(mpfr_lib.mpf_get_d_2exp(exp, x) = 0.5)
        /// Assert.IsTrue(exp.Value = 4)
        /// 
        /// ' Release unmanaged memory allocated for x and exp.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static double mpf_get_d_2exp(ptr<int> /*long int **/ exp, /*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_get_d_2exp(ref exp.Value, op.ToIntPtr());
        }

        /// <summary>
        /// Return the default precision actually used. 
        /// </summary>
        /// <returns>The default precision actually used.</returns>
        /// <remarks>
        /// <para>
        /// An <see cref="mpf_t"/> object must be initialized before storing the first value in it.
        /// The functions <see cref="mpf_init"/> and <see cref="mpf_init2"/> are used for that purpose. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 128 bits.
        /// mpfr_lib.mpf_set_default_prec(128U);
        /// 
        /// // Assert that the value of x is 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_default_prec() == 128U);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 128 bits.
        /// mpfr_lib.mpf_set_default_prec(128UI)
        /// 
        /// ' Assert that the value of x is 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_default_prec() = 128UI)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpf_get_default_prec()
        {
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrf_get_default_prec());
        }

        /// <summary>
        /// Return the current precision of <paramref name="op"/>, in bits. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>The current precision of <paramref name="op"/>, in bits.</returns>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x with 64-bit precision.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 64U);
        /// 
        /// // Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_prec(x) == 64U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x with 64-bit precision.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 64UI)
        /// 
        /// ' Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpf_get_prec(x) = 64UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpf_get_prec(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrf_get_prec(op.ToIntPtr()));
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a 32-bit integer, truncating any fraction part.
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>The converted integer.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is too big for the return type, the result is undefined. 
        /// </para>
        /// <para>
        /// See also <see cref="mpf_fits_slong_p"/> and <see cref="mpf_fits_ulong_p"/>
        /// (see <a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a>). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_get_d"/>
        /// <seealso cref="mpf_get_d_2exp"/>
        /// <seealso cref="mpf_get_ui"/>
        /// <seealso cref="mpf_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Floats.html#Converting-Floats">GNU MPFR - Converting Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, -8.0);
        /// 
        /// // Assert that the value of x is -8.
        /// Assert.IsTrue(mpfr_lib.mpf_get_si(x) == -8);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, -8.0)
        /// 
        /// ' Assert that the value of x is -8.
        /// Assert.IsTrue(mpfr_lib.mpf_get_si(x) = -8)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static int /*long int*/ mpf_get_si(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_get_si(op.ToIntPtr());
        }

        /// <summary>
        /// Convert <paramref name="op"/> to a string of digits in base <paramref name="base"/>.
        /// </summary>
        /// <param name="str"></param>
        /// <param name="expptr"></param>
        /// <param name="base"></param>
        /// <param name="n_digits"></param>
        /// <param name="op"></param>
        /// <returns>A pointer to the result string is returned, being either the allocated block or the given <paramref name="str"/>.</returns>
        /// <remarks>
        /// <para>
        /// The <paramref name="base"/> argument may vary from 2 to 62 or from -2 to -36.
        /// Up to <paramref name="n_digits"/> digits will be generated.
        /// Trailing zeros are not returned.
        /// No more digits than can be accurately represented by <paramref name="op"/> are ever generated.
        /// If <paramref name="n_digits"/> is 0 then that accurate maximum number of digits are generated. 
        /// </para>
        /// <para>
        /// For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used; for -2..-36,
        /// digits and upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters
        /// (in that significance order) are used. 
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is NULL, the result string is allocated using the current allocation function
        /// (see <a href="https://mpfrlib.org/manual/Custom-Allocation.html#Custom-Allocation">GNU MPFR - Custom Allocation</a>).
        /// The block will be strlen(str) + 1 bytes, that being exactly enough for the string and null-terminator.
        /// </para>
        /// <para>
        /// If <paramref name="str"/> is not NULL, it should point to a block of <paramref name="n_digits"/> + 2 bytes,
        /// that being enough for the mantissa, a possible minus sign, and a null-terminator.
        /// When <paramref name="n_digits"/> is 0 to get all significant digits, an application won’t be able to know
        /// the space required, and <paramref name="str"/> should be NULL in that case. 
        /// </para>
        /// <para>
        /// The generated string is a fraction, with an implicit radix point immediately to the left of the first digit.
        /// The applicable exponent is written through the <paramref name="expptr"/> pointer.
        /// For example, the number 3.1416 would be returned as string "31416" and exponent 1.
        /// </para>
        /// <para>
        /// When <paramref name="op"/> is zero, an empty string is produced and the exponent returned is 0. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_get_d"/>
        /// <seealso cref="mpf_get_d_2exp"/>
        /// <seealso cref="mpf_get_si"/>
        /// <seealso cref="mpf_get_ui"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Floats.html#Converting-Floats">GNU MPFR - Converting Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number to -8.0
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, -8.0);
        /// 
        /// // Assert that the value of x is -8.
        /// ptr&lt;mp_exp_t&gt; exp = new ptr&lt;mp_exp_t&gt;(0);
        /// char_ptr value = mpfr_lib.mpf_get_str(char_ptr.Zero, exp, 10, 0, x);
        /// Assert.IsTrue(value.ToString() == "-8");
        /// Assert.IsTrue(exp.Value == 1);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number to -8.0
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, -8.0)
        /// 
        /// ' Assert that the value of x is -8.
        /// Dim exp As New ptr(Of mp_exp_t)(0)
        /// Dim value As char_ptr = mpfr_lib.mpf_get_str(char_ptr.Zero, exp, 10, 0, x)
        /// Assert.IsTrue(value.ToString() = "-8")
        /// Assert.IsTrue(exp.Value = 1)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static char_ptr mpf_get_str(char_ptr str, ptr<mp_exp_t> expptr, int @base, size_t n_digits, /*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new char_ptr(SafeNativeMethods.__mpfrf_get_str_x86(str.ToIntPtr(), ref expptr.Value._value, @base, (uint)n_digits, op.ToIntPtr()));
            else
                return new char_ptr(SafeNativeMethods.__mpfrf_get_str_x64(str.ToIntPtr(), ref expptr.Value._value, @base, n_digits, op.ToIntPtr()));
        }

        /// <summary>
        /// Convert <paramref name="op"/> to an unsigned 32-bit integer, truncating any fraction part.
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>The converted integer.</returns>
        /// <remarks>
        /// <para>
        /// If <paramref name="op"/> is too big for the return type, the result is undefined. 
        /// </para>
        /// <para>
        /// See also <see cref="mpf_fits_slong_p"/> and <see cref="mpf_fits_ulong_p"/>
        /// (see <a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a>). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_get_d"/>
        /// <seealso cref="mpf_get_d_2exp"/>
        /// <seealso cref="mpf_get_si"/>
        /// <seealso cref="mpf_get_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Converting-Floats.html#Converting-Floats">GNU MPFR - Converting Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static uint /*unsigned long int*/ mpf_get_ui(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_get_ui(op.ToIntPtr());
        }

        /// <summary>
        /// Initialize <paramref name="x"/> to 0.
        /// </summary>
        /// <param name="x">The operand float.</param>
        /// <remarks>
        /// <para>
        /// Normally, a variable should be initialized once only or at least be cleared, using <see cref="mpf_clear"/>,
        /// between initializations. The precision of <paramref name="x"/> is undefined unless a default precision has
        /// already been established by a call to <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create and initialize a new floating-point number x.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// 
        /// // Assert that the value of x is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As New mpf_t()
        /// 
        /// mpfr_lib.mpf_init(x)
        /// 
        /// ' Assert that the value of x is 0.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 0.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_init(mpf_t x)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrf_init(x.ToIntPtr());
            x._initialized = true;
        }

        /// <summary>
        /// Initialize <paramref name="x"/> to 0 and set its precision to be at least <paramref name="prec"/> bits.
        /// </summary>
        /// <param name="x">The operand float.</param>
        /// <param name="prec">The minimum precision in bits.</param>
        /// <remarks>
        /// <para>
        /// Normally, a variable should be initialized once only or at least be cleared, using <see cref="mpf_clear"/>, between initializations. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x with 64-bit precision.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 64U);
        /// 
        /// // Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 0.0);
        /// uint p = mpfr_lib.mpf_get_prec(x);
        /// Assert.IsTrue(mpfr_lib.mpf_get_prec(x) == 64U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x with 64-bit precision.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 64UI)
        /// 
        /// ' Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 0.0)
        /// Dim p As UInteger = mpfr_lib.mpf_get_prec(x)
        /// Assert.IsTrue(mpfr_lib.mpf_get_prec(x) = 64UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_init2(mpf_t x, mp_bitcnt_t prec)
        {
            if (x == null) throw new ArgumentNullException("x");
            SafeNativeMethods.__mpfrf_init2(x.ToIntPtr(), prec);
            x._initialized = true;
        }

        /// <summary>
        /// Initialize a NULL-terminated list of <see cref="mpf_t"/> variables, and set their values to 0.
        /// </summary>
        /// <param name="x">The operand float.</param>
        /// <remarks>
        /// <para>
        /// The precision of the initialized variables is undefined unless a default precision has already
        /// been established by a call to <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create new floating-point numbers x1, x2 and x3.
        /// mpf_t x1 = new mpf_t();
        /// mpf_t x2 = new mpf_t();
        /// mpf_t x3 = new mpf_t();
        /// 
        /// // Initialize the floating-point numbers.
        /// mpfr_lib.mpf_inits(x1, x2, x3, null);
        /// 
        /// // Assert that their value is 0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x1) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x2) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x3) == 0.0);
        /// 
        /// // Release unmanaged memory allocated for the floating-point numbers.
        /// mpfr_lib.mpf_clears(x1, x2, x3, null);
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static void mpf_inits(params mpf_t[] x)
        {
            if (x == null) throw new ArgumentNullException("x");
            foreach (mpf_t a in x) { if (a != null) mpf_init(a); }
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_init_set_ui"/>
        /// <seealso cref="mpf_init_set_si"/>
        /// <seealso cref="mpf_init_set_d"/>
        /// <seealso cref="mpf_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MPFR - Combined Float Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to x.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set(y, x);
        /// 
        /// // Assert that the value of y is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(y) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to x.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set(y, x)
        /// 
        /// ' Assert that the value of y is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(y) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_init_set(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_init_set(rop.ToIntPtr(), op.ToIntPtr());
            rop._initialized = true;
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_init_set"/>
        /// <seealso cref="mpf_init_set_ui"/>
        /// <seealso cref="mpf_init_set_si"/>
        /// <seealso cref="mpf_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MPFR - Combined Float Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number to -123.0
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, -123.0);
        /// 
        /// // Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number to -123.0
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, -123.0)
        /// 
        /// ' Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_init_set_d(mpf_t rop, double op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_init_set_d(rop.ToIntPtr(), op);
            rop._initialized = true;
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_init_set"/>
        /// <seealso cref="mpf_init_set_ui"/>
        /// <seealso cref="mpf_init_set_d"/>
        /// <seealso cref="mpf_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MPFR - Combined Float Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize and set a new floating-point number to -123.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, -123);
        /// 
        /// // Assert that the value of x is -123.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize and set a new floating-point number to -123.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, -123)
        /// 
        /// ' Assert that the value of x is -123.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_init_set_si(mpf_t rop, int /*long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_init_set_si(rop.ToIntPtr(), op);
            rop._initialized = true;
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from the string in <paramref name="str"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="str">The operand string.</param>
        /// <param name="base">The base.</param>
        /// <returns>This function returns 0 if the entire string is a valid number in base <paramref name="base"/>. Otherwise it returns -1.</returns>
        /// <remarks>
        /// <para>
        /// See <see cref="mpf_set_str"/> for details on the assignment operation. 
        /// </para>
        /// <para>
        /// Note that <paramref name="rop"/> is initialized even if an error occurs. (I.e., you have to call <see cref="mpf_clear"/> for it.) 
        /// </para>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_init_set"/>
        /// <seealso cref="mpf_init_set_ui"/>
        /// <seealso cref="mpf_init_set_si"/>
        /// <seealso cref="mpf_init_set_d"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MPFR - Combined Float Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 0.0234.
        /// char_ptr value = new char_ptr("234e-4");
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_str(x, value, 10);
        /// 
        /// // Assert that x is 40.
        /// Assert.IsTrue(x.ToString() == "0.234e-1");
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 0.0234.
        /// Dim value As New char_ptr("234e-4")
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_str(x, value, 10)
        /// 
        /// ' Assert that x is 40.
        /// Assert.IsTrue(x.ToString() = "0.234e-1")
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static int mpf_init_set_str(mpf_t rop, /*const*/ char_ptr str, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            int result = SafeNativeMethods.__mpfrf_init_set_str(rop.ToIntPtr(), str.ToIntPtr(), @base);
            rop._initialized = true;
            return result;
        }

        /// <summary>
        /// Initialize <paramref name="rop"/> and set its value from <paramref name="op"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <remarks>
        /// <para>
        /// The precision of <paramref name="rop"/> will be taken from the active default precision, as set by <see cref="mpf_set_default_prec"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_init_set"/>
        /// <seealso cref="mpf_init_set_si"/>
        /// <seealso cref="mpf_init_set_d"/>
        /// <seealso cref="mpf_init_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Simultaneous-Float-Init-_0026-Assign.html#Simultaneous-Float-Init-_0026-Assign">GNU MPFR - Combined Float Initialization and Assignment</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number to 100.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(x, 100U);
        /// 
        /// // Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 100.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number to 100.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_ui(x, 100UI)
        /// 
        /// ' Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 100.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_init_set_ui(mpf_t rop, uint /*unsigned long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_init_set_ui(rop.ToIntPtr(), op);
            rop._initialized = true;
        }

        /// <summary>
        /// Read a string in base <paramref name="base"/> from <paramref name="stream"/>, and put the read float in <paramref name="rop"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="stream">Pointer to file stream.</param>
        /// <param name="base">The base.</param>
        /// <returns>Return the number of bytes read, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// The string is of the form "M@N" or, if the base is 10 or less, alternatively "MeN".
        /// "M" is the mantissa and "N’" is the exponent.
        /// The mantissa is always in the specified <paramref name="base"/>.
        /// The exponent is either in the specified <paramref name="base"/> or, if <paramref name="base"/> is negative, in decimal.
        /// The decimal point expected is taken from the current locale, on systems providing <c>localeconv</c>.
        /// </para>
        /// <para>
        /// The argument <paramref name="base"/> may be in the ranges 2 to 36, or -36 to -2.
        /// Negative values are used to specify that the exponent is in decimal. 
        /// </para>
        /// <para>
        /// Unlike the corresponding <c>mpz</c> function, the <paramref name="base"/> will not be determined from the leading
        /// characters of the string if base is 0.
        /// This is so that numbers like "0.23" are not interpreted as octal.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_out_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Floats.html#I_002fO-of-Floats">GNU MPFR - I/O of Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize op.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init(op);
        /// 
        /// // Write op to a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// System.IO.File.WriteAllText(pathname, "0.123456e6");
        /// 
        /// // Read op from the temporary file, and assert that the number of bytes read is 6.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "r");
        /// Assert.IsTrue(mpfr_lib.mpf_inp_str(op, stream, 10) == 10);
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpf_get_ui(op) == 123456U);
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize op.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init(op)
        /// 
        /// ' Write op to a temporary file.
        /// Dim pathname As String = System.IO.Path.GetTempFileName()
        /// System.IO.File.WriteAllText(pathname, "0.123456e6")
        /// 
        /// ' Read op from the temporary file, and assert that the number of bytes read is 6.
        /// Dim stream As New ptr(Of FILE)()
        /// _wfopen_s(stream.Value.Value, pathname, "r")
        /// Assert.IsTrue(mpfr_lib.mpf_inp_str(op, stream, 10) = 10)
        /// fclose(stream.Value.Value)
        /// 
        /// ' Assert that op is 123456.
        /// Assert.IsTrue(mpfr_lib.mpf_get_ui(op) = 123456UI)
        /// 
        /// ' Delete temporary file.
        /// System.IO.File.Delete(pathname)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static size_t mpf_inp_str(mpf_t rop, ptr<FILE> stream, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrf_inp_str_x86(rop.ToIntPtr(), stream.Value.Value, @base));
            else
                return new size_t(SafeNativeMethods.__mpfrf_inp_str_x64(rop.ToIntPtr(), stream.Value.Value, @base));
        }

        /// <summary>
        /// Return non-zero if <paramref name="op"/> is an integer.
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return non-zero if <paramref name="op"/> is an integer.</returns>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, 10);
        /// 
        /// // Assert that s is an integer.
        /// Assert.IsTrue(mpfr_lib.mpf_integer_p(x) != 0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, 10)
        /// 
        /// ' Assert that s is an integer.
        /// Assert.IsTrue(mpfr_lib.mpf_integer_p(x) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static int mpf_integer_p(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return SafeNativeMethods.__mpfrf_integer_p(op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul_ui"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpf_mul_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x * y.
        /// mpfr_lib.mpf_mul(z, x, y);
        /// 
        /// // Assert that the value of z is -2100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == -2100.0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(y, -210)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x * y.
        /// mpfr_lib.mpf_mul(z, x, y)
        /// 
        /// ' Assert that the value of z is -2100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = -2100.0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_mul(mpf_t rop, /*const*/ mpf_t op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_mul(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * 2^<paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_mul_ui"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 100);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x * 2^8.
        /// mpfr_lib.mpf_mul_2exp(z, x, 8U);
        /// 
        /// // Assert that the value of z is 25600.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 25600.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 100)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x * 2^8.
        /// mpfr_lib.mpf_mul_2exp(z, x, 8UI)
        /// 
        /// ' Assert that the value of z is 25600.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 25600.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_mul_2exp(mpf_t rop, /*const*/ mpf_t op1, mp_bitcnt_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_mul_2exp(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> * <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpf_mul_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x * 210.
        /// mpfr_lib.mpf_mul_ui(z, x, 210U);
        /// 
        /// // Assert that the value of z is 2100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 2100.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x * 210.
        /// mpfr_lib.mpf_mul_ui(z, x, 210UI)
        /// 
        /// ' Assert that the value of z is 2100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 2100.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_mul_ui(mpf_t rop, /*const*/ mpf_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_mul_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to -<paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = -x.
        /// mpfr_lib.mpf_neg(z, x);
        /// 
        /// // Assert that the value of z is -10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == -10.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = -x.
        /// mpfr_lib.mpf_neg(z, x)
        /// 
        /// ' Assert that the value of z is -10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = -10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_neg(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_neg(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Print <paramref name="op"/> to <paramref name="stream"/>, as a string of digits.
        /// </summary>
        /// <param name="stream">Pointer to file stream.</param>
        /// <param name="base">The base.</param>
        /// <param name="n_digits">Maximum number fo digits to write.</param>
        /// <param name="op">The operand float.</param>
        /// <returns>Return the number of bytes written, or if an error occurred, return 0.</returns>
        /// <remarks>
        /// <para>
        /// The mantissa is prefixed with an "0." and is in the given <paramref name="base"/>,
        /// which may vary from 2 to 62 or from -2 to -36.
        /// An exponent is then printed, separated by an "e", or if the <paramref name="base"/>
        /// is greater than 10 then by an "@".
        /// The exponent is always in decimal.
        /// The decimal point follows the current locale, on systems providing <c>localeconv</c>. 
        /// </para>
        /// <para>
        /// For <paramref name="base"/> in the range 2..36, digits and lower-case letters are used;
        /// for -2..-36, digits and upper-case letters are used; for 37..62, digits,
        /// upper-case letters, and lower-case letters (in that significance order) are used. 
        /// </para>
        /// <para>
        /// Up to <paramref name="n_digits"/> will be printed from the mantissa, except that no more
        /// digits than are accurately representable by op will be printed.
        /// <paramref name="n_digits"/> can be 0 to select that accurate maximum. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_inp_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/I_002fO-of-Floats.html#I_002fO-of-Floats">GNU MPFR - I/O of Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to 123456.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_ui(op, 123456U);
        /// 
        /// // Get a temporary file.
        /// string pathname = System.IO.Path.GetTempFileName();
        /// 
        /// // Open temporary file for writing.
        /// ptr&lt;FILE&gt; stream = new ptr&lt;FILE&gt;();
        /// _wfopen_s(out stream.Value.Value, pathname, "w");
        /// 
        /// // Write op to temporary file, and assert that the number of bytes written is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_out_str(stream, 10, 0, op) == 10);
        /// 
        /// // Close temporary file.
        /// fclose(stream.Value.Value);
        /// 
        /// // Assert that the content of the temporary file is "123456".
        /// string result = System.IO.File.ReadAllText(pathname);
        /// Assert.IsTrue(result == "0.123456e6");
        /// 
        /// // Delete temporary file.
        /// System.IO.File.Delete(pathname);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static size_t mpf_out_str(ptr<FILE> stream, int @base, size_t n_digits, /*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrf_out_str_x86(stream.Value.Value, @base, (uint)n_digits, op.ToIntPtr()));
            else
                return new size_t(SafeNativeMethods.__mpfrf_out_str_x64(stream.Value.Value, @base, n_digits, op.ToIntPtr()));
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/>^<paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = sqrt(x).
        /// mpfr_lib.mpf_pow_ui(z, x, 3U);
        /// 
        /// // Assert that the value of z is 1000.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 1000.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = sqrt(x).
        /// mpfr_lib.mpf_pow_ui(z, x, 3UI)
        /// 
        /// ' Assert that the value of z is 1000.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 1000.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_pow_ui(mpf_t rop, /*const*/ mpf_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_pow_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Generate a random float of at most <paramref name="max_size"/> limbs, with long strings of zeros and ones in the binary representation.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="max_size">The maximum number of limbs.</param>
        /// <param name="exp">The range of the random exponent.</param>
        /// <remarks>
        /// <para>
        /// The exponent of the number is in the interval -<paramref name="exp"/> to <paramref name="exp"/> (in limbs).
        /// This function is useful for testing functions and algorithms, since these kind of random numbers have proven to be more
        /// likely to trigger corner-case bugs.
        /// Negative random numbers are generated when <paramref name="max_size"/> is negative. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of rop to 0.
        /// mpf_t rop = new mpf_t();
        /// mpfr_lib.mpf_init(rop);
        /// 
        /// // Generate a random floating-point number with at most 10 limbs and its exponent in [-5 5].
        /// mpfr_lib.mpf_random2(rop, 10, 5);
        /// 
        /// // Free all memory occupied by rop.
        /// mpfr_lib.mpf_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpf_t()
        /// mpfr_lib.mpf_init(rop)
        /// 
        /// ' Generate a random floating-point number with at most 10 limbs and its exponent in [-5 5].
        /// mpfr_lib.mpf_random2(rop, 10, 5)
        /// 
        /// ' Free all memory occupied by rop.
        /// mpfr_lib.mpf_clear(rop)
        /// </code> 
        /// </example>
        public static void mpf_random2(mpf_t rop, mp_size_t max_size, mp_exp_t exp)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_random2(rop.ToIntPtr(), max_size, exp);
        }

        /// <summary>
        /// Compute the relative difference between <paramref name="op1"/> and <paramref name="op2"/> and store the result in <paramref name="rop"/>. This is | <paramref name="op1"/> - <paramref name="op2"/> | / <paramref name="op1"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand float.</param>
        /// <param name="op2">The second operand float.</param>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_z"/>
        /// <seealso cref="mpf_cmp_d"/>
        /// <seealso cref="mpf_cmp_ui"/>
        /// <seealso cref="mpf_cmp_si"/>
        /// <seealso cref="mpf_sgn"/>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = |x - y| / x.
        /// mpfr_lib.mpf_reldiff(z, x, y);
        /// 
        /// // Assert that the value of z is 22.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 22.0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(y, -210)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = |x - y| / x.
        /// mpfr_lib.mpf_reldiff(z, x, y)
        /// 
        /// ' Assert that the value of z is 22.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 22.0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_reldiff(mpf_t rop, /*const*/ mpf_t op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_reldiff(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 128U);
        /// mpfr_lib.mpf_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init2(y, 128U);
        /// mpfr_lib.mpf_set_si(y, -210);
        /// 
        /// // Assign the value of y to x.
        /// mpfr_lib.mpf_set(x, y);
        /// 
        /// // Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -210.0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 128UI)
        /// mpfr_lib.mpf_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init2(y, 128UI)
        /// mpfr_lib.mpf_set_si(y, -210)
        /// 
        /// ' Assign the value of y to x.
        /// mpfr_lib.mpf_set(x, y)
        /// 
        /// ' Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -210.0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_set(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_set(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 128U);
        /// 
        /// // Set x to -123.0.
        /// mpfr_lib.mpf_set_d(x, -123.0);
        /// 
        /// // Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 128UI)
        /// 
        /// ' Set x to -123.0.
        /// mpfr_lib.mpf_set_d(x, -123.0)
        /// 
        /// ' Assert that the value of x is -123.0.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_set_d(mpf_t rop, double op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_set_d(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set the default precision to be at least <paramref name="prec"/> bits.
        /// </summary>
        /// <param name="prec">The minimum precision in bits.</param>
        /// <remarks>
        /// <para>
        /// All subsequent calls to <see cref="mpf_init"/> will use this precision, but previously initialized variables are unaffected. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 128 bits.
        /// mpfr_lib.mpf_set_default_prec(128U);
        /// 
        /// // Assert that the value of x is 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_default_prec() == 128U);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 128 bits.
        /// mpfr_lib.mpf_set_default_prec(128UI)
        /// 
        /// ' Assert that the value of x is 128 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_default_prec() = 128UI)
        /// </code> 
        /// </example>
        public static void mpf_set_default_prec(mp_bitcnt_t prec)
        {
            SafeNativeMethods.__mpfrf_set_default_prec(prec);
        }

        /// <summary>
        /// Set the precision of <paramref name="rop"/> to be at least <paramref name="prec"/> bits.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="prec">The minimum precision in bits.</param>
        /// <remarks>
        /// <para>
        /// The value in rop will be truncated to the new precision. 
        /// </para>
        /// <para>
        /// This function requires a call to <c>realloc</c>, and so should not be used in a tight loop. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec_raw"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number x.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// 
        /// // Set its precision to 64 bits.
        /// mpfr_lib.mpf_set_prec(x, 64U);
        /// 
        /// // Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 0.0);
        /// Assert.IsTrue(mpfr_lib.mpf_get_prec(x) == 64U);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number x.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init(x)
        /// 
        /// ' Set its precision to 64 bits.
        /// mpfr_lib.mpf_set_prec(x, 64UI)
        /// 
        /// ' Assert that the value of x is 0.0, and that its precision is 64 bits.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 0.0)
        /// Assert.IsTrue(mpfr_lib.mpf_get_prec(x) = 64UI)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_set_prec(mpf_t rop, mp_bitcnt_t prec)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_set_prec(rop.ToIntPtr(), prec);
        }

        /// <summary>
        /// Set the precision of <paramref name="rop"/> to be at least <paramref name="prec"/> bits, without changing the memory allocated. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="prec">The minimum precision in bits.</param>
        /// <remarks>
        /// <para>
        /// <paramref name="prec"/> must be no more than the allocated precision for <paramref name="rop"/>,
        /// that being the precision when <paramref name="rop"/> was initialized, or in the most recent <see cref="mpf_set_prec"/>. 
        /// </para>
        /// <para>
        /// The value in <paramref name="rop"/> is unchanged, and in particular if it had a higher precision than <paramref name="prec"/>
        /// it will retain that higher precision. New values written to <paramref name="rop"/> will use the new <paramref name="prec"/>. 
        /// </para>
        /// <para>
        /// Before calling <see cref="mpf_clear"/> or the full <see cref="mpf_set_prec"/>, another <see cref="mpf_set_prec_raw"/> call
        /// must be made to restore <paramref name="rop"/> to its original allocated precision. Failing to do so will have unpredictable results.
        /// </para>
        /// <para>
        /// <see cref="mpf_get_prec"/> can be used before <see cref="mpf_set_prec_raw"/> to get the original allocated precision.
        /// After <see cref="mpf_set_prec_raw"/> it reflects the prec value set. 
        /// </para>
        /// <para>
        /// <see cref="mpf_set_prec_raw"/> is an efficient way to use an <see cref="mpf_t"/> variable at different precisions during a calculation,
        /// perhaps to gradually increase precision in an iteration, or just to use various different precisions for different purposes during a calculation. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set_default_prec"/>
        /// <seealso cref="mpf_get_default_prec"/>
        /// <seealso cref="mpf_init"/>
        /// <seealso cref="mpf_init2"/>
        /// <seealso cref="mpf_inits"/>
        /// <seealso cref="mpf_clear"/>
        /// <seealso cref="mpf_clears"/>
        /// <seealso cref="mpf_get_prec"/>
        /// <seealso cref="mpf_set_prec"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Initializing-Floats.html#Initializing-Floats">GNU MPFR - Initializing Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 128 bits.
        /// mpfr_lib.mpf_set_default_prec(128U);
        /// 
        /// // Create, initialize, and set a new rational y to 200 / 3.
        /// mpq_t y = new mpq_t();
        /// mpfr_lib.mpq_init(y);
        /// mpfr_lib.mpq_set_ui(y, 200, 3U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to y.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// mpfr_lib.mpf_set_q(x, y);
        /// 
        /// Assert.IsTrue(x.ToString() == "0.6666666666666666666666666666666666666667e2");
        /// 
        /// // Change precision of x, and set its value to 10000 / 3.
        /// mpfr_lib.mpf_set_prec_raw(x, 8U);
        /// mpfr_lib.mpq_set_ui(y, 10000, 3U);
        /// mpfr_lib.mpf_set_q(x, y);
        /// 
        /// Assert.IsTrue(x.ToString() == "0.333333333333333333333e4");
        /// 
        /// // Restore precision of x.
        /// mpfr_lib.mpf_set_prec_raw(x, 128U);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.mpq_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 128 bits.
        /// mpfr_lib.mpf_set_default_prec(128UI)
        /// 
        /// ' Create, initialize, and set a new rational y to 200 / 3.
        /// Dim y As New mpq_t()
        /// mpfr_lib.mpq_init(y)
        /// mpfr_lib.mpq_set_ui(y, 200, 3UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to y.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init(x)
        /// mpfr_lib.mpf_set_q(x, y)
        /// Assert.IsTrue(x.ToString() = "0.6666666666666666666666666666666666666667e2")
        /// 
        /// ' Change precision of x, and set its value to 10000 / 3.
        /// mpfr_lib.mpf_set_prec_raw(x, 8UI)
        /// mpfr_lib.mpq_set_ui(y, 10000, 3UI)
        /// mpfr_lib.mpf_set_q(x, y)
        /// Assert.IsTrue(x.ToString() = "0.333333333333333333333e4")
        /// 
        /// ' Restore precision of x.
        /// mpfr_lib.mpf_set_prec_raw(x, 128UI)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.mpq_clear(y)
        /// </code> 
        /// </example>
        public static void mpf_set_prec_raw(mpf_t rop, mp_bitcnt_t prec)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_set_prec_raw(rop.ToIntPtr(), prec);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new rational y to 200 / 5.
        /// mpq_t y = new mpq_t();
        /// mpfr_lib.mpq_init(y);
        /// mpfr_lib.mpq_set_ui(y, 200, 5U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to y.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// mpfr_lib.mpf_set_q(x, y);
        /// 
        /// // Assert that x is 40.
        /// Assert.IsTrue(x.ToString() == "0.4e2");
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.mpq_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new rational y to 200 / 5.
        /// Dim y As New mpq_t()
        /// mpfr_lib.mpq_init(y)
        /// mpfr_lib.mpq_set_ui(y, 200, 5UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to y.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init(x)
        /// mpfr_lib.mpf_set_q(x, y)
        /// 
        /// ' Assert that x is 40.
        /// Assert.IsTrue(x.ToString() = "0.4e2")
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.mpq_clear(y)
        /// </code> 
        /// </example>
        public static void mpf_set_q(mpf_t rop, /*const*/ mpq_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_set_q(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 128U);
        /// 
        /// // Set x to -123.
        /// mpfr_lib.mpf_set_si(x, -123);
        /// 
        /// // Assert that the value of x is -123.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -123.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 128UI)
        /// 
        /// ' Set x to -123.
        /// mpfr_lib.mpf_set_si(x, -123)
        /// 
        /// ' Assert that the value of x is -123.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -123.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_set_si(mpf_t rop, int /*long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_set_si(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from the string in <paramref name="str"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="str">The input string.</param>
        /// <param name="base">The base.</param>
        /// <returns>This function returns 0 if the entire string is a valid number in base <paramref name="base"/>. Otherwise it returns -1.</returns>
        /// <remarks>
        /// <para>
        /// The string is of the form "M@N" or, if the <paramref name="base"/> is 10 or less,
        /// alternatively "MeN".
        /// "M" is the mantissa and "N" is the exponent.
        /// The mantissa is always in the specified <paramref name="base"/>.
        /// The exponent is either in the specified <paramref name="base"/> or, if <paramref name="base"/> is negative, in decimal.
        /// The decimal point expected is taken from the current locale, on systems providing <c>localeconv</c>. 
        /// </para>
        /// <para>
        /// The argument <paramref name="base"/> may be in the ranges 2 to 62, or -62 to -2.
        /// Negative values are used to specify that the exponent is in decimal. 
        /// </para>
        /// <para>
        /// For bases up to 36, case is ignored; upper-case and lower-case letters have the same value;
        /// for bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case
        /// letter represent 36..61. 
        /// </para>
        /// <para>
        /// Unlike the corresponding <c>mpz</c> function, the <paramref name="base"/> will not be determined from the leading characters
        /// of the string if base is 0. This is so that numbers like "0.23" are not interpreted as octal. 
        /// </para>
        /// <para>
        /// White space is allowed in the string, and is simply ignored.
        /// [This is not really true; white-space is ignored in the beginning of the string and within the mantissa,
        /// but not in other places, such as after a minus sign or in the exponent.
        /// We are considering changing the definition of this function, making it fail when there is any white-space
        /// in the input, since that makes a lot of sense.
        /// Please tell us your opinion about this change.
        /// Do you really want it to accept "3 14" as meaning 314 as it does now?] 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 0.0234.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// char_ptr value = new char_ptr("234e-4");
        /// mpfr_lib.mpf_set_str(x, value, 10);
        /// 
        /// // Assert that x is 40.
        /// Assert.IsTrue(x.ToString() == "0.234e-1");
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.free(value);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 0.0234.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init(x)
        /// Dim value As New char_ptr("234e-4")
        /// mpfr_lib.mpf_set_str(x, value, 10)
        /// 
        /// ' Assert that x is 40.
        /// Assert.IsTrue(x.ToString() = "0.234e-1")
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.free(value)
        /// </code> 
        /// </example>
        public static int mpf_set_str(mpf_t rop, /*const*/ char_ptr str, int @base)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            return SafeNativeMethods.__mpfrf_set_str(rop.ToIntPtr(), str.ToIntPtr(), @base);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create and initialize a new floating-point number.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 128U);
        /// 
        /// // Set x to 100.
        /// mpfr_lib.mpf_set_ui(x, 100U);
        /// 
        /// // Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == 100.0);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create and initialize a new floating-point number.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 128UI)
        /// 
        /// ' Set x to 100.
        /// mpfr_lib.mpf_set_ui(x, 100UI)
        /// 
        /// ' Assert that the value of x is 100.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = 100.0)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static void mpf_set_ui(mpf_t rop, uint /*unsigned long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_set_ui(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set the value of <paramref name="rop"/> from <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpf_swap"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new integer y to 200.
        /// mpz_t y = new mpz_t();
        /// mpfr_lib.mpz_init(y);
        /// mpfr_lib.mpz_set_ui(y, 200U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to y.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init(x);
        /// mpfr_lib.mpf_set_z(x, y);
        /// 
        /// // Assert that x is 200.
        /// Assert.IsTrue(x.ToString() == "0.2e3");
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x);
        /// mpfr_lib.mpz_clear(y);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new integer y to 200.
        /// Dim y As New mpz_t()
        /// mpfr_lib.mpz_init(y)
        /// mpfr_lib.mpz_set_ui(y, 200UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to y.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init(x)
        /// mpfr_lib.mpf_set_z(x, y)
        /// 
        /// ' Assert that x is 200.
        /// Assert.IsTrue(x.ToString() = "0.2e3")
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clear(x)
        /// mpfr_lib.mpz_clear(y)
        /// </code> 
        /// </example>
        public static void mpf_set_z(mpf_t rop, /*const*/ mpz_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_set_z(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0. 
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>Return +1 if op &gt; 0, 0 if op = 0, and -1 if op &lt; 0.</returns>
        /// <seealso cref="mpf_cmp"/>
        /// <seealso cref="mpf_cmp_z"/>
        /// <seealso cref="mpf_cmp_d"/>
        /// <seealso cref="mpf_cmp_ui"/>
        /// <seealso cref="mpf_cmp_si"/>
        /// <seealso cref="mpf_reldiff"/>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set the value of op to -10.
        /// mpf_t op = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(op, -10);
        /// 
        /// // Assert that the sign of op is -1.
        /// Assert.IsTrue(mpfr_lib.mpf_sgn(op) == -1);
        /// 
        /// // Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set the value of op to -10.
        /// Dim op As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(op, -10)
        /// 
        /// ' Assert that the sign of op is -1.
        /// Assert.IsTrue(mpfr_lib.mpf_sgn(op) = -1)
        /// 
        /// ' Release unmanaged memory allocated for op.
        /// mpfr_lib.mpf_clear(op)
        /// </code> 
        /// </example>
        public static int mpf_sgn(mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            return op._mp_size < 0 ? -1 : (op._mp_size > 0 ? 1 : 0);
        }

        /// <summary>
        /// Return the number of limbs currently in use.
        /// </summary>
        /// <param name="op">The operand float.</param>
        /// <returns>The number of limbs currently in use.</returns>
        /// <seealso cref="mpf_t"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x.
        /// mpf_t x = "1.00000000000000000000001";
        /// 
        /// // Assert that the size of x is 1.
        /// Assert.IsTrue(mpfr_lib.mpf_size(x) == 4);
        /// 
        /// // Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x.
        /// Dim x As mpf_t = "1.00000000000000000000001"
        /// 
        /// ' Assert that the size of x is 1.
        /// Assert.IsTrue(mpfr_lib.mpf_size(x) = 4)
        /// 
        /// ' Release unmanaged memory allocated for x.
        /// mpfr_lib.mpf_clear(x)
        /// </code> 
        /// </example>
        public static size_t mpf_size(/*const*/ mpf_t op)
        {
            if (op == null) throw new ArgumentNullException("op");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrf_size_x86(op.ToIntPtr()));
            else
                return new size_t(SafeNativeMethods.__mpfrf_size_x64(op.ToIntPtr()));
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the square root of <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt_ui"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 100.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 100);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = sqrt(x).
        /// mpfr_lib.mpf_sqrt(z, x);
        /// 
        /// // Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 100.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 100)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = sqrt(x).
        /// mpfr_lib.mpf_sqrt(z, x)
        /// 
        /// ' Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_sqrt(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_sqrt(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to the square root of <paramref name="op"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = sqrt(100).
        /// mpfr_lib.mpf_sqrt_ui(z, 100U);
        /// 
        /// // Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clear(z);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = sqrt(100).
        /// mpfr_lib.mpf_sqrt_ui(z, 100UI)
        /// 
        /// ' Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clear(z)
        /// </code> 
        /// </example>
        public static void mpf_sqrt_ui(mpf_t rop, uint /*unsigned long int*/ op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            SafeNativeMethods.__mpfrf_sqrt_ui(rop.ToIntPtr(), op);
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_ui_sub"/>
        /// <seealso cref="mpf_sub_ui"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x - y.
        /// mpfr_lib.mpf_sub(z, x, y);
        /// 
        /// // Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// 
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(y, -210)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x - y.
        /// mpfr_lib.mpf_sub(z, x, y)
        /// /// 
        /// ' Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for x, y, and z.
        /// mpfr_lib.mpf_clears(x, y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_sub(mpf_t rop, /*const*/ mpf_t op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_sub(rop.ToIntPtr(), op1.ToIntPtr(), op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_ui_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = x - 200.
        /// mpfr_lib.mpf_sub_ui(z, x, 200U);
        /// 
        /// // Assert that the value of z is -190.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == -190.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = x - 200.
        /// mpfr_lib.mpf_sub_ui(z, x, 200UI)
        /// 
        /// ' Assert that the value of z is -190.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = -190.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_sub_ui(mpf_t rop, /*const*/ mpf_t op1, uint /*unsigned long int*/ op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op1 == null) throw new ArgumentNullException("op1");
            SafeNativeMethods.__mpfrf_sub_ui(rop.ToIntPtr(), op1.ToIntPtr(), op2);
        }

        /// <summary>
        /// Swap <paramref name="rop1"/> and <paramref name="rop2"/> efficiently. 
        /// </summary>
        /// <param name="rop1">The first result float.</param>
        /// <param name="rop2">The second result float.</param>
        /// <remarks>
        /// <para>
        /// Both the values and the precisions of the two variables are swapped.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_set"/>
        /// <seealso cref="mpf_set_ui"/>
        /// <seealso cref="mpf_set_si"/>
        /// <seealso cref="mpf_set_d"/>
        /// <seealso cref="mpf_set_z"/>
        /// <seealso cref="mpf_set_q"/>
        /// <seealso cref="mpf_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Assigning-Floats.html#Assigning-Floats">GNU MPFR - Assigning Floats</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init2(x, 128U);
        /// mpfr_lib.mpf_set_si(x, 10);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init2(y, 128U);
        /// mpfr_lib.mpf_set_si(y, -210);
        /// 
        /// // Swap the values of x and y.
        /// mpfr_lib.mpf_swap(x, y);
        /// 
        /// // Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) == -210.0);
        /// 
        /// // Assert that the value of y is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(y) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clears(x, y, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init2(x, 128UI)
        /// mpfr_lib.mpf_set_si(x, 10)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init2(y, 128UI)
        /// mpfr_lib.mpf_set_si(y, -210)
        /// 
        /// ' Swap the values of x and y.
        /// mpfr_lib.mpf_swap(x, y)
        /// 
        /// ' Assert that the value of x is -210.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(x) = -210.0)
        /// 
        /// ' Assert that the value of y is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(y) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and y.
        /// mpfr_lib.mpf_clears(x, y, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_swap(mpf_t rop1, mpf_t rop2)
        {
            if (rop1 == null) throw new ArgumentNullException("rop1");
            if (rop2 == null) throw new ArgumentNullException("rop2");
            SafeNativeMethods.__mpfrf_swap(rop1.ToIntPtr(), rop2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op"/> rounded to the integer towards zero. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op">The operand float.</param>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_urandomb"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.4.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_d(x, 10.4);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = trunc(x).
        /// mpfr_lib.mpf_trunc(z, x);
        /// 
        /// // Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 10.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.4.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_d(x, 10.4)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = trunc(x).
        /// mpfr_lib.mpf_trunc(z, x)
        /// 
        /// ' Assert that the value of z is 10.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 10.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_trunc(mpf_t rop, /*const*/ mpf_t op)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op == null) throw new ArgumentNullException("op");
            SafeNativeMethods.__mpfrf_trunc(rop.ToIntPtr(), op.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> / <paramref name="op2"/>. 
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <remarks>
        /// <para>
        /// Division is undefined if the divisor is zero, and passing a zero divisor to the divide
        /// functions will make it intentionally divide by zero.
        /// This lets the user handle arithmetic exceptions in division functions in the same manner
        /// as other arithmetic exceptions. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_div_ui"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpf_div_2exp"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number x to 10.
        /// mpf_t x = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(x, 10);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = 210 / x.
        /// mpfr_lib.mpf_ui_div(z, 210U, x);
        /// 
        /// // Assert that the value of z is 21.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 21.0);
        /// 
        /// // Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number x to 10.
        /// Dim x As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(x, 10)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = 210 / x.
        /// mpfr_lib.mpf_ui_div(z, 210UI, x)
        /// 
        /// ' Assert that the value of z is 21.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 21.0)
        /// 
        /// ' Release unmanaged memory allocated for x and z.
        /// mpfr_lib.mpf_clears(x, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_ui_div(mpf_t rop, uint /*unsigned long int*/ op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_ui_div(rop.ToIntPtr(), op1, op2.ToIntPtr());
        }

        /// <summary>
        /// Set <paramref name="rop"/> to <paramref name="op1"/> - <paramref name="op2"/>.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="op1">The first operand.</param>
        /// <param name="op2">The second operand.</param>
        /// <seealso cref="mpf_add"/>
        /// <seealso cref="mpf_sub"/>
        /// <seealso cref="mpf_sub_ui"/>
        /// <seealso cref="mpf_mul"/>
        /// <seealso cref="mpf_div"/>
        /// <seealso cref="mpf_sqrt"/>
        /// <seealso cref="mpf_pow_ui"/>
        /// <seealso cref="mpf_neg"/>
        /// <seealso cref="mpf_abs"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Float-Arithmetic.html#Float-Arithmetic">GNU MPFR - Float Arithmetic</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64U);
        /// 
        /// // Create, initialize, and set a new floating-point number y to -210.
        /// mpf_t y = new mpf_t();
        /// mpfr_lib.mpf_init_set_si(y, -210);
        /// 
        /// // Create and initialize a new floating-point number z.
        /// mpf_t z = new mpf_t();
        /// mpfr_lib.mpf_init(z);
        /// 
        /// // Set z = 10 - y.
        /// mpfr_lib.mpf_ui_sub(z, 10U, y);
        /// 
        /// // Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) == 220.0);
        /// 
        /// // Release unmanaged memory allocated for y, and z.
        /// mpfr_lib.mpf_clears(y, z, null);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Set default precision to 64 bits.
        /// mpfr_lib.mpf_set_default_prec(64UI)
        /// 
        /// ' Create, initialize, and set a new floating-point number y to -210.
        /// Dim y As New mpf_t()
        /// mpfr_lib.mpf_init_set_si(y, -210)
        /// 
        /// ' Create and initialize a new floating-point number z.
        /// Dim z As New mpf_t()
        /// mpfr_lib.mpf_init(z)
        /// 
        /// ' Set z = 10 - y.
        /// mpfr_lib.mpf_ui_sub(z, 10UI, y)
        /// 
        /// ' Assert that the value of z is 220.
        /// Assert.IsTrue(mpfr_lib.mpf_get_d(z) = 220.0)
        /// 
        /// ' Release unmanaged memory allocated for y, and z.
        /// mpfr_lib.mpf_clears(y, z, Nothing)
        /// </code> 
        /// </example>
        public static void mpf_ui_sub(mpf_t rop, uint /*unsigned long int*/ op1, /*const*/ mpf_t op2)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (op2 == null) throw new ArgumentNullException("op2");
            SafeNativeMethods.__mpfrf_ui_sub(rop.ToIntPtr(), op1, op2.ToIntPtr());
        }

        /// <summary>
        /// Generate a uniformly distributed random float in <paramref name="rop"/>, such that 0 &#8804; rop &lt; 1, with <paramref name="nbits"/> significant bits in the mantissa or less if the precision of <paramref name="rop"/> is smaller.
        /// </summary>
        /// <param name="rop">The result float.</param>
        /// <param name="state">The random number generator state.</param>
        /// <param name="nbits">Number of significant bits.</param>
        /// <remarks>
        /// <para>
        /// The variable state must be initialized by calling one of the <c>mpfr_randinit</c> functions
        /// (<a href="https://mpfrlib.org/manual/Random-State-Initialization.html#Random-State-Initialization">GNU MPFR - Random State Initialization</a>) before invoking this function. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpf_ceil"/>
        /// <seealso cref="mpf_floor"/>
        /// <seealso cref="mpf_trunc"/>
        /// <seealso cref="mpf_integer_p"/>
        /// <seealso cref="mpf_fits_ulong_p"/>
        /// <seealso cref="mpf_fits_slong_p"/>
        /// <seealso cref="mpf_fits_uint_p"/>
        /// <seealso cref="mpf_fits_sint_p"/>
        /// <seealso cref="mpf_fits_ushort_p"/>
        /// <seealso cref="mpf_fits_sshort_p"/>
        /// <seealso cref="mpf_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Miscellaneous-Float-Functions.html#Miscellaneous-Float-Functions">GNU MPFR - Miscellaneous Float Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create, initialize, and seed a new random number generator.
        /// mpfr_randstate_t state = new mpfr_randstate_t();
        /// mpfr_lib.mpfr_randinit_mt(state);
        /// mpfr_lib.mpfr_randseed_ui(state, 100000U);
        /// 
        /// // Create, initialize, and set the value of rop to 0.
        /// mpf_t rop = new mpf_t();
        /// mpfr_lib.mpf_init(rop);
        /// 
        /// // Generate a random integer in the range [0, 1) with 50 bits precision.
        /// mpfr_lib.mpf_urandomb(rop, state, 50);
        /// 
        /// // Free all memory occupied by state and rop.
        /// mpfr_lib.mpfr_randclear(state);
        /// mpfr_lib.mpf_clear(rop);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create, initialize, and seed a new random number generator.
        /// Dim state As New mpfr_randstate_t()
        /// mpfr_lib.mpfr_randinit_mt(state)
        /// mpfr_lib.mpfr_randseed_ui(state, 100000UI)
        /// 
        /// ' Create, initialize, and set the value of rop to 0.
        /// Dim rop As New mpf_t()
        /// mpfr_lib.mpf_init(rop)
        /// 
        /// ' Generate a random integer in the range [0, 1) with 50 bits precision.
        /// mpfr_lib.mpf_urandomb(rop, state, 50)
        /// 
        /// ' Free all memory occupied by state and rop.
        /// mpfr_lib.mpfr_randclear(state)
        /// mpfr_lib.mpf_clear(rop)
        /// </code> 
        /// </example>
        public static void mpf_urandomb(mpf_t rop, mpfr_randstate_t state, mp_bitcnt_t nbits)
        {
            if (rop == null) throw new ArgumentNullException("rop");
            if (state == null) throw new ArgumentNullException("state");
            SafeNativeMethods.__mpfrf_urandomb(rop.ToIntPtr(), state.ToIntPtr(), nbits);
        }

        #endregion

        #region "Low level positive-integer (i.e. N) routines."

        /// <summary>
        /// Add {<paramref name="s1p"/>, <paramref name="s1n"/>} and {<paramref name="s2p"/>, <paramref name="s2n"/>}, and write the <paramref name="s1n"/> least significant limbs of the result to <paramref name="rp"/>. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s1n">The number of limbs in <paramref name="s1p"/>.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="s2n">The number of limbs in <paramref name="s2p"/>.</param>
        /// <returns>Return carry, either 0 or 1.</returns>
        /// <remarks>
        /// <para>
        /// This function requires that <paramref name="s1n"/> is greater than or equal to <paramref name="s2n"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp = s1 + s2.
        /// mp_limb_t carry = mpfr_lib.mpn_add(rp, s1p, s1p.Size, s2p, s2p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp = s1 + s2.
        /// Dim carry As mp_limb_t = mpfr_lib.mpn_add(rp, s1p, s1p.Size, s2p, s2p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(carry = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_add(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t s1n, /*const*/ mp_ptr s2p, mp_size_t s2n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_add_x86(rp.ToIntPtr(), s1p.ToIntPtr(), s1n, s2p.ToIntPtr(), s2n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_add_x64(rp.ToIntPtr(), s1p.ToIntPtr(), s1n, s2p.ToIntPtr(), s2n));
        }

        /// <summary>
        /// Add {<paramref name="s1p"/>, <paramref name="n"/>} and <paramref name="s2limb"/>, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="s1p"/>.</param>
        /// <param name="s2limb">The second operand integer.</param>
        /// <returns>Return carry, either 0 or 1.</returns>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp = s1 + 1.
        /// mp_limb_t carry = mpfr_lib.mpn_add_1(rp, s1p, s1p.Size, 1);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp = s1 + 1.
        ///  Dim carry As mp_limb_t = mpfr_lib.mpn_add_1(rp, s1p, s1p.Size, 1)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(carry = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_add_1(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n, mp_limb_t s2limb)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_add_1_x86(rp.ToIntPtr(), s1p.ToIntPtr(), n, (uint)s2limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_add_1_x64(rp.ToIntPtr(), s1p.ToIntPtr(), n, s2limb));
        }

        /// <summary>
        /// Add {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <returns>Return carry, either 0 or 1.</returns>
        /// <remarks>
        /// <para>
        /// This is the lowest-level function for addition.
        /// It is the preferred function for addition, since it is written in assembly for most CPUs.
        /// For addition of a variable to itself (i.e., <paramref name="s1p"/> equals <paramref name="s2p"/>)
        /// use <see cref="mpn_lshift"/> with a count of 1 for optimal speed.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp = s1 + s2.
        /// mp_limb_t carry = mpfr_lib.mpn_add_n(rp, s1p, s2p, rp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp = s1 + s2.
        /// Dim carry As mp_limb_t = mpfr_lib.mpn_add_n(rp, s1p, s2p, rp.Size)
        /// 
        /// ' Assert result of operation.
        /// 
        /// Assert.IsTrue(carry = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_add_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_add_n_x86(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_add_n_x64(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
        }

        /// <summary>
        /// Multiply {<paramref name="s1p"/>, <paramref name="n"/>} and <paramref name="s2limb"/>, and add the <paramref name="n"/> least significant limbs of the product to {<paramref name="rp"/>, <paramref name="n"/>} and write the result to <paramref name="rp"/>. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="s1p"/>.</param>
        /// <param name="s2limb">The second operand integer.</param>
        /// <returns>Return the most significant limb of the product, plus carry-out from the addition.</returns>
        /// <remarks>
        /// <para>
        /// {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>} are allowed
        /// to overlap provided <paramref name="rp"/> &#8804; <paramref name="s1p"/>. 
        /// </para>
        /// <para>
        /// This is a low-level function that is a building block for general multiplication as well as other operations in MPFR.
        /// It is written in assembly for most CPUs. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[] { 0x00000002, 0x00000000 });
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp += s1 * 2.
        /// mp_limb_t carry = mpfr_lib.mpn_addmul_1(rp, s1p, s1p.Size, 2);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 0x02);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger() { &amp;H2, &amp;H0})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp += s1 * 2.
        /// Dim carry As mp_limb_t = mpfr_lib.mpn_addmul_1(rp, s1p, s1p.Size, 2)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(carry = &amp;H2)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_addmul_1(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n, mp_limb_t s2limb)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_addmul_1_x86(rp.ToIntPtr(), s1p.ToIntPtr(), n, (uint)s2limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_addmul_1_x64(rp.ToIntPtr(), s1p.ToIntPtr(), n, s2limb));
        }

        /// <summary>
        /// Compare {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <returns>Return a positive value if s1 &gt; s2, 0 if they are equal, or a negative value if s1 &lt; s2. </returns>
        /// <seealso cref="mpn_perfect_power_p"/>
        /// <seealso cref="mpn_perfect_square_p"/>
        /// <seealso cref="mpn_zero_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// 
        /// // Assert s1p > s2p.
        /// Assert.IsTrue(mpfr_lib.mpn_cmp(s1p, s2p, s1p.Size) > 0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p, s2p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// 
        /// ' Assert s1p > s2p.
        /// Assert.IsTrue(mpfr_lib.mpn_cmp(s1p, s2p, s1p.Size) > 0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p, s2p)
        /// </code> 
        /// </example>
        public static int mpn_cmp(/*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            return SafeNativeMethods.__mpfrn_cmp(s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Test {<paramref name="sp"/>, <paramref name="n"/>} and return 1 if the operand is zero, 0 otherwise.
        /// </summary>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="sp"/>.</param>
        /// <returns>Return 1 if the operand is zero, 0 otherwise.</returns>
        /// <seealso cref="mpn_cmp"/>
        /// <seealso cref="mpn_perfect_power_p"/>
        /// <seealso cref="mpn_perfect_square_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Assert sp == 0.
        /// Assert.IsTrue(mpfr_lib.mpn_zero_p(sp, sp.Size) == 1);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(sp);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Assert sp == 0.
        /// Assert.IsTrue(mpfr_lib.mpn_zero_p(sp, sp.Size) = 1)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(sp)
        /// </code> 
        /// </example>
        public static int mpn_zero_p(/*const*/ mp_ptr sp, mp_size_t n)
        {
            if (sp == null) throw new ArgumentNullException("sp");
            return SafeNativeMethods.__mpfrn_zero_p(sp.ToIntPtr(), n);
        }

        /// <summary>
        /// Divide {<paramref name="sp"/>, <paramref name="n"/>} by <paramref name="d"/>, expecting it to divide exactly, and writing the result to {r<paramref name="rp"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The first operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="sp"/> and <paramref name="rp"/>.</param>
        /// <param name="d">The second operand integer.</param>
        /// <remarks>
        /// <para>
        /// If <paramref name="d"/> doesn’t divide exactly, the value written to {<paramref name="rp"/>, <paramref name="n"/>} is undefined.
        /// The areas at <paramref name="rp"/> and <paramref name="sp"/> have to be identical or completely separate, not partially overlapping.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x55555555, 0x00005555 });
        /// 
        /// // Set rp = sp / 3.
        /// mpfr_lib.mpn_divexact_1(rp, sp, sp.Size, 0x3);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H55555555, &amp;H5555})
        /// 
        /// ' Set rp = sp / 3.
        /// mpfr_lib.mpn_divexact_1(rp, sp, sp.Size, &amp;H3)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static void mpn_divexact_1(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n, mp_limb_t d)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (IntPtr.Size == 4)
                SafeNativeMethods.__mpfrn_divexact_1_x86(rp.ToIntPtr(), sp.ToIntPtr(), n, (uint)d);
            else
                SafeNativeMethods.__mpfrn_divexact_1_x64(rp.ToIntPtr(), sp.ToIntPtr(), n, d);
        }

        /// <summary>
        /// Divide {<paramref name="sp"/>, <paramref name="n"/>} by 3, expecting it to divide exactly, and writing the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="sp"/>.</param>
        /// <returns>If 3 divides exactly, the return value is zero and the result is the quotient. If not, the return value is non-zero and the result won’t be anything useful.</returns>
        /// <remarks>
        /// <para>
        /// <see cref="mpn_divexact_by3c"/> takes an initial carry parameter, which can be the return value from a previous call,
        /// so a large calculation can be done piece by piece from low to high.
        /// <see cref="mpn_divexact_by3"/> is simply a macro calling <see cref="mpn_divexact_by3c"/> with a 0 carry parameter.
        /// </para>
        /// <para>
        /// These routines use a multiply-by-inverse and will be faster than <see cref="mpn_divrem_1"/> on CPUs with
        /// fast multiplication but slow division. 
        /// </para>
        /// <para>
        /// The source a, result q, size n, initial carry i, and return value c satisfy
        /// c * b^n + a - i = 3 * q, where b = 2^<see cref="mp_bits_per_limb"/>.
        /// The return c is always 0, 1 or 2, and the initial carry i must also be 0,
        /// 1 or 2 (these are both borrows really). When c = 0 clearly q = (a - i) / 3.
        /// When c != 0, the remainder (a - i) mod 3 is given by 3 - c, because
        /// b ≡ 1 mod 3 (when <see cref="mp_bits_per_limb"/> is even, which is always so currently). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x55555555, 0x00005555 });
        /// 
        /// // Set rp = sp / 3.
        /// mp_limb_t remainder = mpfr_lib.mpn_divexact_by3(rp, sp, sp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(remainder == 0);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H55555555, &amp;H5555})
        /// 
        /// ' Set rp = sp / 3.
        /// Dim remainder As mp_limb_t = mpfr_lib.mpn_divexact_by3(rp, sp, sp.Size)
        /// 
        /// ' Assert result of operation.
        /// 
        /// Assert.IsTrue(remainder = 0)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_divexact_by3(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divexact_by3_x86(rp.ToIntPtr(), sp.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divexact_by3_x64(rp.ToIntPtr(), sp.ToIntPtr(), n));
        }

        /// <summary>
        /// Divide {<paramref name="sp"/>, <paramref name="n"/>} by 3, expecting it to divide exactly, and writing the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The number of limbs in <paramref name="sp"/>.</param>
        /// <param name="carry">The initial carry.</param>
        /// <returns>If 3 divides exactly, the return value is zero and the result is the quotient. If not, the return value is non-zero and the result won’t be anything useful.</returns>
        /// <remarks>
        /// <para>
        /// <see cref="mpn_divexact_by3c"/> takes an initial carry parameter, which can be the return value from a previous call,
        /// so a large calculation can be done piece by piece from low to high.
        /// <see cref="mpn_divexact_by3"/> is simply a macro calling <see cref="mpn_divexact_by3c"/> with a 0 carry parameter.
        /// </para>
        /// <para>
        /// These routines use a multiply-by-inverse and will be faster than <see cref="mpn_divrem_1"/> on CPUs with
        /// fast multiplication but slow division. 
        /// </para>
        /// <para>
        /// The source a, result q, size n, initial carry i, and return value c satisfy
        /// c * b^n + a - i = 3 * q, where b = 2^<see cref="mp_bits_per_limb"/>.
        /// The return c is always 0, 1 or 2, and the initial carry i must also be 0,
        /// 1 or 2 (these are both borrows really). When c = 0 clearly q = (a - i) / 3.
        /// When c != 0, the remainder (a - i) mod 3 is given by 3 - c, because
        /// b ≡ 1 mod 3 (when <see cref="mp_bits_per_limb"/> is even, which is always so currently). 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xaaaaaaaa, 0x5555aaaa });
        /// 
        /// // Set rp = sp / 3.
        /// mp_limb_t remainder = mpfr_lib.mpn_divexact_by3c(rp, sp, sp.Size, 1);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(remainder == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HaaaaaaaaUI, &amp;H5555aaaa})
        /// 
        /// ' Set rp = sp / 3.
        /// Dim remainder As mp_limb_t = mpfr_lib.mpn_divexact_by3c(rp, sp, sp.Size, 1)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(remainder = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_divexact_by3c(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n, mp_limb_t carry)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divexact_by3c_x86(rp.ToIntPtr(), sp.ToIntPtr(), n, (uint)carry));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divexact_by3c_x64(rp.ToIntPtr(), sp.ToIntPtr(), n, carry));
        }

        /// <summary>
        /// Divide {<paramref name="s2p"/>, <paramref name="s2n"/>} by <paramref name="s3limb"/>, and write the quotient at <paramref name="r1p"/>.
        /// </summary>
        /// <param name="r1p"></param>
        /// <param name="qxn"></param>
        /// <param name="s2p"></param>
        /// <param name="s2n"></param>
        /// <param name="s3limb"></param>
        /// <returns>Return the remainder.</returns>
        /// <remarks>
        /// <para>
        /// The integer quotient is written to {<paramref name="r1p"/> + <paramref name="qxn"/>, <paramref name="s2n"/>}
        /// and in addition <paramref name="qxn"/> fraction limbs are developed and written to {<paramref name="r1p"/>, <paramref name="qxn"/>}.
        /// Either or both <paramref name="s2n"/> and <paramref name="qxn"/> can be zero.
        /// For most usages, <paramref name="qxn"/> will be zero. 
        /// </para>
        /// <para>
        /// <see cref="mpn_divmod_1"/> exists for upward source compatibility and is simply a macro
        /// calling <see cref="mpn_divrem_1"/> with a <paramref name="qxn"/> of 0. 
        /// </para>
        /// <para>
        /// The areas at <paramref name="r1p"/> and <paramref name="s2p"/> have to be identical or
        /// completely separate, not partially overlapping. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr r1p = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x435e50d7, 0x00000d79 });
        /// 
        /// // Set r1p = s2p / 19.
        /// mp_limb_t remainder = mpfr_lib.mpn_divrem_1(r1p, 0, s2p, s2p.Size, 0x13);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(remainder == 10);
        /// Assert.IsTrue(r1p.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(r1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim r1p As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H435e50d7, &amp;Hd79})
        /// 
        /// ' Set r1p = s2p / 19.
        /// Dim remainder As mp_limb_t = mpfr_lib.mpn_divrem_1(r1p, 0, s2p, s2p.Size, &amp;H13)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(remainder = 10)
        /// Assert.IsTrue(r1p.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(r1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_divrem_1(mp_ptr r1p, mp_size_t qxn, /*const*/ mp_ptr s2p, mp_size_t s2n, mp_limb_t s3limb)
        {
            if (r1p == null) throw new ArgumentNullException("r1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divrem_1_x86(r1p.ToIntPtr(), qxn, s2p.ToIntPtr(), s2n, (uint)s3limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divrem_1_x64(r1p.ToIntPtr(), qxn, s2p.ToIntPtr(), s2n, s3limb));
        }

        /// <summary>
        /// Divide {<paramref name="s2p"/>, <paramref name="s2n"/>} by <paramref name="s3limb"/>, and write the quotient at <paramref name="r1p"/>.
        /// </summary>
        /// <param name="r1p"></param>
        /// <param name="s2p"></param>
        /// <param name="s2n"></param>
        /// <param name="s3limb"></param>
        /// <returns>Return the remainder.</returns>
        /// <remarks>
        /// <para>
        /// The integer quotient is written to {<paramref name="r1p"/>, <paramref name="s2n"/>}.
        /// <paramref name="s2n"/> can be zero.
        /// </para>
        /// <para>
        /// <see cref="mpn_divmod_1"/> exists for upward source compatibility and is simply a macro
        /// calling <see cref="mpn_divrem_1"/> with a qxn of 0. 
        /// </para>
        /// <para>
        /// The areas at <paramref name="r1p"/> and <paramref name="s2p"/> have to be identical or
        /// completely separate, not partially overlapping. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr r1p = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x435e50d7, 0x00000d79 });
        /// 
        /// // Set r1p = s2p / 19.
        /// mp_limb_t remainder = mpfr_lib.mpn_divmod_1(r1p, s2p, s2p.Size, 0x13);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(remainder == 10);
        /// Assert.IsTrue(r1p.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(r1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim r1p As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H435e50d7, &amp;Hd79})
        /// 
        /// ' Set r1p = s2p / 19.
        /// Dim remainder As mp_limb_t = mpfr_lib.mpn_divmod_1(r1p, s2p, s2p.Size, &amp;H13)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(remainder = 10)
        /// Assert.IsTrue(r1p.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(r1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_divmod_1(mp_ptr r1p, /*const*/ mp_ptr s2p, mp_size_t s2n, mp_limb_t s3limb)
        {
            if (r1p == null) throw new ArgumentNullException("r1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divrem_1_x86(r1p.ToIntPtr(), 0, s2p.ToIntPtr(), s2n, (uint)s3limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_divrem_1_x64(r1p.ToIntPtr(), 0, s2p.ToIntPtr(), s2n, s3limb));
        }

        ////obsolete
        ////#define mpn_divrem __MPN(divrem)
        ////public static mp_limb_t mpn_divrem(IntPtr /*mp_ptr*/, int /*mp_size_t*/, IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/)
        //{
        //    return SafeNativeMethods.__mpfrn_divrem(IntPtr /*mp_ptr*/, int /*mp_size_t*/, IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/);
        //}

        ////obsolete
        ////#define mpn_divrem_1 __MPN(divrem_1)
        ////public static mp_limb_t mpn_divrem_1(IntPtr /*mp_ptr*/ r1p, int /*mp_size_t*/ qxn, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n, mp_limb_t s3limb)
        //{
        //    return SafeNativeMethods.__mpfrn_divrem_1(IntPtr /*mp_ptr*/ r1p, int /*mp_size_t*/ qxn, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n, mp_limb_t s3limb);
        //}

        ////obsolete
        ////#define mpn_divrem_2 __MPN(divrem_2)
        ////public static mp_limb_t mpn_divrem_2(IntPtr /*mp_ptr*/, int /*mp_size_t*/, IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/)
        //{
        //    return SafeNativeMethods.__mpfrn_divrem_2(IntPtr /*mp_ptr*/, int /*mp_size_t*/, IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/);
        //}

        ////#define mpn_div_qr_1 __MPN(div_qr_1)
        ////public static mp_limb_t mpn_div_qr_1(IntPtr /*mp_ptr*/, mp_limb_t*, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t)
        //{
        //    return SafeNativeMethods.__mpfrn_div_qr_1(IntPtr /*mp_ptr*/, mp_limb_t*, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t);
        //}

        ////#define mpn_div_qr_2 __MPN(div_qr_2)
        ////public static mp_limb_t mpn_div_qr_2(IntPtr /*mp_ptr*/, IntPtr /*mp_ptr*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/)
        //{
        //    return SafeNativeMethods.__mpfrn_div_qr_2(IntPtr /*mp_ptr*/, IntPtr /*mp_ptr*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/);
        //}

        /// <summary>
        /// Set {<paramref name="rp"/>, retval} to the greatest common divisor of {<paramref name="xp"/>, <paramref name="xn"/>} and {<paramref name="yp"/>, <paramref name="yn"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="xp">The first operand integer.</param>
        /// <param name="xn">The number of limbs of <paramref name="xp"/>.</param>
        /// <param name="yp">The second operand integer.</param>
        /// <param name="yn">The number of limbs of <paramref name="yp"/>.</param>
        /// <returns>The result can be up to <paramref name="yn"/> limbs, the return value is the actual number produced; i.e. the number of limbs of <paramref name="rp"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both source operands are destroyed. 
        /// </para>
        /// <para>
        /// It is required that <paramref name="xn"/> &#8805; <paramref name="yn"/> &gt; 0, and the most significant limb
        /// of {<paramref name="yp"/>, <paramref name="yn"/>} must be non-zero.
        /// No overlap is permitted between {<paramref name="xp"/>, <paramref name="xn"/>} and {<paramref name="yp"/>, <paramref name="yn"/>}. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_gcd_1"/>
        /// <seealso cref="mpn_gcdext"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr xp = new mp_ptr(new uint[] { 0x964619c7, 0x00000002 });
        /// mp_ptr yp = new mp_ptr(new uint[] { 0xc2d24d55, 0x00000007 });
        /// mp_ptr rp = new mp_ptr(yp.Size);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x964619c7, 0x00000002 });
        /// 
        /// // Set rp = gcd(xp, yp).
        /// mp_size_t size = mpfr_lib.mpn_gcd(rp, xp, xp.Size, yp, yp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(size == result.Size);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, xp, yp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim xp As New mp_ptr(New UInteger() { &amp;H964619c7UI, &amp;H2})
        /// Dim yp As New mp_ptr(New UInteger() { &amp;Hc2d24d55UI, &amp;H7})
        /// Dim rp As New mp_ptr(yp.Size)
        /// Dim result As New mp_ptr(New UInteger() { &amp;H964619c7UI, &amp;H2})
        /// 
        /// ' Set rp = gcd(xp, yp).
        /// Dim size As mp_size_t = mpfr_lib.mpn_gcd(rp, xp, xp.Size, yp, yp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(size = result.Size)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, xp, yp, result)
        /// </code> 
        /// </example>
        public static mp_size_t mpn_gcd(mp_ptr rp, mp_ptr xp, mp_size_t xn, mp_ptr yp, mp_size_t yn)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (xp == null) throw new ArgumentNullException("xp");
            if (yp == null) throw new ArgumentNullException("yp");
            return new mp_size_t(SafeNativeMethods.__mpfrn_gcd(rp.ToIntPtr(), xp.ToIntPtr(), xn, yp.ToIntPtr(), yn));
        }

        /// <summary>
        /// Return the greatest common divisor of {<paramref name="xp"/>, <paramref name="xn"/>} and <paramref name="ylimb"/>.
        /// </summary>
        /// <param name="xp">The first operand integer.</param>
        /// <param name="xn">The number of limbs of <paramref name="xp"/>.</param>
        /// <param name="ylimb">The second operand integer.</param>
        /// <returns>The greatest common divisor of {<paramref name="xp"/>, <paramref name="xn"/>} and <paramref name="ylimb"/>.</returns>
        /// <remarks>
        /// <para>
        /// Both operands must be non-zero. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_gcd"/>
        /// <seealso cref="mpn_gcdext"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr xp = new mp_ptr(new uint[] { 0x00000000, 0x00000001 });
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_gcd_1(xp, xp.Size, 1073741824) == 1073741824);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(xp);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim xp As New mp_ptr(New UInteger() { &amp;H0, &amp;H1})
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_gcd_1(xp, xp.Size, 1073741824) = 1073741824)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(xp)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_gcd_1(/*const*/ mp_ptr xp, mp_size_t xn, mp_limb_t ylimb)
        {
            if (xp == null) throw new ArgumentNullException("xp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_gcd_1_x86(xp.ToIntPtr(), xn, (uint)ylimb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_gcd_1_x64(xp.ToIntPtr(), xn, ylimb));
        }

        ////#define mpn_gcdext_1 __MPN(gcdext_1)
        ////public static mp_limb_t mpn_gcdext_1(mp_limb_signed_t*, mp_limb_signed_t*, mp_limb_t, mp_limb_t)
        //{
        //    return SafeNativeMethods.__mpfrn_gcdext_1(mp_limb_signed_t*, mp_limb_signed_t*, mp_limb_t, mp_limb_t);
        //}

        /// <summary>
        /// Compute the greatest common divisor G of U and V. Compute a cofactor S such that G = US + VT.
        /// </summary>
        /// <param name="gp">The fisrt result operand.</param>
        /// <param name="sp">The second result operand.</param>
        /// <param name="sn">Pointer to the number of limbs of <paramref name="sp"/>.</param>
        /// <param name="up">The first operand integer.</param>
        /// <param name="un">The number of limbs of <paramref name="up"/>.</param>
        /// <param name="vp">The second operand integer.</param>
        /// <param name="vn">The number of limbs of <paramref name="vp"/>.</param>
        /// <returns>The number of limbs of <paramref name="gp"/>.</returns>
        /// <remarks>
        /// <para>
        /// Let U be defined by {<paramref name="up"/>, <paramref name="un"/>}
        /// and let V be defined by {<paramref name="vp"/>, <paramref name="vn"/>}.
        /// </para>
        /// <para>
        /// The second cofactor T is not computed but can easily be obtained from (G - U * S) / V (the division will be exact).
        /// It is required that <paramref name="un"/> &#8805; <paramref name="vn"/> &gt; 0, 
        /// and the most significant limb of {<paramref name="vp"/>, <paramref name="vn"/>} must be non-zero. 
        /// </para>
        /// <para>
        /// Store G at <paramref name="gp"/> and let the return value define its limb count.
        /// Store S at <paramref name="sp"/> and let | <paramref name="sn"/>.Value | define its limb count.
        /// S can be negative; when this happens <paramref name="sn"/>.Value will be negative.
        /// The area at <paramref name="gp"/> should have room for <paramref name="vn"/> limbs
        /// and the area at <paramref name="sp"/> should have room for <paramref name="vn"/> + 1 limbs. 
        /// </para>
        /// <para>
        /// Both source operands are destroyed. 
        /// </para>
        /// <para>
        /// Compatibility notes: MPFR 4.3.0 and 4.3.1 defined S less strictly.
        /// Earlier as well as later MPFR releases define S as described here.
        /// MPFR releases before MPFR 4.3.0 required additional space for both input and output areas.
        /// More precisely, the areas {<paramref name="up"/>, <paramref name="un"/> + 1} and
        /// {<paramref name="vp"/>, <paramref name="vn"/> + 1} were destroyed (i.e. the operands
        /// plus an extra limb past the end of each), and the areas pointed to by <paramref name="gp"/>
        /// and <paramref name="sp"/> should each have room for <paramref name="un"/> + 1 limbs.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_gcd"/>
        /// <seealso cref="mpn_gcd_1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr up = new mp_ptr(new uint[] { 0x40000000, 0x00000000 });
        /// mp_ptr vp = new mp_ptr(new uint[] { 0x00000000, 0x00000001 });
        /// mp_ptr gp = new mp_ptr(new uint[vp.Size * (IntPtr.Size / 4)]);
        /// mp_ptr sp = new mp_ptr(new uint[(vp.Size + 1) * (IntPtr.Size / 4)]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x40000000, 0x00000000 });
        /// mp_ptr cofactor = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0x00000000 });
        /// 
        /// // Set gp = gcd(up, vp).
        /// ptr&lt;mp_size_t&gt; sn = new ptr&lt;mp_size_t&gt;(0);
        /// mp_size_t size = mpfr_lib.mpn_gcdext(gp, sp, sn, up, up.Size, vp, vp.Size);
        /// 
        /// // Assert result.
        /// Assert.IsTrue(size == 1);
        /// Assert.IsTrue(gp.SequenceEqual(result));
        /// Assert.IsTrue(sn.Value == 1);
        /// Assert.IsTrue(sp.SequenceEqual(cofactor));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(gp, up, vp, sp, result, cofactor);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim up As New mp_ptr(New UInteger() { &amp;H40000000, &amp;H0})
        /// Dim vp As New mp_ptr(New UInteger() { &amp;H0, &amp;H1})
        /// Dim gp As New mp_ptr(New UInteger(vp.Size* (IntPtr.Size / 4) - 1) {})
        /// Dim sp As New mp_ptr(New UInteger((vp.Size + 1) * (IntPtr.Size / 4) - 1) {})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H40000000, &amp;H0})
        /// Dim cofactor As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;H0})
        /// 
        /// ' Set gp = gcd(up, vp).
        /// Dim sn As New ptr(Of mp_size_t)(0)
        /// Dim size As mp_size_t = mpfr_lib.mpn_gcdext(gp, sp, sn, up, up.Size, vp, vp.Size)
        /// 
        /// ' Assert result.
        /// Assert.IsTrue(size = 1)
        /// Assert.IsTrue(gp.SequenceEqual(result))
        /// Assert.IsTrue(sn.Value = 1)
        /// Assert.IsTrue(sp.SequenceEqual(cofactor))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(gp, up, vp, sp, result, cofactor)
        /// </code> 
        /// </example>
        public static mp_size_t mpn_gcdext(mp_ptr gp, mp_ptr sp, ptr<mp_size_t> sn, mp_ptr up, mp_size_t un, mp_ptr vp, mp_size_t vn)
        {
            if (gp == null) throw new ArgumentNullException("gp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (up == null) throw new ArgumentNullException("up");
            if (vp == null) throw new ArgumentNullException("vp");
            return new mp_size_t(SafeNativeMethods.__mpfrn_gcdext(gp.ToIntPtr(), sp.ToIntPtr(), ref sn.Value._value, up.ToIntPtr(), un, vp.ToIntPtr(), vn));
        }

        /// <summary>
        /// Convert {<paramref name="s1p"/>, <paramref name="s1n"/>} to a raw unsigned char array at <paramref name="str"/> in base <paramref name="base"/>, and return the number of characters produced.
        /// </summary>
        /// <param name="str">The result string.</param>
        /// <param name="base">The base.</param>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <returns>The number of characters produced at <paramref name="str"/>.</returns>
        /// <remarks>
        /// <para>
        /// There may be leading zeros in the string.
        /// The string is not in ASCII; to convert it to printable format, add the ASCII codes for "0" or "A",
        /// depending on the base and range. <paramref name="base"/> can vary from 2 to 256. 
        /// </para>
        /// <para>
        /// The most significant limb of the input {<paramref name="s1p"/>, <paramref name="s1n"/>} must be non-zero.
        /// The input {<paramref name="s1p"/>, <paramref name="s1n"/>} is clobbered, except when base is a power of 2,
        /// in which case it’s unchanged. 
        /// </para>
        /// <para>
        /// The area at <paramref name="str"/> has to have space for the largest possible number
        /// represented by a <paramref name="s1n"/> long limb array, plus one extra character. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_set_str"/>
        /// <seealso cref="mpn_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
        /// char_ptr str = new char_ptr("xxxxxxxxxxxxxxxxx");
        /// 
        /// // Convert s1p to hex string.
        /// size_t count = mpfr_lib.mpn_get_str(str, 16, s1p, s1p.Size);
        /// 
        /// // Copy out str to bytes.
        /// byte[] s = new byte[count];
        /// Marshal.Copy(str.ToIntPtr(), s, 0, (int)count);
        /// 
        /// // Assert the non-ASCII, hex representation of s1p.
        /// Assert.IsTrue(s.SequenceEqual(new byte[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 }));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// mpfr_lib.free(str);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// Dim str As New char_ptr("xxxxxxxxxxxxxxxxx")
        /// 
        /// ' Convert s1p to hex string.
        /// Dim count As size_t = mpfr_lib.mpn_get_str(str, 16, s1p, s1p.Size)
        /// 
        /// ' Copy out str to bytes.
        /// Dim s As Byte() = New Byte(count - 1) { }
        /// Marshal.Copy(str.ToIntPtr(), s, 0, CInt(count))
        /// 
        /// ' Assert the non-ASCII, hex representation of s1p.
        /// Assert.IsTrue(s.SequenceEqual(New Byte() { 1, 0, 0, 0, 0, 0, 0, 0, 1}))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// mpfr_lib.free(str)
        /// </code> 
        /// </example>
        public static size_t mpn_get_str(/*unsigned*/ char_ptr str, int @base, mp_ptr s1p, mp_size_t s1n)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrn_get_str_x86(str.ToIntPtr(), @base, s1p.ToIntPtr(), s1n));
            else
                return new size_t(SafeNativeMethods.__mpfrn_get_str_x64(str.ToIntPtr(), @base, s1p.ToIntPtr(), s1n));
        }

        /// <summary>
        /// Compute the hamming distance between {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, which is the number of bit positions where the two operands have different bit values. 
        /// </summary>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <returns>The hamming distance between {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>.</returns>
        /// <seealso cref="mpn_lshift"/>
        /// <seealso cref="mpn_popcount"/>
        /// <seealso cref="mpn_rshift"/>
        /// <seealso cref="mpn_scan0"/>
        /// <seealso cref="mpn_scan1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0xffffffff });
        /// 
        /// // Assert hamming distance.
        /// Assert.IsTrue(mpfr_lib.mpn_hamdist(s1p, s2p, s1p.Size) == 31);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p, s2p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;HffffffffUI})
        /// 
        /// ' Assert hamming distance.
        /// Assert.IsTrue(mpfr_lib.mpn_hamdist(s1p, s2p, s1p.Size) = 31)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p, s2p)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpn_hamdist(/*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrn_hamdist(s1p.ToIntPtr(), s2p.ToIntPtr(), n));
        }

        /// <summary>
        /// Shift {<paramref name="sp"/>, <paramref name="n"/>} left by <paramref name="count"/> bits, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="sp"/>.</param>
        /// <param name="count">The number of bits ot shift.</param>
        /// <returns>The bits shifted out at the left are returned in the least significant count bits of the return value (the rest of the return value is zero).</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="count"/> must be in the range 1 to <see cref="mp_bits_per_limb"/> - 1.
        /// The regions {<paramref name="sp"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>} may overlap,
        /// provided <paramref name="rp"/> &#8805; <paramref name="sp"/>. 
        /// </para>
        /// <para>
        /// This function is written in assembly for most CPUs. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_hamdist"/>
        /// <seealso cref="mpn_popcount"/>
        /// <seealso cref="mpn_rshift"/>
        /// <seealso cref="mpn_scan0"/>
        /// <seealso cref="mpn_scan1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffc, 0xffffffff });
        /// 
        /// // Set rp = sp &lt;&lt; 1.
        /// mp_limb_t bits = mpfr_lib.mpn_lshift(rp, sp, sp.Size, 1);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(bits == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffcUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = sp &lt;&lt; 1.
        /// Dim bits As mp_limb_t = mpfr_lib.mpn_lshift(rp, sp, sp.Size, 1)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(bits = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_lshift(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n, uint count)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_lshift_x86(rp.ToIntPtr(), sp.ToIntPtr(), n, count));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_lshift_x64(rp.ToIntPtr(), sp.ToIntPtr(), n, count));
        }

        /// <summary>
        /// Divide {<paramref name="s1p"/>, <paramref name="s1n"/>} by <paramref name="s2limb"/>, and return the remainder. 
        /// </summary>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <param name="s2limb">The second operand integer.</param>
        /// <returns>The remainder.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="s1n"/> can be zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xfffffffe, 0x0000ffff });
        /// 
        /// // Assert s1p mod 3 is 2.
        /// Assert.IsTrue(mpfr_lib.mpn_mod_1(s1p, s1p.Size, 3) == 2);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;Hffff})
        /// 
        /// ' Assert s1p mod 3 is 2.
        /// Assert.IsTrue(mpfr_lib.mpn_mod_1(s1p, s1p.Size, 3) = 2)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_mod_1(/*const*/ mp_ptr s1p, mp_size_t s1n, mp_limb_t s2limb)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_mod_1_x86(s1p.ToIntPtr(), s1n, (uint)s2limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_mod_1_x64(s1p.ToIntPtr(), s1n, s2limb));
        }

        /// <summary>
        /// Multiply {<paramref name="s1p"/>, <paramref name="s1n"/>} and {<paramref name="s2p"/>, <paramref name="s2n"/>}, and write the (<paramref name="s1n"/> + <paramref name="s2n"/>)-limb result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <param name="s2p">The first operand integer.</param>
        /// <param name="s2n">The number of limbs of <paramref name="s2p"/>.</param>
        /// <returns>Return the most significant limb of the result.</returns>
        /// <remarks>
        /// <para>
        /// The destination has to have space for <paramref name="s1n"/> + <paramref name="s2n"/> limbs,
        /// even if the product’s most significant limb is zero.
        /// No overlap is permitted between the destination and either source.
        /// </para>
        /// <para>
        /// This function requires that <paramref name="s1n"/> is greater than or equal to <paramref name="s2n"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000002 });
        /// mp_ptr rp = new mp_ptr(new uint[3]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff, 0x00000001 });
        /// 
        /// // Set rp = s1 * s2.
        /// mpfr_lib.mpn_mul(rp, s1p, s1p.Size, s2p, s2p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H2})
        /// Dim rp As New mp_ptr(New UInteger(2) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI, &amp;H1})
        /// 
        /// ' Set rp = s1 * s2.
        /// mpfr_lib.mpn_mul(rp, s1p, s1p.Size, s2p, s2p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_mul(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t s1n, /*const*/ mp_ptr s2p, mp_size_t s2n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_mul_x86(rp.ToIntPtr(), s1p.ToIntPtr(), s1n, s2p.ToIntPtr(), s2n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_mul_x64(rp.ToIntPtr(), s1p.ToIntPtr(), s1n, s2p.ToIntPtr(), s2n));
        }

        /// <summary>
        /// Multiply {<paramref name="s1p"/>, <paramref name="n"/>} by <paramref name="s2limb"/>, and write the <paramref name="n"/> least significant limbs of the product to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <param name="s2limb">The second operand integer.</param>
        /// <returns>Return the most significant limb of the product.</returns>
        /// <remarks>
        /// <para>
        /// {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>} 
        /// are allowed to overlap provided <paramref name="rp"/> &#8804; <paramref name="s1p"/>.
        /// </para>
        /// <para>
        /// This is a low-level function that is a building block for general multiplication as well as 
        /// other operations in MPFR. It is written in assembly for most CPUs.
        /// </para>
        /// <para>
        /// Don’t call this function if <paramref name="s2limb"/> is a power of 2;
        /// use <see cref="mpn_lshift"/> with a count equal to the logarithm of
        /// <paramref name="s2limb"/> instead, for optimal speed. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// 
        /// // Set rp = s1 * 2.
        /// mp_limb_t carry = mpfr_lib.mpn_mul_1(rp, s1p, s1p.Size, 2);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 * 2.
        /// Dim carry As mp_limb_t = mpfr_lib.mpn_mul_1(rp, s1p, s1p.Size, 2)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(carry = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_mul_1(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n, mp_limb_t s2limb)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_mul_1_x86(rp.ToIntPtr(), s1p.ToIntPtr(), n, (uint)s2limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_mul_1_x64(rp.ToIntPtr(), s1p.ToIntPtr(), n, s2limb));
        }

        /// <summary>
        /// Multiply {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the (2 * <paramref name="n"/>)-limb result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <remarks>
        /// <para>
        /// The destination has to have space for 2 * <paramref name="n"/> limbs, even if the product’s
        /// most significant limb is zero. No overlap is permitted between the destination and either source. 
        /// </para>
        /// <para>
        /// If the two input operands are the same, use <see cref="mpn_sqr"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000002, 0x00000000 });
        /// mp_ptr rp = new mp_ptr(new uint[4]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff, 0x00000001, 0x00000000 });
        /// 
        /// // Set rp = s1 * s2.
        /// mpfr_lib.mpn_mul_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H2, &amp;H0})
        /// Dim rp As New mp_ptr(New UInteger(3) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI, &amp;H1, &amp;H0})
        /// 
        /// ' Set rp = s1 * s2.
        /// mpfr_lib.mpn_mul_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_mul_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_mul_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Compute the square of {<paramref name="s1p"/>, <paramref name="n"/>} and write the (2 * <paramref name="n"/>)-limb result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <remarks>
        /// <para>
        /// The destination has to have space for 2 * <paramref name="n"/> limbs, even if the result’s
        /// most significant limb is zero. No overlap is permitted between the destination and the source. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[4]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0xfffffffe, 0xffffffff });
        /// 
        /// // Set rp = s1^2.
        /// mpfr_lib.mpn_sqr(rp, s1p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(3) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;HfffffffeUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1^2.
        /// mpfr_lib.mpn_sqr(rp, s1p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result)
        /// </code> 
        /// </example>
        public static void mpn_sqr(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            SafeNativeMethods.__mpfrn_sqr(rp.ToIntPtr(), s1p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the negation of {<paramref name="sp"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="sp"/> and <paramref name="rp"/>.</param>
        /// <returns>Return borrow, either 0 or 1.</returns>
        /// <remarks>
        /// <para>
        /// This is equivalent to calling <see cref="mpn_sub_n"/> with a <paramref name="n"/>-limb
        /// zero minuend and passing {<paramref name="sp"/>, <paramref name="n"/>} as subtrahend.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x0000001, 0x00000000 });
        /// 
        /// // Set rp = -sp.
        /// mp_limb_t borrow = mpfr_lib.mpn_neg(rp, sp, sp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// 
        /// ' Set rp = -sp.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_neg(rp, sp, sp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_neg(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_neg_x86(rp.ToIntPtr(), sp.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_neg_x64(rp.ToIntPtr(), sp.ToIntPtr(), n));
        }

        /// <summary>
        /// Perform the bitwise complement of {<paramref name="sp"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The numbe rof limbs of <paramref name="rp>"/> and <paramref name="sp"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x0f0f0f0f, 0x0f0f0f0f });
        /// 
        /// // Set rp = not(sp).
        /// mpfr_lib.mpn_com(rp, sp, sp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;Hf0f0f0f, &amp;Hf0f0f0f})
        /// 
        /// ' Set rp = not(sp).
        /// mpfr_lib.mpn_com(rp, sp, sp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static void mpn_com(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            SafeNativeMethods.__mpfrn_com(rp.ToIntPtr(), sp.ToIntPtr(), n);
        }

        /// <summary>
        /// Return non-zero iff {<paramref name="s1p"/>, <paramref name="n"/>} is a perfect square.
        /// </summary>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="n">The numbe rof limbs of <paramref name="s1p"/>.</param>
        /// <returns>Non-zero iff {<paramref name="s1p"/>, <paramref name="n"/>} is a perfect square.</returns>
        /// <remarks>
        /// <para>
        /// The most significant limb of the input {<paramref name="s1p"/>, <paramref name="n"/>} must be non-zero.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cmp"/>
        /// <seealso cref="mpn_perfect_power_p"/>
        /// <seealso cref="mpn_zero_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// 
        /// // Assert s1p is not a perfect square.
        /// Assert.IsTrue(mpfr_lib.mpn_perfect_square_p(s1p, s1p.Size) == 0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// 
        /// ' Assert s1p is not a perfect square.
        /// Assert.IsTrue(mpfr_lib.mpn_perfect_square_p(s1p, s1p.Size) = 0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// </code> 
        /// </example>
        public static int mpn_perfect_square_p(/*const*/ mp_ptr s1p, mp_size_t n)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            return SafeNativeMethods.__mpfrn_perfect_square_p(s1p.ToIntPtr(), n);
        }

        /// <summary>
        /// Return non-zero iff {<paramref name="sp"/>, <paramref name="n"/>} is a perfect power.
        /// </summary>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The numbe rof limbs of <paramref name="sp"/>.</param>
        /// <returns>Non-zero iff {<paramref name="sp"/>, <paramref name="n"/>} is a perfect power.</returns>
        /// <seealso cref="mpn_cmp"/>
        /// <seealso cref="mpn_perfect_square_p"/>
        /// <seealso cref="mpn_zero_p"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xd4a51000, 0x000000e8 });
        /// 
        /// // Assert s1p is a perfect power.
        /// Assert.IsTrue(mpfr_lib.mpn_perfect_power_p(s1p, s1p.Size) != 0);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;Hd4a51000UI, &amp;He8})
        /// 
        /// ' Assert s1p is a perfect power.
        /// Assert.IsTrue(mpfr_lib.mpn_perfect_power_p(s1p, s1p.Size) &lt;&gt; 0)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// </code> 
        /// </example>
        public static int mpn_perfect_power_p(/*const*/ mp_ptr sp, mp_size_t n)
        {
            if (sp == null) throw new ArgumentNullException("sp");
            return SafeNativeMethods.__mpfrn_perfect_power_p(sp.ToIntPtr(), n);
        }

        /// <summary>
        /// Count the number of set bits in {<paramref name="s1p"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <returns>The number of set bits in {<paramref name="s1p"/>, <paramref name="n"/>}.</returns>
        /// <seealso cref="mpn_hamdist"/>
        /// <seealso cref="mpn_lshift"/>
        /// <seealso cref="mpn_rshift"/>
        /// <seealso cref="mpn_scan0"/>
        /// <seealso cref="mpn_scan1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0x0000001, 0x00000001 });
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_popcount(s1p, s1p.Size) == 2);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_popcount(s1p, s1p.Size) = 2)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpn_popcount(/*const*/ mp_ptr s1p, mp_size_t n)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrn_popcount(s1p.ToIntPtr(), n));
        }

        ////#define mpn_pow_1 __MPN(pow_1)
        ////public static int /*mp_size_t*/ mpn_pow_1(IntPtr /*mp_ptr*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t, IntPtr /*mp_ptr*/)
        //{
        //    return SafeNativeMethods.__mpfrn_pow_1(IntPtr /*mp_ptr*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t, IntPtr /*mp_ptr*/);
        //}

        /////* undocumented now, but retained here for upward compatibility */
        ////#define mpn_preinv_mod_1 __MPN(preinv_mod_1)
        ////public static mp_limb_t mpn_preinv_mod_1(/*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t, mp_limb_t)
        //{
        //    return SafeNativeMethods.__mpfrn_preinv_mod_1(/*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t, mp_limb_t);
        //}

        /// <summary>
        /// Generate a random number of length <paramref name="r1n"/> and store it at <paramref name="r1p"/>.
        /// </summary>
        /// <param name="r1p">The result integer.</param>
        /// <param name="r1n">The number of limbs of <paramref name="r1p"/>.</param>
        /// <remarks>
        /// <para>
        /// The most significant limb is always non-zero.
        /// <see cref="mpn_random"/> generates uniformly distributed limb data,
        /// <see cref="mpn_random2"/> generates long strings of zeros and ones in the binary representation. 
        /// </para>
        /// <para>
        /// <see cref="mpn_random2"/> is intended for testing the correctness of the <c>mpn</c> routines. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_random2"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr r1p = new mp_ptr(new uint[2]);
        /// 
        /// // Generate random number.
        /// mpfr_lib.mpn_random(r1p, mpfr_lib.mp_bytes_per_limb == 4 ? 2 : 1);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(r1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim r1p As New mp_ptr(New UInteger(1) { })
        /// 
        /// ' Generate random number.
        /// mpfr_lib.mpn_random(r1p, If(mpfr_lib.mp_bytes_per_limb = 4, 2, 1))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(r1p)
        /// </code> 
        /// </example>
        public static void mpn_random(mp_ptr r1p, mp_size_t r1n)
        {
            if (r1p == null) throw new ArgumentNullException("r1p");
            SafeNativeMethods.__mpfrn_random(r1p.ToIntPtr(), r1n);
        }

        /// <summary>
        /// Generate a random number of length <paramref name="r1n"/> and store it at <paramref name="r1p"/>.
        /// </summary>
        /// <param name="r1p">The result integer.</param>
        /// <param name="r1n">The number of limbs of <paramref name="r1p"/>.</param>
        /// <remarks>
        /// <para>
        /// The most significant limb is always non-zero.
        /// <see cref="mpn_random"/> generates uniformly distributed limb data,
        /// <see cref="mpn_random2"/> generates long strings of zeros and ones in the binary representation. 
        /// </para>
        /// <para>
        /// <see cref="mpn_random2"/> is intended for testing the correctness of the <c>mpn</c> routines. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_random"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr r1p = new mp_ptr(new uint[2]);
        /// 
        /// // Generate random number.
        /// mpfr_lib.mpn_random2(r1p, mpfr_lib.mp_bytes_per_limb == 4 ? 2 : 1);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(r1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim r1p As New mp_ptr(New UInteger(1) { })
        /// 
        /// ' Generate random number.
        /// mpfr_lib.mpn_random2(r1p, If(mpfr_lib.mp_bytes_per_limb = 4, 2, 1))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(r1p)
        /// </code> 
        /// </example>
        public static void mpn_random2(mp_ptr r1p, mp_size_t r1n)
        {
            if (r1p == null) throw new ArgumentNullException("r1p");
            SafeNativeMethods.__mpfrn_random2(r1p.ToIntPtr(), r1n);
        }

        /// <summary>
        /// Shift {<paramref name="sp"/>, <paramref name="n"/>} right by <paramref name="count"/> bits, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="sp">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="sp"/> and <paramref name="rp"/>.</param>
        /// <param name="count"></param>
        /// <returns>The bits shifted out at the right are returned in the most significant <paramref name="count"/> bits of the return value (the rest of the return value is zero).</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="count"/> must be in the range 1 to <see cref="mp_bits_per_limb"/> - 1.
        /// The regions {<paramref name="sp"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>}
        /// may overlap, provided <paramref name="rp"/> &#8804; <paramref name="sp"/>. 
        /// </para>
        /// <para>
        /// This function is written in assembly for most CPUs. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_hamdist"/>
        /// <seealso cref="mpn_lshift"/>
        /// <seealso cref="mpn_popcount"/>
        /// <seealso cref="mpn_scan0"/>
        /// <seealso cref="mpn_scan1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xffffffff, 0x7fffffff });
        /// 
        /// // Set rp = sp &gt;&gt; 1.
        /// mp_limb_t bits = mpfr_lib.mpn_rshift(rp, sp, sp.Size, 1);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(bits == (mpfr_lib.mp_bytes_per_limb == 4 ? 0x80000000 : 0x8000000000000000));
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;H7fffffff})
        /// 
        /// ' Set rp = sp &gt;&gt; 1.
        /// Dim bits As mp_limb_t = mpfr_lib.mpn_rshift(rp, sp, sp.Size, 1)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(bits = (If(mpfr_lib.mp_bytes_per_limb = 4, &amp;H80000000UI, &amp;H8000000000000000UL)))
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_rshift(mp_ptr rp, /*const*/ mp_ptr sp, mp_size_t n, uint count)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (sp == null) throw new ArgumentNullException("sp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_rshift_x86(rp.ToIntPtr(), sp.ToIntPtr(), n, count));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_rshift_x64(rp.ToIntPtr(), sp.ToIntPtr(), n, count));
        }

        /// <summary>
        /// Scan <paramref name="s1p"/> from bit position <paramref name="bit"/> for the next clear bit.
        /// </summary>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="bit">The index of the starting bit.</param>
        /// <returns>The index of the next clear bit.</returns>
        /// <remarks>
        /// <para>
        /// It is required that there be a clear bit within the area at <paramref name="s1p"/>
        /// at or beyond bit position <paramref name="bit"/>, so that the function has something to return. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_hamdist"/>
        /// <seealso cref="mpn_lshift"/>
        /// <seealso cref="mpn_popcount"/>
        /// <seealso cref="mpn_rshift"/>
        /// <seealso cref="mpn_scan1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0x0000001, 0x00000001 });
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_scan0(s1p, 0) == 1);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_scan0(s1p, 0) = 1)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpn_scan0(/*const*/ mp_ptr s1p, mp_bitcnt_t bit)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrn_scan0(s1p.ToIntPtr(), bit));
        }

        /// <summary>
        /// Scan <paramref name="s1p"/> from bit position <paramref name="bit"/> for the next set bit.
        /// </summary>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="bit">The index of the starting bit.</param>
        /// <returns>The index of the next set bit.</returns>
        /// <remarks>
        /// <para>
        /// It is required that there be a set bit within the area at <paramref name="s1p"/>
        /// at or beyond bit position <paramref name="bit"/>, so that the function has something to return. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_hamdist"/>
        /// <seealso cref="mpn_lshift"/>
        /// <seealso cref="mpn_popcount"/>
        /// <seealso cref="mpn_rshift"/>
        /// <seealso cref="mpn_scan0"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0x0000001, 0x00000001 });
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_scan1(s1p, 1) == 32);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(s1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(mpfr_lib.mpn_scan1(s1p, 1) = 32)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(s1p)
        /// </code> 
        /// </example>
        public static mp_bitcnt_t mpn_scan1(/*const*/ mp_ptr s1p, mp_bitcnt_t bit)
        {
            if (s1p == null) throw new ArgumentNullException("s1p");
            return new mp_bitcnt_t(SafeNativeMethods.__mpfrn_scan1(s1p.ToIntPtr(), bit));
        }

        /// <summary>
        /// Convert bytes {<paramref name="str"/>, <paramref name="strsize"/>} in the given <paramref name="base"/> to limbs at <paramref name="rp"/>. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="str">The operand string.</param>
        /// <param name="strsize">The length of <paramref name="str"/>.</param>
        /// <param name="base"></param>
        /// <returns>The number of limbs of <paramref name="rp"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="str"/>[0] is the most significant input byte and
        /// <paramref name="str"/>[<paramref name="strsize"/> - 1] is the least significant input byte.
        /// Each byte should be a value in the range 0 to <paramref name="base"/> - 1,
        /// not an ASCII character. base can vary from 2 to 256.
        /// </para>
        /// <para>
        /// The converted value is {<paramref name="rp"/>, rn} where rn is the return value.
        /// If the most significant input byte <paramref name="str"/>[0] is non-zero,
        /// then <paramref name="rp"/>[rn - 1] will be non-zero,
        /// else <paramref name="rp"/>[rn - 1] and some number of subsequent limbs may be zero. 
        /// </para>
        /// <para>
        /// The area at <paramref name="rp"/> has to have space for the largest possible number with
        /// <paramref name="strsize"/> digits in the chosen <paramref name="base"/>, plus one extra limb. 
        /// </para>
        /// <para>
        /// The input must have at least one byte, and no overlap is permitted
        /// between {<paramref name="str"/>, <paramref name="strsize"/>} and the result at <paramref name="rp"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_get_str"/>
        /// <seealso cref="mpn_sizeinbase"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands.
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// byte[] s = new byte[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 };
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
        /// char_ptr str = new char_ptr("xxxxxxxxxxxxxxxxx");
        /// Marshal.Copy(s, 0, str.ToIntPtr(), 9);
        /// 
        /// // Convert rp from str in hex base.
        /// mp_size_t count = mpfr_lib.mpn_set_str(rp, str, 9, 16);
        /// 
        /// // Assert the non-ASCII, hex representation of s1p.
        /// Assert.IsTrue(count == rp.Size);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp);
        /// mpfr_lib.free(str);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands.
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim s As Byte() = New Byte() { 1, 0, 0, 0, 0, 0, 0, 0, 1}
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// Dim str As New char_ptr("xxxxxxxxxxxxxxxxx")
        /// Marshal.Copy(s, 0, str.ToIntPtr(), 9)
        /// 
        /// ' Convert rp from str in hex base.
        /// Dim count As mp_size_t = mpfr_lib.mpn_set_str(rp, str, 9, 16)
        /// 
        /// ' Assert the non-ASCII, hex representation of s1p.
        /// Assert.IsTrue(count = rp.Size)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp)
        /// mpfr_lib.free(str)
        /// </code> 
        /// </example>
        public static mp_size_t mpn_set_str(mp_ptr rp, /*const unsigned*/ char_ptr str, size_t strsize, int @base)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (IntPtr.Size == 4)
                return new mp_size_t(SafeNativeMethods.__mpfrn_set_str_x86(rp.ToIntPtr(), str.ToIntPtr(), (uint)strsize, @base));
            else
                return new mp_size_t(SafeNativeMethods.__mpfrn_set_str_x64(rp.ToIntPtr(), str.ToIntPtr(), strsize, @base));
        }

        /// <summary>
        /// Return the size of {<paramref name="xp"/>, <paramref name="n"/>} measured in number of digits in the given <paramref name="base"/>.
        /// </summary>
        /// <param name="xp">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="xp"/>.</param>
        /// <param name="base">The base.</param>
        /// <returns>The size of {<paramref name="xp"/>, <paramref name="n"/>} measured in number of digits in the given <paramref name="base"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="base"/> can vary from 2 to 62.
        /// Requires <paramref name="n"/> &gt; 0 and <paramref name="xp"/>[<paramref name="n"/> - 1] &gt; 0.
        /// The result will be either exact or 1 too big.
        /// If base is a power of 2, the result is always exact. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_get_str"/>
        /// <seealso cref="mpn_set_str"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr xp = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
        /// 
        /// // Assert that the number of bits required is 33.
        /// Assert.IsTrue(mpfr_lib.mpn_sizeinbase(xp, xp.Size, 2) == 33);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(xp);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim xp As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// 
        /// ' Assert that the number of bits required is 33.
        /// Assert.IsTrue(mpfr_lib.mpn_sizeinbase(xp, xp.Size, 2) = 33)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(xp)
        /// </code> 
        /// </example>
        public static size_t mpn_sizeinbase(/*const*/ mp_ptr xp, mp_size_t n, int @base)
        {
            if (xp == null) throw new ArgumentNullException("xp");
            if (IntPtr.Size == 4)
                return new size_t(SafeNativeMethods.__mpfrn_sizeinbase_x86(xp.ToIntPtr(), n, @base));
            else
                return new size_t(SafeNativeMethods.__mpfrn_sizeinbase_x64(xp.ToIntPtr(), n, @base));
        }

        /// <summary>
        /// Compute the square root of {<paramref name="sp"/>, <paramref name="n"/>} and put the result at {<paramref name="r1p"/>, ceil(<paramref name="n"/> / 2)} and the remainder at {<paramref name="r2p"/>, retval}.
        /// </summary>
        /// <param name="r1p">The first result integer.</param>
        /// <param name="r2p">The second result integer.</param>
        /// <param name="sp">The operand integwer.</param>
        /// <param name="n">The number of limbs of <paramref name="sp"/>.</param>
        /// <returns>The number of limbs of <paramref name="r2p"/>.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="r2p"/> needs space for <paramref name="n"/> limbs,
        /// but the return value indicates how many are produced. 
        /// </para>
        /// <para>
        /// The most significant limb of {<paramref name="sp"/>, <paramref name="n"/>} must be non-zero.
        /// The areas {<paramref name="r1p"/>, ceil(<paramref name="n"/> / 2)} and
        /// {<paramref name="sp"/>, <paramref name="n"/>} must be completely separate. 
        /// The areas {<paramref name="r2p"/>, <paramref name="n"/>} and {<paramref name="sp"/>, <paramref name="n"/>}
        /// must be either identical or completely separate.
        /// </para>
        /// <para>
        /// If the remainder is not wanted then <paramref name="r2p"/> can be NULL, and in this case the return value
        /// is zero or non-zero according to whether the remainder would have been zero or non-zero.
        /// </para>
        /// <para>
        /// A return value of zero indicates a perfect square. See also <see cref="mpn_perfect_square_p"/>.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0x00000001, 0x00000001 });
        /// mp_ptr r1p = new mp_ptr(new uint[sp.Size * (mpfr_lib.mp_bytes_per_limb / 4)]);
        /// mp_ptr r2p = new mp_ptr(new uint[sp.Size * (mpfr_lib.mp_bytes_per_limb / 4)]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00010000, 0x00000000 });
        /// mp_ptr remainder = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// 
        /// // Set r1p = trunc(sqrt(sp)), r2p = sp - r1p^2
        /// mp_size_t r2n = mpfr_lib.mpn_sqrtrem(r1p, r2p, sp, sp.Size);
        /// 
        /// // Assert result.
        /// Assert.IsTrue(r2n == 1);
        ///  Assert.IsTrue(r1p.SequenceEqual(result));
        /// Assert.IsTrue(r2p.SequenceEqual(remainder));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(sp, r1p, r2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;H1, &amp;H1})
        /// Dim r1p As New mp_ptr(New UInteger(sp.Size * (mpfr_lib.mp_bytes_per_limb / 4) - 1) {})
        /// Dim r2p As New mp_ptr(New UInteger(sp.Size * (mpfr_lib.mp_bytes_per_limb / 4) - 1) {})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H10000, &amp;H0})
        /// Dim remainder As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// 
        /// ' Set r1p = trunc(sqrt(sp)), r2p = sp - r1p^2
        /// Dim r2n As mp_size_t = mpfr_lib.mpn_sqrtrem(r1p, r2p, sp, sp.Size)
        /// 
        /// ' Assert result.
        /// Assert.IsTrue(r2n = 1)
        /// Assert.IsTrue(r1p.SequenceEqual(result))
        /// Assert.IsTrue(r2p.SequenceEqual(remainder))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(sp, r1p, r2p, result)
        /// </code> 
        /// </example>
        public static mp_size_t mpn_sqrtrem(mp_ptr r1p, mp_ptr r2p, /*const*/ mp_ptr sp, mp_size_t n)
        {
            if (r1p == null) throw new ArgumentNullException("r1p");
            if (r2p == null) throw new ArgumentNullException("r2p");
            if (sp == null) throw new ArgumentNullException("sp");
            return new mp_size_t(SafeNativeMethods.__mpfrn_sqrtrem(r1p.ToIntPtr(), r2p.ToIntPtr(), sp.ToIntPtr(), n));
        }

        /// <summary>
        /// Subtract {<paramref name="s2p"/>, <paramref name="s2n"/>} from {<paramref name="s1p"/>, <paramref name="s1n"/>}, and write the <paramref name="s1n"/> least significant limbs of the result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s1n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="s2n">The number of limbs of <paramref name="s2p"/>.</param>
        /// <returns>Return borrow, either 0 or 1.</returns>
        /// <remarks>
        /// <para>
        /// This is the lowest-level function for subtraction. It is the preferred function for subtraction, since it is written in assembly for most CPUs.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// 
        /// // Set rp = s1 - s2.
        /// mp_limb_t borrow = mpfr_lib.mpn_sub(rp, s1p, s1p.Size, s2p, s2p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 0);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 - s2.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_sub(rp, s1p, s1p.Size, s2p, s2p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = 0)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_sub(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t s1n, /*const*/ mp_ptr s2p, mp_size_t s2n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sub_x86(rp.ToIntPtr(), s1p.ToIntPtr(), s1n, s2p.ToIntPtr(), s2n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sub_x64(rp.ToIntPtr(), s1p.ToIntPtr(), s1n, s2p.ToIntPtr(), s2n));
        }

        /// <summary>
        /// Subtract <paramref name="s2limb"/> from {<paramref name="s1p"/>, <paramref name="n"/>}, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="n">The numbe rof limbs of <paramref name="s1p"/>.</param>
        /// <param name="s2limb">The second operand integer.</param>
        /// <returns>Return borrow, either 0 or 1.</returns>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// 
        /// // Set rp = s1 - 1.
        /// mp_limb_t borrow = mpfr_lib.mpn_sub_1(rp, s1p, s1p.Size, 1);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 0);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 - 1.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_sub_1(rp, s1p, s1p.Size, 1)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = 0)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_sub_1(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n, mp_limb_t s2limb)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sub_1_x86(rp.ToIntPtr(), s1p.ToIntPtr(), n, (uint)s2limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sub_1_x64(rp.ToIntPtr(), s1p.ToIntPtr(), n, s2limb));
        }

        /// <summary>
        /// Subtract {<paramref name="s2p"/>, <paramref name="n"/>} from {<paramref name="s1p"/>, <paramref name="n"/>}, and write the <paramref name="n"/> least significant limbs of the result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The numbe rof limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <returns>Return borrow, either 0 or 1.</returns>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// 
        /// // Set rp = s1 - s2.
        /// mp_limb_t borrow = mpfr_lib.mpn_sub_n(rp, s1p, s2p, rp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 0);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        ///  Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 - s2.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_sub_n(rp, s1p, s2p, rp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = 0)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_sub_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sub_n_x86(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sub_n_x64(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
        }

        /// <summary>
        /// Multiply {<paramref name="s1p"/>, <paramref name="n"/>} and <paramref name="s2limb"/>, and subtract the <paramref name="n"/> least significant limbs of the product from {<paramref name="rp"/>, <paramref name="n"/>} and write the result to <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/></param>
        /// <param name="s2limb">The second operand integer.</param>
        /// <returns>Return the most significant limb of the product, plus borrow-out from the subtraction.</returns>
        /// <remarks>
        /// <para>
        /// {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="rp"/>, <paramref name="n"/>}
        /// are allowed to overlap provided <paramref name="rp"/> &#8804; <paramref name="s1p"/>.
        /// </para>
        /// <para>
        /// This is a low-level function that is a building block for general multiplication and division
        /// as well as other operations in MPFR. It is written in assembly for most CPUs. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpn_tdiv_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(new uint[] { 0x00000002, 0x00000000 });
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000004, 0x00000000 });
        /// 
        /// // Set rp -= s1 * 2.
        /// mp_limb_t borrow = mpfr_lib.mpn_submul_1(rp, s1p, s1p.Size, 2);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 0x02);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(New UInteger() { &amp;H2, &amp;H0})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H4, &amp;H0})
        /// 
        /// ' Set rp -= s1 * 2.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_submul_1(rp, s1p, s1p.Size, 2)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = &amp;H2)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_submul_1(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n, mp_limb_t s2limb)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_submul_1_x86(rp.ToIntPtr(), s1p.ToIntPtr(), n, (uint)s2limb));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_submul_1_x64(rp.ToIntPtr(), s1p.ToIntPtr(), n, s2limb));
        }

        /// <summary>
        /// Divide {<paramref name="np"/>, <paramref name="nn"/>} by {<paramref name="dp"/>, <paramref name="dn"/>} and put the quotient at {<paramref name="qp"/>, <paramref name="nn"/> - <paramref name="dn"/> + 1} and the remainder at {<paramref name="rp"/>, <paramref name="dn"/>}.
        /// </summary>
        /// <param name="qp">The result quotient integer.</param>
        /// <param name="rp">The result remainder integer.</param>
        /// <param name="qxn">Must be 0.</param>
        /// <param name="np">The numerator operand integer.</param>
        /// <param name="nn">The number of limbs of <paramref name="np"/>.</param>
        /// <param name="dp">The denominator operand integer.</param>
        /// <param name="dn">The number of limbs of <paramref name="dp"/>.</param>
        /// <remarks>
        /// <para>
        /// The quotient is rounded towards 0.
        /// </para>
        /// <para>
        /// No overlap is permitted between arguments, except that <paramref name="np"/> might
        /// equal <paramref name="rp"/>.
        /// The dividend size <paramref name="nn"/> must be greater than or equal to divisor
        /// size <paramref name="dn"/>.
        /// The most significant limb of the divisor must be non-zero.
        /// The <paramref name="qxn"/> operand must be zero. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_add"/>
        /// <seealso cref="mpn_add_1"/>
        /// <seealso cref="mpn_add_n"/>
        /// <seealso cref="mpn_addmul_1"/>
        /// <seealso cref="mpn_divexact_1"/>
        /// <seealso cref="mpn_divexact_by3"/>
        /// <seealso cref="mpn_divexact_by3c"/>
        /// <seealso cref="mpn_divmod_1"/>
        /// <seealso cref="mpn_divrem_1"/>
        /// <seealso cref="mpn_mod_1"/>
        /// <seealso cref="mpn_mul"/>
        /// <seealso cref="mpn_mul_1"/>
        /// <seealso cref="mpn_mul_n"/>
        /// <seealso cref="mpn_neg"/>
        /// <seealso cref="mpn_sub"/>
        /// <seealso cref="mpn_sub_1"/>
        /// <seealso cref="mpn_sub_n"/>
        /// <seealso cref="mpn_submul_1"/>
        /// <seealso cref="mpn_sqr"/>
        /// <seealso cref="mpn_sqrtrem"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr np = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr dp = new mp_ptr(new uint[] { 0x00000013 });
        /// mp_ptr qp = new mp_ptr(new uint[np.Size - dp.Size + 1]);
        /// mp_ptr rp = new mp_ptr(new uint[dp.Size]);
        /// mp_ptr quotient = new mp_ptr(new uint[] { 0x435e50d7, 0x00000d79 });
        /// mp_ptr remainder = new mp_ptr(new uint[] { 0x0000000a });
        /// 
        /// // Set rp = np / dp.
        /// mpfr_lib.mpn_tdiv_qr(qp, rp, 0, np, np.Size, dp, dp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(qp.SequenceEqual(quotient));
        /// Assert.IsTrue(rp.SequenceEqual(remainder));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(qp, rp, np, dp, quotient, remainder);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim np As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim dp As New mp_ptr(New UInteger() { &amp;H13})
        /// Dim qp As New mp_ptr(New UInteger(np.Size - dp.Size) { })
        /// Dim rp As New mp_ptr(New UInteger(dp.Size - 1) { })
        /// Dim quotient As New mp_ptr(New UInteger() { &amp;H435e50d7, &amp;Hd79})
        /// Dim remainder As New mp_ptr(New UInteger() { &amp;Ha})
        /// 
        /// ' Set rp = np / dp.
        /// mpfr_lib.mpn_tdiv_qr(qp, rp, 0, np, np.Size, dp, dp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(qp.SequenceEqual(quotient))
        /// Assert.IsTrue(rp.SequenceEqual(remainder))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(qp, rp, np, dp, quotient, remainder)
        /// </code> 
        /// </example>
        public static void mpn_tdiv_qr(mp_ptr qp, mp_ptr rp, mp_size_t qxn, /*const*/ mp_ptr np, mp_size_t nn, /*const*/ mp_ptr dp, mp_size_t dn)
        {
            if (qp == null) throw new ArgumentNullException("qp");
            if (rp == null) throw new ArgumentNullException("rp");
            if (np == null) throw new ArgumentNullException("np");
            if (dp == null) throw new ArgumentNullException("dp");
            SafeNativeMethods.__mpfrn_tdiv_qr(qp.ToIntPtr(), rp.ToIntPtr(), qxn, np.ToIntPtr(), nn, dp.ToIntPtr(), dn);
        }

        /// <summary>
        /// Perform the bitwise logical and of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// 
        /// // Set rp = s1 and s2.
        /// mpfr_lib.mpn_and_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// 
        /// ' Set rp = s1 and s2.
        /// mpfr_lib.mpn_and_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_and_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_and_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical and of {<paramref name="s1p"/>, <paramref name="n"/>} and the bitwise complement of {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xedcba987 });
        /// 
        /// // Set rp = s1 and not s2.
        /// mpfr_lib.mpn_andn_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;Hedcba987UI})
        /// 
        /// ' Set rp = s1 and not s2.
        /// mpfr_lib.mpn_andn_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_andn_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_andn_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical and of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the bitwise complement of the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// 
        /// // Set rp = not(s1 and s2).
        /// mpfr_lib.mpn_and_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        ///  rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// 
        /// ' Set rp = not(s1 and s2).
        /// mpfr_lib.mpn_and_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_nand_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_nand_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical inclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// 
        /// // Set rp = s1 or s2.
        /// mpfr_lib.mpn_ior_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 or s2.
        /// mpfr_lib.mpn_ior_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_ior_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_ior_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical inclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and the bitwise complement of {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// 
        /// // Set rp = s1 or not s2.
        /// mpfr_lib.mpn_iorn_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 or not s2.
        /// mpfr_lib.mpn_iorn_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_iorn_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_iorn_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical inclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the bitwise complement of the result to {<paramref name="rp"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp = not (s1 or s2).
        /// mpfr_lib.mpn_nior_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp = not (s1 or s2).
        /// mpfr_lib.mpn_nior_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_nior_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_nior_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical exclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xnor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xedcba987 });
        /// 
        /// // Set rp = s1 xor s2.
        /// mpfr_lib.mpn_xor_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;Hedcba987UI})
        /// 
        /// ' Set rp = s1 xor s2.
        /// mpfr_lib.mpn_xor_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_xor_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_xor_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Perform the bitwise logical exclusive or of {<paramref name="s1p"/>, <paramref name="n"/>} and {<paramref name="s2p"/>, <paramref name="n"/>}, and write the bitwise complement of the result to {<paramref name="rp"/>, <paramref name="n"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <seealso cref="mpn_and_n"/>
        /// <seealso cref="mpn_andn_n"/>
        /// <seealso cref="mpn_com"/>
        /// <seealso cref="mpn_ior_n"/>
        /// <seealso cref="mpn_iorn_n"/>
        /// <seealso cref="mpn_nand_n"/>
        /// <seealso cref="mpn_nior_n"/>
        /// <seealso cref="mpn_xor_n"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x12345678 });
        /// 
        /// // Set rp = not(s1 xor s2).
        /// mpfr_lib.mpn_xnor_n(rp, s1p, s2p, s1p.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H12345678})
        /// 
        /// ' Set rp = not(s1 xor s2).
        /// mpfr_lib.mpn_xnor_n(rp, s1p, s2p, s1p.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static void mpn_xnor_n(mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            SafeNativeMethods.__mpfrn_xnor_n(rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n);
        }

        /// <summary>
        /// Copy from {<paramref name="s1p"/>, <paramref name="n"/>} to {<paramref name="rp"/>, <paramref name="n"/>}, increasingly. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <seealso cref="mpn_copyd"/>
        /// <seealso cref="mpn_zero"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
        /// 
        /// // Set rp = sp.
        /// mpfr_lib.mpn_copyi(rp, sp, sp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
        /// 
        /// ' Set rp = sp.
        /// mpfr_lib.mpn_copyi(rp, sp, sp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static void mpn_copyi(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            SafeNativeMethods.__mpfrn_copyi(rp.ToIntPtr(), s1p.ToIntPtr(), n);
        }

        /// <summary>
        /// Copy from {<paramref name="s1p"/>, <paramref name="n"/>} to {<paramref name="rp"/>, <paramref name="n"/>}, decreasingly. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/>.</param>
        /// <seealso cref="mpn_copyi"/>
        /// <seealso cref="mpn_zero"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr sp = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xf0f0f0f0, 0xf0f0f0f0 });
        /// 
        /// // Set rp = sp.
        /// mpfr_lib.mpn_copyd(rp, sp, sp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim sp As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;Hf0f0f0f0UI, &amp;Hf0f0f0f0UI})
        /// 
        /// ' Set rp = sp.
        /// mpfr_lib.mpn_copyd(rp, sp, sp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, sp, result)
        /// </code> 
        /// </example>
        public static void mpn_copyd(mp_ptr rp, /*const*/ mp_ptr s1p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            SafeNativeMethods.__mpfrn_copyd(rp.ToIntPtr(), s1p.ToIntPtr(), n);
        }

        /// <summary>
        /// Zero {<paramref name="rp"/>, <paramref name="n"/>}.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="n">The number of limbs of <paramref name="rp"/>.</param>
        /// <seealso cref="mpn_copyd"/>
        /// <seealso cref="mpn_copyi"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operand, and expected result.
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp = sp.
        /// mpfr_lib.mpn_zero(rp, rp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operand, and expected result.
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp = sp.
        /// mpfr_lib.mpn_zero(rp, rp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, result)
        /// </code> 
        /// </example>
        public static void mpn_zero(mp_ptr rp, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            SafeNativeMethods.__mpfrn_zero(rp.ToIntPtr(), n);
        }

        /// <summary>
        /// If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="mpn_add_n"/>, and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
        /// </summary>
        /// <param name="cnd">Conditonal value: non-zero for true, zero for false.</param>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <returns>If <paramref name="cnd"/> is non-zero, return carry, either 0 or 1, and if <paramref name="cnd"/> is zero, return 0.</returns>
        /// <remarks>
        /// <para>
        /// This function does conditional addition.
        /// If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="mpn_add_n"/>,
        /// and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
        /// The functions is designed to have timing and memory access patterns depending only
        /// on size and location of the data areas, but independent of the condition <paramref name="cnd"/>.
        /// Like for <see cref="mpn_add_n"/>, on most machines, the timing will also be independent
        /// of the actual limb values. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// 
        /// // Set rp = s1 + s2.
        /// mp_limb_t carry = mpfr_lib.mpn_cnd_add_n(1, rp, s1p, s2p, rp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// 
        /// ' Set rp = s1 + s2.
        /// Dim carry As mp_limb_t = mpfr_lib.mpn_cnd_add_n(1, rp, s1p, s2p, rp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(carry = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_cnd_add_n(mp_limb_t cnd, mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_cnd_add_n_x86((uint)cnd, rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_cnd_add_n_x64(cnd, rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
        }


        /// <summary>
        /// If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="mpn_sub_n"/>, and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
        /// </summary>
        /// <param name="cnd">Conditonal value: non-zero for true, zero for false.</param>
        /// <param name="rp">The result integer.</param>
        /// <param name="s1p">The first operand integer.</param>
        /// <param name="s2p">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="s1p"/> and <paramref name="s2p"/>.</param>
        /// <returns>If <paramref name="cnd"/> is non-zero, return borrow, either 0 or 1, and if <paramref name="cnd"/> is zero, return 0.</returns>
        /// <remarks>
        /// <para>
        /// This function does conditional addition.
        /// If <paramref name="cnd"/> is non-zero, it produces the same result as a regular <see cref="mpn_sub_n"/>,
        /// and if <paramref name="cnd"/> is zero, it copies {<paramref name="s1p"/>, <paramref name="n"/>} to the result area and returns zero.
        /// The functions is designed to have timing and memory access patterns depending only
        /// on size and location of the data areas, but independent of the condition <paramref name="cnd"/>.
        /// Like for <see cref="mpn_sub_n"/>, on most machines, the timing will also be independent
        /// of the actual limb values. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr s1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr s2p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// mp_ptr rp = new mp_ptr(new uint[2]);
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// 
        /// // Set rp = s1 - s2.
        /// mp_limb_t borrow = mpfr_lib.mpn_cnd_sub_n(1, rp, s1p, s2p, rp.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 0);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim s1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim s2p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// Dim rp As New mp_ptr(New UInteger(1) { })
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// 
        /// ' Set rp = s1 - s2.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_cnd_sub_n(1, rp, s1p, s2p, rp.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = 0)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, s1p, s2p, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_cnd_sub_n(mp_limb_t cnd, mp_ptr rp, /*const*/ mp_ptr s1p, /*const*/ mp_ptr s2p, mp_size_t n)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (s1p == null) throw new ArgumentNullException("s1p");
            if (s2p == null) throw new ArgumentNullException("s2p");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_cnd_sub_n_x86((uint)cnd, rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_cnd_sub_n_x64(cnd, rp.ToIntPtr(), s1p.ToIntPtr(), s2p.ToIntPtr(), n));
        }

        /// <summary>
        /// Set R to A + b, where R = {<paramref name="rp"/>, <paramref name="n"/>}, A = {<paramref name="ap"/>, <paramref name="n"/>}, and <paramref name="b"/> is a single limb.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="ap">The first operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="rp"/>.</param>
        /// <param name="b">The second operand integer.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <returns>Returns carry, either 0 or 1.</returns>
        /// <remarks>
        /// <para>
        /// This function takes O(N) time, unlike the leaky functions <see cref="mpn_add_1"/> which is O(1) on average.
        /// It requires scratch space of <see cref="mpn_sec_add_1_itch"/>(n) limbs, to be passed in the <paramref name="tp"/> parameter.
        /// The scratch space requirements are guaranteed to be at most <paramref name="n"/> limbs, and increase monotonously in the operand size.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1_itch"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000000, 0x00000000 });
        /// mp_ptr rp = new mp_ptr(result.Size);
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_add_1_itch(ap.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set rp = ap + 1.
        /// mp_limb_t carry = mpfr_lib.mpn_sec_add_1(rp, ap, ap.Size, 1, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(carry == 1);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, tp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H0, &amp;H0})
        /// Dim rp As New mp_ptr(result.Size)
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_add_1_itch(ap.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set rp = ap + 1.
        /// Dim carry As mp_limb_t = mpfr_lib.mpn_sec_add_1(rp, ap, ap.Size, 1, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(carry = 1)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, tp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_sec_add_1(mp_ptr rp, /*const*/ mp_ptr ap, mp_size_t n, mp_limb_t b, mp_ptr tp)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (ap == null) throw new ArgumentNullException("ap");
            if (tp == null) throw new ArgumentNullException("tp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sec_add_1_x86(rp.ToIntPtr(), ap.ToIntPtr(), n, (uint)b, tp.ToIntPtr()));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sec_add_1_x64(rp.ToIntPtr(), ap.ToIntPtr(), n, b, tp.ToIntPtr()));
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_add_1"/>.
        /// </summary>
        /// <param name="n">The number of limbs of the <see cref="mpn_sec_add_1"/> operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_add_1"/>.</returns>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_add_1_itch(mp_size_t n)
        {
            return new mp_size_t(SafeNativeMethods.__mpfrn_sec_add_1_itch(n));
        }

        /// <summary>
        /// Set R to A - b, where R = {<paramref name="rp"/>, <paramref name="n"/>}, A = {<paramref name="ap"/>, <paramref name="n"/>}, and <paramref name="b"/> is a single limb.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="ap">The first operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="rp"/>.</param>
        /// <param name="b">The second operand integer.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <returns>Returns borrow, either 0 or 1.</returns>
        /// <remarks>
        /// <para>
        /// This function takes O(N) time, unlike the leaky functions <see cref="mpn_sub_1"/> which is O(1) on average.
        /// It requires scratch space of <see cref="mpn_sec_sub_1_itch"/>(n) limbs, to be passed in the <paramref name="tp"/> parameter.
        /// The scratch space requirements are guaranteed to be at most <paramref name="n"/> limbs, and increase monotonously in the operand size.
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1_itch"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(result.Size);
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_sub_1_itch(ap.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set rp = ap - 1.
        /// mp_limb_t borrow = mpfr_lib.mpn_sec_sub_1(rp, ap, ap.Size, 1, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(borrow == 0);
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, tp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(result.Size)
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_sub_1_itch(ap.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set rp = ap - 1.
        /// Dim borrow As mp_limb_t = mpfr_lib.mpn_sec_sub_1(rp, ap, ap.Size, 1, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(borrow = 0)
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, tp, result)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_sec_sub_1(mp_ptr rp, /*const*/ mp_ptr ap, mp_size_t n, mp_limb_t b, mp_ptr tp)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (ap == null) throw new ArgumentNullException("ap");
            if (tp == null) throw new ArgumentNullException("tp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sec_sub_1_x86(rp.ToIntPtr(), ap.ToIntPtr(), n, (uint)b, tp.ToIntPtr()));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sec_sub_1_x64(rp.ToIntPtr(), ap.ToIntPtr(), n, b, tp.ToIntPtr()));
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_sub_1"/>.
        /// </summary>
        /// <param name="n">The number of limbs of the <see cref="mpn_sec_sub_1"/> operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_sub_1"/>.</returns>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_sub_1_itch(mp_size_t n)
        {
            return SafeNativeMethods.__mpfrn_sec_sub_1_itch(n);
        }

        /// <summary>
        /// If <paramref name="cnd"/> is non-zero, swaps the contents of the areas {<paramref name="ap"/>, <paramref name="n"/>} and {<paramref name="bp"/>, <paramref name="n"/>}. Otherwise, the areas are left unmodified.
        /// </summary>
        /// <param name="cnd">Conditonal value: non-zero for true, zero for false.</param>
        /// <param name="ap">The first operand integer.</param>
        /// <param name="bp">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="bp"/>.</param>
        /// <remarks>
        /// <para>
        /// Implemented using logical operations on the limbs, with the same memory accesses independent of the value of <paramref name="cnd"/>. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr bp = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// mp_ptr a1p = new mp_ptr(new uint[] { 0x00000001, 0x00000000 });
        /// mp_ptr b1p = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// 
        /// // Exchange ab and bp.
        /// mpfr_lib.mpn_cnd_swap(1, ap, bp, ap.Size);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(ap.SequenceEqual(a1p));
        /// Assert.IsTrue(bp.SequenceEqual(b1p));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(ap, bp, a1p, b1p);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim bp As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// Dim a1p As New mp_ptr(New UInteger() { &amp;H1, &amp;H0})
        /// Dim b1p As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// 
        /// ' Exchange ab and bp.
        /// mpfr_lib.mpn_cnd_swap(1, ap, bp, ap.Size)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(ap.SequenceEqual(a1p))
        /// Assert.IsTrue(bp.SequenceEqual(b1p))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(ap, bp, a1p, b1p)
        /// </code> 
        /// </example>
        public static void mpn_cnd_swap(mp_limb_t cnd, /*volatile*/ mp_ptr /*mp_limb_t**/ ap, /*volatile*/ mp_ptr /*mp_limb_t**/ bp, mp_size_t n)
        {
            if (ap == null) throw new ArgumentNullException("ap");
            if (bp == null) throw new ArgumentNullException("bp");
            if (IntPtr.Size == 4)
                SafeNativeMethods.__mpfrn_cnd_swap_x86((uint)cnd, ap.ToIntPtr(), bp.ToIntPtr(), n);
            else
                SafeNativeMethods.__mpfrn_cnd_swap_x64(cnd, ap.ToIntPtr(), bp.ToIntPtr(), n);
        }

        /// <summary>
        /// Set R to A * B, where A = {<paramref name="ap"/>, <paramref name="an"/>}, B = {<paramref name="bp"/>, <paramref name="bn"/>}, and R = {<paramref name="rp"/>, <paramref name="an"/> + <paramref name="bn"/>}. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="ap">The first operand integer.</param>
        /// <param name="an">The number of limbs of <paramref name="ap"/>.</param>
        /// <param name="bp">The second operand integer.</param>
        /// <param name="bn">The number of limbs of <paramref name="bp"/>.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <remarks>
        /// <para>
        /// It is required that <paramref name="an"/> &#8805; bn &gt; 0. 
        /// </para>
        /// <para>
        /// No overlapping between R and the input operands is allowed.
        /// For A = B, use <see cref="mpn_sec_sqr"/> for optimal performance. 
        /// </para>
        /// <para>
        /// This function requires scratch space of <see cref="mpn_sec_mul_itch"/>(<paramref name="an"/>, <paramref name="bn"/>)
        /// limbs to be passed in the tp parameter. The scratch space requirements are guaranteed to increase monotonously in the operand sizes. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul_itch"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr bp = new mp_ptr(new uint[] { 0x00000002 });
        /// mp_ptr result = new mp_ptr(new uint[] { 0xfffffffe, 0xffffffff, 0x00000001 });
        /// mp_ptr rp = new mp_ptr(ap.Size + bp.Size);
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_mul_itch(ap.Size, bp.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set rp = ap * bp.
        /// mpfr_lib.mpn_sec_mul(rp, ap, ap.Size, bp, bp.Size, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, bp, tp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim bp As New mp_ptr(New UInteger() { &amp;H2})
        /// Dim result As New mp_ptr(New UInteger() { &amp;HfffffffeUI, &amp;HffffffffUI, &amp;H1})
        /// Dim rp As New mp_ptr(ap.Size + bp.Size)
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_mul_itch(ap.Size, bp.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set rp = ap * bp.
        /// mpfr_lib.mpn_sec_mul(rp, ap, ap.Size, bp, bp.Size, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, bp, tp, result)
        /// </code> 
        /// </example>
        public static void mpn_sec_mul(mp_ptr rp, /*const*/ mp_ptr ap, mp_size_t an, /*const*/ mp_ptr bp, mp_size_t bn, mp_ptr tp)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (ap == null) throw new ArgumentNullException("ap");
            if (bp == null) throw new ArgumentNullException("bp");
            if (tp == null) throw new ArgumentNullException("tp");
            SafeNativeMethods.__mpfrn_sec_mul(rp.ToIntPtr(), ap.ToIntPtr(), an, bp.ToIntPtr(), bn, tp.ToIntPtr());
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_mul"/>.
        /// </summary>
        /// <param name="an">The number of limbs of the <see cref="mpn_sec_mul"/> first operand.</param>
        /// <param name="bn">The number of limbs of the <see cref="mpn_sec_mul"/> second operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_mul"/>.</returns>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_mul_itch(mp_size_t an, mp_size_t bn)
        {
            return SafeNativeMethods.__mpfrn_sec_mul_itch(an, bn);
        }

        /// <summary>
        /// Set R to A^2, where A = {<paramref name="ap"/>, <paramref name="an"/>}, and R = {<paramref name="rp"/>, 2 * <paramref name="an"/>}. 
        /// </summary>
        /// <param name="rp">The result operand.</param>
        /// <param name="ap">The operand integer.</param>
        /// <param name="an">The number of limbs of <paramref name="ap"/>.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <remarks>
        /// <para>
        /// It is required that <paramref name="an"/> &gt; 0. 
        /// </para>
        /// <para>
        /// No overlapping between R and the input operands is allowed. 
        /// </para>
        /// <para>
        /// This function requires scratch space of <see cref="mpn_sec_sqr_itch"/>(<paramref name="an"/>)
        /// limbs to be passed in the <paramref name="tp"/> parameter.
        /// The scratch space requirements are guaranteed to increase monotonously in the operand size. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr_itch"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr ap = new mp_ptr(new uint[] { 0xffffffff, 0xffffffff });
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001, 0x00000000, 0xfffffffe, 0xffffffff });
        /// mp_ptr rp = new mp_ptr(2 * ap.Size);
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_sqr_itch(ap.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set rp = s1^2.
        /// mpfr_lib.mpn_sec_sqr(rp, ap, ap.Size, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, tp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim ap As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;HffffffffUI})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1, &amp;H0, &amp;HfffffffeUI, &amp;HffffffffUI})
        /// Dim rp As New mp_ptr(2 * ap.Size)
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_sqr_itch(ap.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set rp = s1^2.
        /// mpfr_lib.mpn_sec_sqr(rp, ap, ap.Size, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, ap, tp, result)
        /// </code> 
        /// </example>
        public static void mpn_sec_sqr(mp_ptr rp, /*const*/ mp_ptr ap, mp_size_t an, mp_ptr tp)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (ap == null) throw new ArgumentNullException("ap");
            if (tp == null) throw new ArgumentNullException("tp");
            SafeNativeMethods.__mpfrn_sec_sqr(rp.ToIntPtr(), ap.ToIntPtr(), an, tp.ToIntPtr());
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_sqr"/>.
        /// </summary>
        /// <param name="an">The number of limbs of the <see cref="mpn_sec_sqr"/> operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_sqr"/>.</returns>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_sqr_itch(mp_size_t an)
        {
            return SafeNativeMethods.__mpfrn_sec_sqr_itch(an);
        }

        /// <summary>
        /// Set R to (B^E) modulo M, where R = {<paramref name="rp"/>, <paramref name="n"/>}, M = {<paramref name="mp"/>, <paramref name="n"/>}, and E = {<paramref name="ep"/>, ceil(<paramref name="enb"/> / <see cref="mp_bits_per_limb"/>)}. 
        /// </summary>
        /// <param name="rp">The result operand.</param>
        /// <param name="bp">The first operand integer.</param>
        /// <param name="bn">The number of limbs of <paramref name="bp"/>.</param>
        /// <param name="ep">The second operand integer.</param>
        /// <param name="enb">The number of limbs of <paramref name="ep"/>.</param>
        /// <param name="mp">The third operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="mp"/>.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <remarks>
        /// <para>
        /// It is required that B &gt; 0, that M &gt; 0 is odd, and that E &lt; 2^<paramref name="enb"/>.
        /// </para>
        /// <para>
        /// No overlapping between R and the input operands is allowed. 
        /// </para>
        /// <para>
        /// This function requires scratch space of <see cref="mpn_sec_powm_itch"/>(<paramref name="bn"/>, <paramref name="enb"/>, <paramref name="n"/>)
        /// limbs to be passed in the <paramref name="tp"/> parameter.
        /// The scratch space requirements are guaranteed to increase monotonously in the operand sizes. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm_itch"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr bp = new mp_ptr(new uint[] { 0x00000002 });
        /// mp_ptr ep = new mp_ptr(new uint[] { 0x00000004 });
        /// mp_ptr mp = new mp_ptr(new uint[] { 0x00000003 });
        /// mp_ptr result = new mp_ptr(new uint[] { 0x00000001 });
        /// mp_ptr rp = new mp_ptr(bp.Size);
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_powm_itch(bp.Size, 3, mp.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set rp = bp^ep mod mp.
        /// mpfr_lib.mpn_sec_powm(rp, bp, bp.Size, ep, 3, mp, mp.Size, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(rp, bp, ep, mp, tp, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim bp As New mp_ptr(New UInteger() { &amp;H2})
        /// Dim ep As New mp_ptr(New UInteger() { &amp;H4})
        /// Dim mp As New mp_ptr(New UInteger() { &amp;H3})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H1})
        /// Dim rp As New mp_ptr(bp.Size)
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_powm_itch(bp.Size, 3, mp.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set rp = bp^ep mod mp.
        /// mpfr_lib.mpn_sec_powm(rp, bp, bp.Size, ep, 3, mp, mp.Size, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(rp, bp, ep, mp, tp, result)
        /// </code> 
        /// </example>
        public static void mpn_sec_powm(mp_ptr rp, /*const*/ mp_ptr bp, mp_size_t bn, /*const*/ mp_ptr ep, mp_bitcnt_t enb, /*const*/ mp_ptr mp, mp_size_t n, mp_ptr tp)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (bp == null) throw new ArgumentNullException("bp");
            if (ep == null) throw new ArgumentNullException("ep");
            if (mp == null) throw new ArgumentNullException("mp");
            if (tp == null) throw new ArgumentNullException("tp");
            SafeNativeMethods.__mpfrn_sec_powm(rp.ToIntPtr(), bp.ToIntPtr(), bn, ep.ToIntPtr(), enb, mp.ToIntPtr(), n, tp.ToIntPtr());
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_powm"/>.
        /// </summary>
        /// <param name="bn">The number of limbs of the <see cref="mpn_sec_powm"/> first operand.</param>
        /// <param name="enb">The number of limbs of the <see cref="mpn_sec_powm"/> second operand.</param>
        /// <param name="n">The number of limbs of the <see cref="mpn_sec_powm"/> third operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_powm"/>.</returns>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_powm_itch(mp_size_t bn, mp_bitcnt_t enb, mp_size_t n)
        {
            return SafeNativeMethods.__mpfrn_sec_powm_itch(bn, enb, n);
        }

        /// <summary>
        /// Select entry <paramref name="which"/> from table <paramref name="tab"/>, which has <paramref name="nents"/> entries, each <paramref name="n"/> limbs. Store the selected entry at <paramref name="rp"/>.
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="tab">The table of operand integers.</param>
        /// <param name="n">The number of limbs in each entry of the table.</param>
        /// <param name="nents">The number of entries in the table.</param>
        /// <param name="which">The zero-based index of the entry to select.</param>
        /// <remarks>
        /// <para>
        /// This function reads the entire table to avoid side-channel information leaks. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_powm_itch"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr tab = new mp_ptr(new uint[] { 0x11111111, 0x22222222, 0x33333333, 0x44444444, 0x33333333, 0x00000000 });
        /// mp_ptr result = new mp_ptr(new uint[] { 0x33333333 });
        /// mp_ptr rp = new mp_ptr(result.Size);
        /// 
        /// // Set rp to third entry in tab.
        /// mpfr_lib.mpn_sec_tabselect(rp, tab, 1, tab.Size, 2);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result));
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(tab, result);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim tab As New mp_ptr(New UInteger() { &amp;H11111111, &amp;H22222222, &amp;H33333333, &amp;H44444444, &amp;H33333333, &amp;H0})
        /// Dim result As New mp_ptr(New UInteger() { &amp;H33333333})
        /// Dim rp As New mp_ptr(result.Size)
        /// 
        /// ' Set rp to third entry in tab.
        /// mpfr_lib.mpn_sec_tabselect(rp, tab, 1, tab.Size, 2)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(rp.SequenceEqual(result))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(tab, result)
        /// </code> 
        /// </example>
        public static void mpn_sec_tabselect(/*volatile*/ mp_ptr /*mp_limb_t**/ rp, /*volatile const*/ mp_ptr /*mp_limb_t**/ tab, mp_size_t n, mp_size_t nents, mp_size_t which)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (tab == null) throw new ArgumentNullException("tab");
            SafeNativeMethods.__mpfrn_sec_tabselect(rp.ToIntPtr(), tab.ToIntPtr(), n, nents, which);
        }

        /// <summary>
        /// Set Q to the truncated quotient N / D and R to N modulo D, where N = {<paramref name="np"/>, <paramref name="nn"/>}, D = {<paramref name="dp"/>, <paramref name="dn"/>}, Q’s most significant limb is the function return value and the remaining limbs are {<paramref name="qp"/>, <paramref name="nn"/> - <paramref name="dn"/>}, and R = {<paramref name="np"/>, <paramref name="dn"/>}. 
        /// </summary>
        /// <param name="qp">The quotient result operand.</param>
        /// <param name="np">The first operand and remainder result integer.</param>
        /// <param name="nn">The number of limbs of <paramref name="np"/>.</param>
        /// <param name="dp">The second operand integer.</param>
        /// <param name="dn">The number of limbs of <paramref name="dp"/>.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <returns>Q’s most significant limb.</returns>
        /// <remarks>
        /// <para>
        /// It is required that <paramref name="nn"/> &#8805; <paramref name="dn"/> &#8805; 1, and that <paramref name="dp"/>[<paramref name="dn"/> - 1] &#8800; 0.
        /// This does not imply that N &#8805; D since N might be zero-padded. 
        /// </para>
        /// <para>
        /// Note the overlapping between N and R.
        /// No other operand overlapping is allowed.
        /// The entire space occupied by N is overwritten. 
        /// </para>
        /// <para>
        /// This function requires scratch space of <see cref="mpn_sec_div_qr_itch"/>(<paramref name="nn"/>, <paramref name="dn"/>)
        /// limbs to be passed in the <paramref name="tp"/> parameter. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr_itch"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr np = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr dp = new mp_ptr(new uint[] { 0x00000003 });
        /// mp_ptr remainder = new mp_ptr(new uint[] { 0x00000000 });
        /// mp_ptr qp = new mp_ptr(new uint[np.Size]);
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_div_qr_itch(np.Size, dp.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set qp = floor(np / dp) and rp = np mod dp.
        /// mp_limb_t mslimb = mpfr_lib.mpn_sec_div_qr(qp, np, np.Size, dp, dp.Size, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(mslimb == (ulong)(mpfr_lib.mp_bytes_per_limb == 4 ? 0x00005555 : 0x0000555555555555));
        /// Assert.IsTrue(qp[0] == (ulong)(mpfr_lib.mp_bytes_per_limb == 4 ? 0x55555555 : 0x0000000000000000));
        /// Assert.IsTrue(np[0] == remainder[0]);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(qp, np, dp, remainder, tp);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim np As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim dp As New mp_ptr(New UInteger() { &amp;H3})
        /// Dim remainder As New mp_ptr(New UInteger() { &amp;H0})
        /// Dim qp As New mp_ptr(New UInteger(np.Size - 1) { })
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_div_qr_itch(np.Size, dp.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set qp = floor(np / dp) and rp = np mod dp.
        /// Dim mslimb As mp_limb_t = mpfr_lib.mpn_sec_div_qr(qp, np, np.Size, dp, dp.Size, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(mslimb = CULng(If(mpfr_lib.mp_bytes_per_limb = 4, &amp;H5555, &amp;H555555555555L)))
        /// Assert.IsTrue(qp(0) = CULng(If(mpfr_lib.mp_bytes_per_limb = 4, &amp;H55555555, &amp;H0)))
        /// Assert.IsTrue(np(0) = remainder(0))
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(qp, np, dp, remainder, tp)
        /// </code> 
        /// </example>
        public static mp_limb_t mpn_sec_div_qr(mp_ptr qp, mp_ptr np, mp_size_t nn, /*const*/ mp_ptr dp, mp_size_t dn, mp_ptr tp)
        {
            if (qp == null) throw new ArgumentNullException("qp");
            if (np == null) throw new ArgumentNullException("np");
            if (dp == null) throw new ArgumentNullException("dp");
            if (tp == null) throw new ArgumentNullException("tp");
            if (IntPtr.Size == 4)
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sec_div_qr_x86(qp.ToIntPtr(), np.ToIntPtr(), nn, dp.ToIntPtr(), dn, tp.ToIntPtr()));
            else
                return new mp_limb_t(SafeNativeMethods.__mpfrn_sec_div_qr_x64(qp.ToIntPtr(), np.ToIntPtr(), nn, dp.ToIntPtr(), dn, tp.ToIntPtr()));
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_div_qr"/>.
        /// </summary>
        /// <param name="nn">The number of limbs of the <see cref="mpn_sec_div_qr"/> first operand.</param>
        /// <param name="dn">The number of limbs of the <see cref="mpn_sec_div_qr"/> second operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_div_qr"/>.</returns>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_div_qr_itch(mp_size_t nn, mp_size_t dn)
        {
            return new mp_size_t(SafeNativeMethods.__mpfrn_sec_div_qr_itch(nn, dn));
        }

        /// <summary>
        /// Set R to N modulo D, where N = {<paramref name="np"/>, <paramref name="nn"/>}, D = {<paramref name="dp"/>, <paramref name="dn"/>}, and R = {<paramref name="np"/>, <paramref name="dn"/>}. 
        /// </summary>
        /// <param name="np">The first operand and result integer.</param>
        /// <param name="nn">The number of limbs of <paramref name="np"/>.</param>
        /// <param name="dp">The second operand integer</param>
        /// <param name="dn">The number of limbs of <paramref name="dp"/>.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <remarks>
        /// <para>
        /// It is required that <paramref name="nn"/> &#8805; <paramref name="dn"/> &#8805; 1,
        /// and that <paramref name="dp"/>[<paramref name="dn"/> - 1] &#8800; 0.
        /// This does not imply that N &#8805; D since N might be zero-padded. 
        /// </para>
        /// <para>
        /// Note the overlapping between N and R.
        /// No other operand overlapping is allowed.
        /// The entire space occupied by N is overwritten. 
        /// </para>
        /// <para>
        /// This function requires scratch space of <see cref="mpn_sec_div_r_itch"/>(<paramref name="nn"/>, <paramref name="dn"/>)
        /// limbs to be passed in the <paramref name="tp"/> parameter. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r_itch"/>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr np = new mp_ptr(new uint[] { 0xffffffff, 0x0000ffff });
        /// mp_ptr dp = new mp_ptr(new uint[] { 0x00000004 });
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_div_r_itch(np.Size, dp.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set np = np mod dp.
        /// mpfr_lib.mpn_sec_div_r(np, np.Size, dp, dp.Size, tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(np[0] == 3);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(np, dp, tp);
        /// </code> 
        /// <code language="VB.NET">
        /// ' Create multi-precision operands, and expected result.
        /// Dim np As New mp_ptr(New UInteger() { &amp;HffffffffUI, &amp;Hffff})
        /// Dim dp As New mp_ptr(New UInteger() { &amp;H4})
        /// 
        /// ' Create scratch space.
        /// Dim size As mp_size_t = mpfr_lib.mpn_sec_div_r_itch(np.Size, dp.Size)
        /// Dim tp As New mp_ptr(size)
        /// 
        /// ' Set np = np mod dp.
        /// mpfr_lib.mpn_sec_div_r(np, np.Size, dp, dp.Size, tp)
        /// 
        /// ' Assert result of operation.
        /// Assert.IsTrue(np(0) = 3)
        /// 
        /// ' Release unmanaged memory.
        /// mpfr_lib.free(np, dp, tp)
        /// </code> 
        /// </example>
        public static void mpn_sec_div_r(mp_ptr np, mp_size_t nn, /*const*/ mp_ptr dp, mp_size_t dn, mp_ptr tp)
        {
            if (np == null) throw new ArgumentNullException("np");
            if (dp == null) throw new ArgumentNullException("dp");
            if (tp == null) throw new ArgumentNullException("tp");
            SafeNativeMethods.__mpfrn_sec_div_r(np.ToIntPtr(), nn, dp.ToIntPtr(), dn, tp.ToIntPtr());
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_div_r"/>.
        /// </summary>
        /// <param name="nn">The number of limbs of the <see cref="mpn_sec_div_r"/> first operand.</param>
        /// <param name="dn">The number of limbs of the <see cref="mpn_sec_div_r"/> second operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_div_r"/>.</returns>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_div_r_itch(mp_size_t nn, mp_size_t dn)
        {
            return new mp_size_t(SafeNativeMethods.__mpfrn_sec_div_r_itch(nn, dn));
        }

        /// <summary>
        /// Set R to the inverse of A modulo M, where R = {<paramref name="rp"/>, <paramref name="n"/>}, A = {<paramref name="ap"/>, <paramref name="n"/>}, and M = {<paramref name="mp"/>, <paramref name="n"/>}. This function’s interface is preliminary. 
        /// </summary>
        /// <param name="rp">The result integer.</param>
        /// <param name="ap">The first operand integer.</param>
        /// <param name="mp">The second operand integer.</param>
        /// <param name="n">The number of limbs of <paramref name="ap"/> and <paramref name="mp"/>.</param>
        /// <param name="nbcnt">The third operand integer.</param>
        /// <param name="tp">The scratch operand integer.</param>
        /// <returns>If an inverse exists, return 1, otherwise return 0 and leave R undefined.</returns>
        /// <remarks>
        /// <para>
        /// If an inverse exists, return 1, otherwise return 0 and leave R undefined.
        /// In either case, the input A is destroyed. 
        /// </para>
        /// <para>
        /// It is required that M is odd, and that <paramref name="nbcnt"/> &#8805; ceil(log(A + 1)) + ceil(log(M + 1)).
        /// A safe choice is <paramref name="nbcnt"/> = 2 * <paramref name="n"/> * <see cref="mp_bits_per_limb"/>,
        /// but a smaller value might improve performance if M or A are known to have leading zero bits. 
        /// </para>
        /// <para>
        /// This function requires scratch space of <see cref="mpn_sec_invert_itch"/>(<paramref name="n"/>)
        /// limbs to be passed in the <paramref name="tp"/> parameter. 
        /// </para>
        /// </remarks>
        /// <seealso cref="mpn_cnd_add_n"/>
        /// <seealso cref="mpn_cnd_sub_n"/>
        /// <seealso cref="mpn_sec_add_1"/>
        /// <seealso cref="mpn_sec_sub_1"/>
        /// <seealso cref="mpn_cnd_swap"/>
        /// <seealso cref="mpn_sec_mul"/>
        /// <seealso cref="mpn_sec_sqr"/>
        /// <seealso cref="mpn_sec_powm"/>
        /// <seealso cref="mpn_sec_tabselect"/>
        /// <seealso cref="mpn_sec_div_qr"/>
        /// <seealso cref="mpn_sec_div_r"/>
        /// <seealso cref="mpn_sec_invert_itch"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        /// <example>
        /// <code language="C#">
        /// // Create multi-precision operands, and expected result.
        /// mp_ptr ap = new mp_ptr(new uint[] { 3 });
        /// mp_ptr mp = new mp_ptr(new uint[] { 11 });
        /// mp_ptr rp = new mp_ptr(ap.Size);
        /// mp_ptr result = new mp_ptr(new uint[] { 4 });
        /// 
        /// // Create scratch space.
        /// mp_size_t size = mpfr_lib.mpn_sec_invert_itch(ap.Size);
        /// mp_ptr tp = new mp_ptr(size);
        /// 
        /// // Set rp = ap^-1 mod mp.
        /// mpfr_lib.mpn_sec_invert(rp, ap, mp, ap.Size, (uint)(2 * ap.Size* mpfr_lib.mp_bits_per_limb), tp);
        /// 
        /// // Assert result of operation.
        /// Assert.IsTrue(rp[0] == result[0]);
        /// 
        /// // Release unmanaged memory.
        /// mpfr_lib.free(ap, mp, rp, result, tp);
        /// </code> 
        /// <code language="VB.NET">
        /// </code> 
        /// </example>
        public static int mpn_sec_invert(mp_ptr rp, mp_ptr ap, /*const*/ mp_ptr mp, mp_size_t n, mp_bitcnt_t nbcnt, mp_ptr tp)
        {
            if (rp == null) throw new ArgumentNullException("rp");
            if (ap == null) throw new ArgumentNullException("ap");
            if (mp == null) throw new ArgumentNullException("mp");
            if (tp == null) throw new ArgumentNullException("tp");
            return SafeNativeMethods.__mpfrn_sec_invert(rp.ToIntPtr(), ap.ToIntPtr(), mp.ToIntPtr(), n, nbcnt, tp.ToIntPtr());
        }

        /// <summary>
        /// Return the scratch space in number of limbs required by the function <see cref="mpn_sec_invert"/>.
        /// </summary>
        /// <param name="n">The number of limbs of the <see cref="mpn_sec_invert"/> first operand.</param>
        /// <returns>The scratch space in number of limbs required by the function <see cref="mpn_sec_invert"/>.</returns>
        /// <seealso cref="mpn_sec_invert"/>
        /// <seealso cref="mpfr_lib"><a href="https://mpfrlib.org/manual/Low_002dlevel-Functions.html#Low_002dlevel-Functions">GNU MPFR - Low-level Functions</a></seealso>
        public static mp_size_t mpn_sec_invert_itch(mp_size_t n)
        {
            return new mp_size_t(SafeNativeMethods.__mpfrn_sec_invert_itch(n));
        }

        #endregion

        [SuppressUnmanagedCodeSecurity]
        private static class SafeNativeMethods
        {

            #region "Win32 functions."

            [DllImport("kernel32", CharSet = CharSet.Unicode)]
            public static extern IntPtr LoadLibrary(string lpFileName);

            [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true, BestFitMapping = false, ThrowOnUnmappableChar = true)]
            public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

            [DllImport("kernel32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool FreeLibrary(IntPtr hModule);

            [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
            [return: MarshalAs(UnmanagedType.Bool)]
            public static extern bool SetDllDirectory(string directory);

            [DllImport("kernel32.dll")]
            public static extern void RtlZeroMemory(IntPtr dst, int length);

#endregion

            #region "Memory allocation functions."

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_get_memory_functions(ref IntPtr /*void*(**) (size_t)*/ alloc_func_ptr, ref IntPtr /*void*(**) (void*, size_t, size_t)*/ realloc_func_ptr, ref IntPtr /*void (**) (void*, size_t)*/ free_func_ptr);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_set_memory_functions(IntPtr /*void*(*) (size_t)*/ alloc_func_ptr, IntPtr /*void*(*) (void*, size_t, size_t)*/ realloc_func_ptr, IntPtr /*void (*) (void*, size_t)*/ free_func_ptr);

            #endregion

            #region "Random number routines."

            ///* obsolete */
            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfr_randinit(IntPtr /*mpfr_randstate_t*/, mpfr_randalg_t, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randinit_default(IntPtr /*mpfr_randstate_t*/ state);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randinit_lc_2exp(IntPtr /*mpfr_randstate_t*/ state, /*const*/ IntPtr /*mpz_t*/ a, uint /*unsigned long int*/ c, uint /*mp_bitcnt_t*/ m2exp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_randinit_lc_2exp_size(IntPtr /*mpfr_randstate_t*/ state, uint /*mp_bitcnt_t*/ size);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randinit_mt(IntPtr /*mpfr_randstate_t*/ state);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randinit_set(IntPtr /*mpfr_randstate_t*/ state, /*const*/ IntPtr /*mpfr_randstate_t*/ /*__mpfr_randstate_struct **/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randseed(IntPtr /*mpfr_randstate_t*/ state, /*const*/ IntPtr /*mpz_t*/ seed);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randseed_ui(IntPtr /*mpfr_randstate_t*/ state, uint /*unsigned long int*/ seed);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfr_randclear(IntPtr /*mpfr_randstate_t*/ state);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfr_urandomb_ui(IntPtr /*mpfr_randstate_t*/ state, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfr_urandomm_ui(IntPtr /*mpfr_randstate_t*/ state, uint /*unsigned long int*/ n);

            #endregion

            #region "Formatted output routines."

            //#define mpfr_asprintf __mpfr_asprintf
            //public static extern int mpfr_asprintf (char **, const char *, ...);

            //#define mpfr_fprintf __mpfr_fprintf
            //# ifdef _MPFR_H_HAVE_FILE
            //public static extern int mpfr_fprintf (FILE *, const char *, ...);
            //#endif

            //#define mpfr_obstack_printf __mpfr_obstack_printf
            //#if defined (_MPFR_H_HAVE_OBSTACK)
            //public static extern int mpfr_obstack_printf (struct obstack *, const char *, ...);
            //#endif

            //#define mpfr_obstack_vprintf __mpfr_obstack_vprintf
            //#if defined (_MPFR_H_HAVE_OBSTACK) && defined (_MPFR_H_HAVE_VA_LIST)
            //public static extern int mpfr_obstack_vprintf (struct obstack *, const char *, va_list);
            //#endif

            //#define mpfr_printf __mpfr_printf
            //        public static extern int mpfr_printf(const char*, ...);

            //#define mpfr_snprintf __mpfr_snprintf
            //        public static extern int mpfr_snprintf(char*, size_t, const char*, ...);

            //#define mpfr_sprintf __mpfr_sprintf
            //        public static extern int mpfr_sprintf(char*, const char*, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vasprintf(ref IntPtr /*char ***/ pp, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ args);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vfprintf(IntPtr /*FILE **/ pp, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ args);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vprintf(/*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ args);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfr_vsnprintf")]
            public static extern int __mpfr_vsnprintf_x86(IntPtr /*char **/ buf, uint /*size_t*/ size, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ args);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfr_vsnprintf")]
            public static extern int __mpfr_vsnprintf_x64(IntPtr /*char **/ buf, ulong /*size_t*/ size, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ args);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vsprintf(IntPtr /*char **/ buf, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ args);

#endregion

            #region "Formatted input routines."

            //#define mpfr_fscanf __mpfr_fscanf
            //# ifdef _MPFR_H_HAVE_FILE
            //        public static extern int mpfr_fscanf(FILE*, const char*, ...);
            //#endif

            //#define mpfr_scanf __mpfr_scanf
            //        public static extern int mpfr_scanf(const char*, ...);

            //#define mpfr_sscanf __mpfr_sscanf
            //        public static extern int mpfr_sscanf(const char*, const char*, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vfscanf(IntPtr /*FILE **/ fp, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ ap);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vscanf(/*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ ap);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfr_vsscanf(/*const*/ IntPtr /*char **/ s, /*const*/ IntPtr /*char **/ fmt, IntPtr /*va_list*/ ap);

#endregion

            #region "Integer (i.e. Z) routines."

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void_ptr /*void **/ __mpfrz_realloc(IntPtr /*mpz_t*/ integer, int /*mp_size_t*/ new_alloc);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_abs(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_add(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_add_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_addmul(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_addmul_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_and(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            //[DllImport(@"libmpfr-4.dll")] /* OBSOLETE */
            //public static extern void __mpfrz_array_init(IntPtr /*mpz_t*/ integer_array, int /*mp_size_t*/ array_size, int /*mp_size_t*/ fixed_num_bits);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_bin_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ k);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_bin_uiui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ n, uint /*unsigned long int*/ k);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_cdiv_q(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_cdiv_q_2exp(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_cdiv_q_ui(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_cdiv_qr(IntPtr /*mpz_t*/ q, IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_cdiv_qr_ui(IntPtr /*mpz_t*/ q, IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_cdiv_r(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_cdiv_r_2exp(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_cdiv_r_ui(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_cdiv_ui(/*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_clear(IntPtr /*mpz_t*/ x);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrz_clears(mpz_t[] x);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_clrbit(IntPtr /*mpz_t*/ rop, uint /*mp_bitcnt_t*/ bit_index);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmp(/*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmp_d(/*const*/ IntPtr /*mpz_t*/ op1, double op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmp_si(/*const*/ IntPtr /*mpz_t*/ op1, int /*long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmp_ui(/*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmpabs(/*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmpabs_d(/*const*/ IntPtr /*mpz_t*/ op1, double op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_cmpabs_ui(/*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_com(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_combit(IntPtr /*mpz_t*/ rop, uint /*mp_bitcnt_t*/ bit_index);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_congruent_p(/*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ c, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_congruent_2exp_p(/*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ c, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_congruent_ui_p(/*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ c, uint /*unsigned long int*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_divexact(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_divexact_ui(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_divisible_p(/*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_divisible_ui_p(/*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_divisible_2exp_p(/*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrz_dump(/*const*/ IntPtr /*mpz_t*/ x);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_export")]
            public static extern IntPtr /*void **/ __mpfrz_export_x86(IntPtr /*void **/ rop, ref uint /*size_t **/ countp, int order, uint /*size_t*/ size, int endian, uint /*size_t*/ nails, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_export")]
            public static extern IntPtr /*void **/ __mpfrz_export_x64(IntPtr /*void **/ rop, ref ulong /*size_t **/ countp, int order, ulong /*size_t **/ size, int endian, ulong /*size_t **/ nails, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fac_ui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_2fac_ui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_mfac_uiui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ n, uint /*unsigned long int*/ m);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_primorial_ui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fdiv_q(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fdiv_q_2exp(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_fdiv_q_ui(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fdiv_qr(IntPtr /*mpz_t*/ q, IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_fdiv_qr_ui(IntPtr /*mpz_t*/ q, IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fdiv_r(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fdiv_r_2exp(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_fdiv_r_ui(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_fdiv_ui(/*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fib_ui(IntPtr /*mpz_t*/ fn, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_fib2_ui(IntPtr /*mpz_t*/ fn, IntPtr /*mpz_t*/ fnsub1, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_fits_sint_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_fits_slong_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_fits_sshort_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_fits_uint_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_fits_ulong_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_fits_ushort_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_gcd(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_gcd_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_gcdext(IntPtr /*mpz_t*/ g, IntPtr /*mpz_t*/ s, IntPtr /*mpz_t*/ t, /*const*/ IntPtr /*mpz_t*/ a, /*const*/ IntPtr /*mpz_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double __mpfrz_get_d(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double __mpfrz_get_d_2exp(ref int /*long int*/ exp, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*long int*/ __mpfrz_get_si(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern IntPtr /*char **/ __mpfrz_get_str(IntPtr /*char **/ str, int @base, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_get_ui(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_getlimbn")]
            public static extern uint /*mp_limb_t*/ __mpfrz_getlimbn_x86(/*const*/ IntPtr /*mpz_t*/ op, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_getlimbn")]
            public static extern ulong /*mp_limb_t*/ __mpfrz_getlimbn_x64(/*const*/ IntPtr /*mpz_t*/ op, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrz_hamdist(/*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_import")]
            public static extern void __mpfrz_import_x86(IntPtr /*mpz_t*/ rop, uint /*size_t*/ count, int order, uint /*size_t*/ size, int endian, uint /*size_t*/ nails, IntPtr /*void **/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_import")]
            public static extern void __mpfrz_import_x64(IntPtr /*mpz_t*/ rop, ulong /*size_t*/ count, int order, ulong /*size_t*/ size, int endian, ulong /*size_t*/ nails, IntPtr /*void **/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_init(IntPtr /*mpz_t*/ x);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_init2(IntPtr /*mpz_t*/ x, uint /*mp_bitcnt_t*/ n);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrz_inits(IntPtr /*mpz_t*/ x, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_init_set(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_init_set_d(IntPtr /*mpz_t*/ rop, double op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_init_set_si(IntPtr /*mpz_t*/ rop, int /*long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_init_set_str(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr str, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_init_set_ui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_inp_raw")]
            public static extern uint /*size_t*/ __mpfrz_inp_raw_x86(IntPtr /*mpz_t*/ rop, IntPtr /*FILE **/ stream);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_inp_raw")]
            public static extern ulong /*size_t*/ __mpfrz_inp_raw_x64(IntPtr /*mpz_t*/ rop, IntPtr /*FILE **/ stream);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_inp_str")]
            public static extern uint /*size_t*/ __mpfrz_inp_str_x86(IntPtr /*mpz_t*/ rop, IntPtr /*FILE **/ stream, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_inp_str")]
            public static extern ulong /*size_t*/ __mpfrz_inp_str_x64(IntPtr /*mpz_t*/ rop, IntPtr /*FILE **/ stream, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_invert(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_ior(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_jacobi(/*const*/ IntPtr /*mpz_t*/ a, /*const*/ IntPtr /*mpz_t*/ b);

            //#define mpz_kronecker mpz_jacobi  /* alias */

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_kronecker_si(/*const*/ IntPtr /*mpz_t*/ a, int /*long int*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_kronecker_ui(/*const*/ IntPtr /*mpz_t*/ a, uint /*unsigned long int*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_si_kronecker(int /*long int*/ a, /*const*/ IntPtr /*mpz_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_ui_kronecker(uint /*unsigned long int*/ a, /*const*/ IntPtr /*mpz_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_lcm(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_lcm_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_legendre(/*const*/ IntPtr /*mpz_t*/ a, /*const*/ IntPtr /*mpz_t*/ p);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_lucnum_ui(IntPtr /*mpz_t*/ ln, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_lucnum2_ui(IntPtr /*mpz_t*/ ln, IntPtr /*mpz_t*/ lnsub1, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_millerrabin(/*const*/ IntPtr /*mpz_t*/ n, int reps);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_mod(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            //#define mpz_mod_ui mpz_fdiv_r_ui /* same as fdiv_r because divisor unsigned */

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_mul(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_mul_2exp(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*mp_bitcnt_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_mul_si(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, int /*long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_mul_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_neg(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_nextprime(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_out_raw")]
            public static extern uint /*size_t*/ __mpfrz_out_raw_x86(IntPtr /*FILE **/stream, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_out_raw")]
            public static extern ulong /*size_t*/ __mpfrz_out_raw_x64(IntPtr /*FILE **/stream, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_out_str")]
            public static extern uint /*size_t*/ __mpfrz_out_str_x86(IntPtr /*FILE **/stream, int @base, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_out_str")]
            public static extern ulong /*size_t*/ __mpfrz_out_str_x64(IntPtr /*FILE **/stream, int @base, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_perfect_power_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_perfect_square_p(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrz_popcount(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_pow_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ @base, uint /*unsigned long int*/ exp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_powm(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ @base, /*const*/ IntPtr /*mpz_t*/ exp, /*const*/ IntPtr /*mpz_t*/ mod);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_powm_sec(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ @base, /*const*/ IntPtr /*mpz_t*/ exp, /*const*/ IntPtr /*mpz_t*/ mod);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_powm_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ @base, uint /*unsigned long int*/ exp, /*const*/ IntPtr /*mpz_t*/ mod);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_probab_prime_p(/*const*/ IntPtr /*mpz_t*/ n, int reps);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)] // OBSOLETE
            public static extern void __mpfrz_random(IntPtr /*mpz_t*/ rop, int /*mp_size_t*/ max_size);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)] // OBSOLETE
            public static extern void __mpfrz_random2(IntPtr /*mpz_t*/ rop, int /*mp_size_t*/ max_size);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_realloc2(IntPtr /*mpz_t*/ x, uint /*mp_bitcnt_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrz_remove(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op, /*const*/ IntPtr /*mpz_t*/ f);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_root(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_rootrem(IntPtr /*mpz_t*/ root, IntPtr /*mpz_t*/ rem, /*const*/ IntPtr /*mpz_t*/ u, uint /*unsigned long int*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_rrandomb(IntPtr /*mpz_t*/ rop, IntPtr /*mpfr_randstate_t*/ state, uint /*mp_bitcnt_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrz_scan0(/*const*/ IntPtr /*mpz_t*/ op, uint /*mp_bitcnt_t*/ starting_bit);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrz_scan1(/*const*/ IntPtr /*mpz_t*/ op, uint /*mp_bitcnt_t*/ starting_bit);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_set(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_set_d(IntPtr /*mpz_t*/ rop, double op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_set_f(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_set_q(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_set_si(IntPtr /*mpz_t*/ rop, int /*long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_set_str(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*char **/ str, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_set_ui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_setbit(IntPtr /*mpz_t*/ rop, uint /*mp_bitcnt_t*/ bit_index);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrz_size(/*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_sizeinbase")]
            public static extern uint /*size_t*/ __mpfrz_sizeinbase_x86(/*const*/ IntPtr /*mpz_t*/ op, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrz_sizeinbase")]
            public static extern ulong /*size_t*/ __mpfrz_sizeinbase_x64(/*const*/ IntPtr /*mpz_t*/ op, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_sqrt(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_sqrtrem(IntPtr /*mpz_t*/ rop1, IntPtr /*mpz_t*/ rop2, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_sub(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_sub_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_ui_sub(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_submul(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_submul_ui(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_swap(IntPtr /*mpz_t*/ rop1, IntPtr /*mpz_t*/ rop2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_tdiv_ui(/*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_tdiv_q(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_tdiv_q_2exp(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_tdiv_q_ui(IntPtr /*mpz_t*/ q, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_tdiv_qr(IntPtr /*mpz_t*/ q, IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_tdiv_qr_ui(IntPtr /*mpz_t*/ q, IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_tdiv_r(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, /*const*/ IntPtr /*mpz_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_tdiv_r_2exp(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*mp_bitcnt_t*/ b);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrz_tdiv_r_ui(IntPtr /*mpz_t*/ r, /*const*/ IntPtr /*mpz_t*/ n, uint /*unsigned long int*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrz_tstbit(/*const*/ IntPtr /*mpz_t*/ op, uint /*mp_bitcnt_t*/ bit_index);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_ui_pow_ui(IntPtr /*mpz_t*/ rop, uint /*unsigned long int*/ @base, uint /*unsigned long int*/ exp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_urandomb(IntPtr /*mpz_t*/ rop, IntPtr /*mpfr_randstate_t*/ state, uint /*mp_bitcnt_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_urandomm(IntPtr /*mpz_t*/ rop, IntPtr /*mpfr_randstate_t*/ state, /*const*/ IntPtr /*mpz_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_xor(IntPtr /*mpz_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern IntPtr /*mp_limb_t**/ __mpfrz_limbs_read(/*const*/ IntPtr /*mpz_t*/ x);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern IntPtr /*mp_limb_t**/ __mpfrz_limbs_write(/*const*/ IntPtr /*mpz_t*/ x, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern IntPtr /*mp_limb_t**/ __mpfrz_limbs_modify(/*const*/ IntPtr /*mpz_t*/ x, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrz_limbs_finish(/*const*/ IntPtr /*mpz_t*/ x, int /*mp_size_t*/ s);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern /*const*/ IntPtr /*mpz_t*/ __mpfrz_roinit_n(IntPtr /*mpz_t*/ x, /*const*/ IntPtr /*mp_limb_t*/ xp, int /*mp_size_t*/ xs);

#endregion

            #region "Rational (i.e. Q) routines."

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_abs(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_add(IntPtr /*mpq_t*/ sum, /*const*/ IntPtr /*mpq_t*/ addend1, /*const*/ IntPtr /*mpq_t*/ addend2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_canonicalize(IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_clear(IntPtr /*mpq_t*/ x);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrq_clears(IntPtr /*mpq_t*/, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrq_cmp(/*const*/ IntPtr /*mpq_t*/ op1, /*const*/ IntPtr /*mpq_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrq_cmp_si(/*const*/ IntPtr /*mpq_t*/ op1, int /*long int*/ num2, uint /*unsigned long int*/ den2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrq_cmp_ui(/*const*/ IntPtr /*mpq_t*/ op1, uint /*unsigned long int*/ num2, uint /*unsigned long int*/ den2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrq_cmp_z(/*const*/ IntPtr /*mpq_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_div(IntPtr /*mpq_t*/ quotient, /*const*/ IntPtr /*mpq_t*/ dividend, /*const*/ IntPtr /*mpq_t*/ divisor);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_div_2exp(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpq_t*/ op1, uint /*mp_bitcnt_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrq_equal(/*const*/ IntPtr /*mpq_t*/ op1, /*const*/ IntPtr /*mpq_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_get_num(IntPtr /*mpz_t*/ numerator, /*const*/ IntPtr /*mpq_t*/ rational);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_get_den(IntPtr /*mpz_t*/ denominator, /*const*/ IntPtr /*mpq_t*/ rational);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double __mpfrq_get_d(/*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern IntPtr /*char **/ __mpfrq_get_str(IntPtr /*char **/ str, int @base, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_init(IntPtr /*mpq_t*/ x);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrq_inits(IntPtr /*mpq_t*/, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrq_inp_str")]
            public static extern uint /*size_t*/ __mpfrq_inp_str_x86(IntPtr /*mpq_t*/ rop, IntPtr /*FILE **/ stream, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrq_inp_str")]
            public static extern ulong /*size_t*/ __mpfrq_inp_str_x64(IntPtr /*mpq_t*/ rop, IntPtr /*FILE **/ stream, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_inv(IntPtr /*mpq_t*/ inverted_number, /*const*/ IntPtr /*mpq_t*/ number);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_mul(IntPtr /*mpq_t*/ product, /*const*/ IntPtr /*mpq_t*/ multiplier, /*const*/ IntPtr /*mpq_t*/ multiplicand);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_mul_2exp(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpq_t*/ op1, uint /*mp_bitcnt_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_neg(IntPtr /*mpq_t*/ negated_operand, /*const*/ IntPtr /*mpq_t*/ operand);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrq_out_str")]
            public static extern uint /*size_t*/ __mpfrq_out_str_x86(IntPtr /*FILE **/ stream, int @base, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrq_out_str")]
            public static extern ulong /*size_t*/ __mpfrq_out_str_x64(IntPtr /*FILE **/ stream, int @base, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_d(IntPtr /*mpq_t*/ rop, double op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_den(IntPtr /*mpq_t*/ rational, /*const*/ IntPtr /*mpz_t*/ denominator);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_f(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_num(IntPtr /*mpq_t*/ rational, /*const*/ IntPtr /*mpz_t*/ numerator);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_si(IntPtr /*mpq_t*/ rop, int /*long int*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrq_set_str(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*char **/ str, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_ui(IntPtr /*mpq_t*/ rop, uint /*unsigned long int*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_set_z(IntPtr /*mpq_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_sub(IntPtr /*mpq_t*/ difference, /*const*/ IntPtr /*mpq_t*/ minuend, /*const*/ IntPtr /*mpq_t*/ subtrahend);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrq_swap(IntPtr /*mpq_t*/ rop1, IntPtr /*mpq_t*/ rop2);

#endregion

            #region "Float (i.e. F) routines."

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_abs(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_add(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_add_ui(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_ceil(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_clear(IntPtr /*mpf_t*/ x);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrf_clears(IntPtr /*mpf_t*/, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_cmp(/*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_cmp_z(/*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpz_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_cmp_d(/*const*/ IntPtr /*mpf_t*/ op1, double op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_cmp_si(/*const*/ IntPtr /*mpf_t*/ op1, int /*long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_cmp_ui(/*const*/ IntPtr /*mpf_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_div(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_div_2exp(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*mp_bitcnt_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_div_ui(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*unsigned long int*/ op2);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrf_dump(/*const*/ IntPtr /*mpf_t*/ op);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern int __mpfrf_eq(/*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2, uint /*mp_bitcnt_t*/ op3);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_fits_sint_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_fits_slong_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_fits_sshort_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_fits_uint_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_fits_ulong_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_fits_ushort_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_floor(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double __mpfrf_get_d(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern double __mpfrf_get_d_2exp(ref int /*long int **/ exp, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrf_get_default_prec(/*void*/);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrf_get_prec(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*long int*/ __mpfrf_get_si(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_get_str")]
            public static extern IntPtr /*char **/ __mpfrf_get_str_x86(IntPtr /*char **/ str, ref int /*mp_exp_t **/ expptr, int @base, uint /*size_t*/ n_digits, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_get_str")]
            public static extern IntPtr /*char **/ __mpfrf_get_str_x64(IntPtr /*char **/ str, ref int /*mp_exp_t **/ expptr, int @base, ulong /*size_t*/ n_digits, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*unsigned long int*/ __mpfrf_get_ui(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_init(IntPtr /*mpf_t*/ x);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_init2(IntPtr /*mpf_t*/ x, uint /*mp_bitcnt_t*/ prec);

            //[DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            //public static extern void __mpfrf_inits(IntPtr /*mpf_t*/, ...);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_init_set(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_init_set_d(IntPtr /*mpf_t*/ rop, double op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_init_set_si(IntPtr /*mpf_t*/ rop, int /*long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_init_set_str(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*char **/ str, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_init_set_ui(IntPtr /*mpf_t*/ rop, uint /*unsigned long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_inp_str")]
            public static extern uint /*size_t*/ __mpfrf_inp_str_x86(IntPtr /*mpf_t*/ rop, IntPtr /*FILE **/ stream, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_inp_str")]
            public static extern ulong /*size_t*/ __mpfrf_inp_str_x64(IntPtr /*mpf_t*/ rop, IntPtr /*FILE **/ stream, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_integer_p(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_mul(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_mul_2exp(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*mp_bitcnt_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_mul_ui(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_neg(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_out_str")]
            public static extern uint /*size_t*/ __mpfrf_out_str_x86(IntPtr /*FILE **/ stream, int @base, uint /*size_t*/ n_digits, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_out_str")]
            public static extern ulong /*size_t*/ __mpfrf_out_str_x64(IntPtr /*FILE **/ stream, int @base, ulong /*size_t*/ n_digits, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_pow_ui(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_random2(IntPtr /*mpf_t*/ rop, int /*mp_size_t*/ max_size, int /*mp_exp_t*/ exp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_reldiff(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_d(IntPtr /*mpf_t*/ rop, double op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_default_prec(uint /*mp_bitcnt_t*/ prec);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_prec(IntPtr /*mpf_t*/ rop, uint /*mp_bitcnt_t*/ prec);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_prec_raw(IntPtr /*mpf_t*/ rop, uint /*mp_bitcnt_t*/ prec);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_q(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpq_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_si(IntPtr /*mpf_t*/ rop, int /*long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrf_set_str(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*char **/ str, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_ui(IntPtr /*mpf_t*/ rop, uint /*unsigned long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_set_z(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpz_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_size")]
            public static extern uint /*size_t*/ __mpfrf_size_x86(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrf_size")]
            public static extern ulong /*size_t*/ __mpfrf_size_x64(/*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_sqrt(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_sqrt_ui(IntPtr /*mpf_t*/ rop, uint /*unsigned long int*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_sub(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_sub_ui(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op1, uint /*unsigned long int*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_swap(IntPtr /*mpf_t*/ rop1, IntPtr /*mpf_t*/ rop2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_trunc(IntPtr /*mpf_t*/ rop, /*const*/ IntPtr /*mpf_t*/ op);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_ui_div(IntPtr /*mpf_t*/ rop, uint /*unsigned long int*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_ui_sub(IntPtr /*mpf_t*/ rop, uint /*unsigned long int*/ op1, /*const*/ IntPtr /*mpf_t*/ op2);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrf_urandomb(IntPtr /*mpf_t*/ rop, IntPtr /*mpfr_randstate_t*/ state, uint /*mp_bitcnt_t*/ nbits);

#endregion

            #region "Low level positive-integer (i.e. N) routines."

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_add")]
            public static extern uint /*mp_limb_t*/ __mpfrn_add_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_add")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_add_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_add_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_add_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, uint /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_add_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_add_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_add_n")]
            public static extern uint /*mp_limb_t*/ __mpfrn_add_n_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_add_n")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_add_n_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_addmul_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_addmul_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, uint /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_addmul_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_addmul_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrn_cmp(/*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrn_zero_p(/*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divexact_1")]
            public static extern void __mpfrn_divexact_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, uint /*mp_limb_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divexact_1")]
            public static extern void __mpfrn_divexact_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ d);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divexact_by3")]
            public static extern uint /*mp_limb_t*/ __mpfrn_divexact_by3_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divexact_by3")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_divexact_by3_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divexact_by3c")]
            public static extern uint /*mp_limb_t*/ __mpfrn_divexact_by3c_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, uint /*mp_limb_t*/ carry);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divexact_by3c")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_divexact_by3c_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ carry);

            //obsolete
            //#define mpn_divrem __MPN(divrem)
            //public static extern mp_limb_t __mpfrn_divrem(IntPtr /*mp_ptr*/, int /*mp_size_t*/, IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divrem_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_divrem_1_x86(IntPtr /*mp_ptr*/ r1p, int /*mp_size_t*/ qxn, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n, uint /*mp_limb_t*/ s3limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_divrem_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_divrem_1_x64(IntPtr /*mp_ptr*/ r1p, int /*mp_size_t*/ qxn, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n, ulong /*mp_limb_t*/ s3limb);

            //obsolete
            //#define mpn_divrem_2 __MPN(divrem_2)
            //public static extern mp_limb_t __mpfrn_divrem_2(IntPtr /*mp_ptr*/, int /*mp_size_t*/, IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/);

            //#define mpn_div_qr_1 __MPN(div_qr_1)
            //public static extern mp_limb_t __mpfrn_div_qr_1(IntPtr /*mp_ptr*/, mp_limb_t*, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t);

            //#define mpn_div_qr_2 __MPN(div_qr_2)
            //public static extern mp_limb_t __mpfrn_div_qr_2(IntPtr /*mp_ptr*/, IntPtr /*mp_ptr*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, /*const*/ IntPtr /*mp_ptr*/);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_gcd(IntPtr /*mp_ptr*/ rp, IntPtr /*mp_ptr*/ xp, int /*mp_size_t*/ xn, IntPtr /*mp_ptr*/ yp, int /*mp_size_t*/ yn);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_gcd_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_gcd_1_x86(/*const*/ IntPtr /*mp_ptr*/ xp, int /*mp_size_t*/ xn, uint /*mp_limb_t*/ ylimb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_gcd_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_gcd_1_x64(/*const*/ IntPtr /*mp_ptr*/ xp, int /*mp_size_t*/ xn, ulong /*mp_limb_t*/ ylimb);

            //#define mpn_gcdext_1 __MPN(gcdext_1)
            //public static extern mp_limb_t __mpfrn_gcdext_1(mp_limb_signed_t*, mp_limb_signed_t*, mp_limb_t, mp_limb_t);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_gcdext(IntPtr /*mp_ptr*/ gp, IntPtr /*mp_ptr*/ sp, ref int /*mp_size_t**/ sn, IntPtr /*mp_ptr*/ up, int /*mp_size_t*/ un, IntPtr /*mp_ptr*/ vp, int /*mp_size_t*/ vn);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_get_str")]
            public static extern uint /*size_t*/ __mpfrn_get_str_x86(IntPtr /*unsigned char **/ str, int @base, IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_get_str")]
            public static extern ulong /*size_t*/ __mpfrn_get_str_x64(IntPtr /*unsigned char **/ str, int @base, IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrn_hamdist(/*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_lshift")]
            public static extern uint /*mp_limb_t*/ __mpfrn_lshift_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, uint count);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_lshift")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_lshift_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, uint count);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_mod_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_mod_1_x86(/*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, uint /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_mod_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_mod_1_x64(/*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, ulong /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_mul")]
            public static extern uint /*mp_limb_t*/ __mpfrn_mul_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_mul")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_mul_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_mul_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_mul_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, uint /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_mul_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_mul_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_mul_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_sqr(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_neg")]
            public static extern uint /*mp_limb_t*/ __mpfrn_neg_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_neg")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_neg_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_com(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrn_perfect_square_p(/*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrn_perfect_power_p(/*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrn_popcount(/*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n);

            //#define mpn_pow_1 __MPN(pow_1)
            //public static extern int /*mp_size_t*/ __mpfrn_pow_1(IntPtr /*mp_ptr*/, /*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t, IntPtr /*mp_ptr*/);

            ///* undocumented now, but retained here for upward compatibility */
            //#define mpn_preinv_mod_1 __MPN(preinv_mod_1)
            //public static extern mp_limb_t __mpfrn_preinv_mod_1(/*const*/ IntPtr /*mp_ptr*/, int /*mp_size_t*/, mp_limb_t, mp_limb_t);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_random(IntPtr /*mp_ptr*/ r1p, int /*mp_size_t*/ r1n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_random2(IntPtr /*mp_ptr*/ r1p, int /*mp_size_t*/ r1n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_rshift")]
            public static extern uint /*mp_limb_t*/ __mpfrn_rshift_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, uint count);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_rshift")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_rshift_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n, uint count);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrn_scan0(/*const*/ IntPtr /*mp_ptr*/ s1p, uint /*mp_bitcnt_t*/ bit);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern uint /*mp_bitcnt_t*/ __mpfrn_scan1(/*const*/ IntPtr /*mp_ptr*/ s1p, uint /*mp_bitcnt_t*/ bit);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_set_str")]
            public static extern int /*mp_size_t*/ __mpfrn_set_str_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*unsigned char **/ str, uint /*size_t*/ strsize, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_set_str")]
            public static extern int /*mp_size_t*/ __mpfrn_set_str_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*unsigned char **/ str, ulong /*size_t*/ strsize, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sizeinbase")]
            public static extern uint /*size_t*/ __mpfrn_sizeinbase_x86(/*const*/ IntPtr /*mp_ptr*/ xp, int /*mp_size_t*/ n, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sizeinbase")]
            public static extern ulong /*size_t*/ __mpfrn_sizeinbase_x64(/*const*/ IntPtr /*mp_ptr*/ xp, int /*mp_size_t*/ n, int @base);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sqrtrem(IntPtr /*mp_ptr*/ r1p, IntPtr /*mp_ptr*/ r2p, /*const*/ IntPtr /*mp_ptr*/ sp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sub")]
            public static extern uint /*mp_limb_t*/ __mpfrn_sub_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sub")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_sub_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ s1n, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ s2n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sub_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_sub_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, uint /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sub_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_sub_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sub_n")]
            public static extern uint /*mp_limb_t*/ __mpfrn_sub_n_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sub_n")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_sub_n_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_submul_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_submul_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, uint /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_submul_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_submul_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ s2limb);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_tdiv_qr(IntPtr /*mp_ptr*/ qp, IntPtr /*mp_ptr*/ rp, int /*mp_size_t*/ qxn, /*const*/ IntPtr /*mp_ptr*/ np, int /*mp_size_t*/ nn, /*const*/ IntPtr /*mp_ptr*/ dp, int /*mp_size_t*/ dn);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_and_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_andn_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_nand_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_ior_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_iorn_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_nior_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_xor_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_xnor_n(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_copyi(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_copyd(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_zero(IntPtr /*mp_ptr*/ rp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_cnd_add_n")]
            public static extern uint /*mp_limb_t*/ __mpfrn_cnd_add_n_x86(uint /*mp_limb_t*/ cnd, IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_cnd_add_n")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_cnd_add_n_x64(ulong /*mp_limb_t*/ cnd, IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_cnd_sub_n")]
            public static extern uint /*mp_limb_t*/ __mpfrn_cnd_sub_n_x86(uint /*mp_limb_t*/ cnd, IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_cnd_sub_n")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_cnd_sub_n_x64(ulong /*mp_limb_t*/ cnd, IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ s1p, /*const*/ IntPtr /*mp_ptr*/ s2p, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sec_add_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_sec_add_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ ap, int /*mp_size_t*/ n, uint /*mp_limb_t*/ b, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sec_add_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_sec_add_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ ap, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ b, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_add_1_itch(int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sec_sub_1")]
            public static extern uint /*mp_limb_t*/ __mpfrn_sec_sub_1_x86(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ ap, int /*mp_size_t*/ n, uint /*mp_limb_t*/ b, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sec_sub_1")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_sec_sub_1_x64(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ ap, int /*mp_size_t*/ n, ulong /*mp_limb_t*/ b, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_sub_1_itch(int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_cnd_swap")]
            public static extern void __mpfrn_cnd_swap_x86(uint /*mp_limb_t*/ cnd, /*volatile*/ IntPtr /*mp_limb_t**/ ap, /*volatile*/ IntPtr /*mp_limb_t**/ bp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_cnd_swap")]
            public static extern void __mpfrn_cnd_swap_x64(ulong /*mp_limb_t*/ cnd, /*volatile*/ IntPtr /*mp_limb_t**/ ap, /*volatile*/ IntPtr /*mp_limb_t**/ bp, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_sec_mul(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ ap, int /*mp_size_t*/ an, /*const*/ IntPtr /*mp_ptr*/ b, int /*mp_size_t*/ bn, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_mul_itch(int /*mp_size_t*/ an, int /*mp_size_t*/ bn);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_sec_sqr(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ ap, int /*mp_size_t*/ an, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_sqr_itch(int /*mp_size_t*/ an);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_sec_powm(IntPtr /*mp_ptr*/ rp, /*const*/ IntPtr /*mp_ptr*/ bp, int /*mp_size_t*/ bn, /*const*/ IntPtr /*mp_ptr*/ ep, uint /*mp_bitcnt_t*/ enb, /*const*/ IntPtr /*mp_ptr*/ mp, int /*mp_size_t*/ n, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_powm_itch(int /*mp_size_t*/ bn, uint /*mp_bitcnt_t*/ enb, int /*mp_size_t*/ n);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_sec_tabselect(/*volatile*/ IntPtr /*mp_limb_t**/ rp, /*volatile const*/ IntPtr /*mp_limb_t**/ tab, int /*mp_size_t*/ n, int /*mp_size_t*/ nents, int /*mp_size_t*/ which);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sec_div_qr")]
            public static extern uint /*mp_limb_t*/ __mpfrn_sec_div_qr_x86(IntPtr /*mp_ptr*/ qp, IntPtr /*mp_ptr*/ np, int /*mp_size_t*/ nn, /*const*/ IntPtr /*mp_ptr*/ dp, int /*mp_size_t*/ dn, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "__mpfrn_sec_div_qr")]
            public static extern ulong /*mp_limb_t*/ __mpfrn_sec_div_qr_x64(IntPtr /*mp_ptr*/ qp, IntPtr /*mp_ptr*/ np, int /*mp_size_t*/ nn, /*const*/ IntPtr /*mp_ptr*/ dp, int /*mp_size_t*/ dn, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_div_qr_itch(int /*mp_size_t*/ nn, int /*mp_size_t*/ dn);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern void __mpfrn_sec_div_r(IntPtr /*mp_ptr*/ np, int /*mp_size_t*/ nn, /*const*/ IntPtr /*mp_ptr*/ dp, int /*mp_size_t*/ dn, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_div_r_itch(int /*mp_size_t*/ nn, int /*mp_size_t*/ dn);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int __mpfrn_sec_invert(IntPtr /*mp_ptr*/ rp, IntPtr /*mp_ptr*/ ap, /*const*/ IntPtr /*mp_ptr*/ mp, int /*mp_size_t*/ n, uint /*mp_bitcnt_t*/ nbcnt, IntPtr /*mp_ptr*/ tp);

            [DllImport(@"libmpfr-4.dll", CallingConvention = CallingConvention.Cdecl)]
            public static extern int /*mp_size_t*/ __mpfrn_sec_invert_itch(int /*mp_size_t*/ n);

            #endregion

            /*
            public static extern __gmp_const char * mpfr_get_version(void);
            public static extern __gmp_const char * mpfr_get_patches(void);
            public static extern int mpfr_buildopt_tls_p(void);
            public static extern int mpfr_buildopt_decimal_p(void);
            public static extern int mpfr_buildopt_gmpinternals_p(void);
            public static extern __gmp_const char * mpfr_buildopt_tune_case(void);

            public static extern mpfr_exp_t mpfr_get_emin(void);
            public static extern int        mpfr_set_emin(mpfr_exp_t);
            public static extern mpfr_exp_t mpfr_get_emin_min(void);
            public static extern mpfr_exp_t mpfr_get_emin_max(void);
            public static extern mpfr_exp_t mpfr_get_emax(void);
            public static extern int        mpfr_set_emax(mpfr_exp_t);
            public static extern mpfr_exp_t mpfr_get_emax_min(void);
            public static extern mpfr_exp_t mpfr_get_emax_max(void);

            public static extern void mpfr_set_default_rounding_mode(mpfr_rnd_t);
            public static extern mpfr_rnd_t mpfr_get_default_rounding_mode(void);
            public static extern __gmp_const char * mpfr_print_rnd_mode(mpfr_rnd_t);

            public static extern void mpfr_clear_flags(void);
            public static extern void mpfr_clear_underflow(void);
            public static extern void mpfr_clear_overflow(void);
            public static extern void mpfr_clear_divby0(void);
            public static extern void mpfr_clear_nanflag(void);
            public static extern void mpfr_clear_inexflag(void);
            public static extern void mpfr_clear_erangeflag(void);

            public static extern void mpfr_set_underflow(void);
            public static extern void mpfr_set_overflow(void);
            public static extern void mpfr_set_divby0(void);
            public static extern void mpfr_set_nanflag(void);
            public static extern void mpfr_set_inexflag(void);
            public static extern void mpfr_set_erangeflag(void);

            public static extern int mpfr_underflow_p(void);
            public static extern int mpfr_overflow_p(void);
            public static extern int mpfr_divby0_p(void);
            public static extern int mpfr_nanflag_p(void);
            public static extern int mpfr_inexflag_p(void);
            public static extern int mpfr_erangeflag_p(void);

            public static extern int mpfr_check_range(mpfr_ptr, int, mpfr_rnd_t);

            public static extern void mpfr_init2(mpfr_ptr, mpfr_prec_t);
            public static extern void mpfr_init(mpfr_ptr);
            public static extern void mpfr_clear(mpfr_ptr);

            public static extern void mpfr_inits2(mpfr_prec_t, mpfr_ptr, ...) __MPFR_SENTINEL_ATTR;
            public static extern void mpfr_inits(mpfr_ptr, ...) __MPFR_SENTINEL_ATTR;
            public static extern void mpfr_clears(mpfr_ptr, ...) __MPFR_SENTINEL_ATTR;

            public static extern int mpfr_prec_round(mpfr_ptr, mpfr_prec_t, mpfr_rnd_t);
            public static extern int mpfr_can_round(mpfr_srcptr, mpfr_exp_t, mpfr_rnd_t, mpfr_rnd_t, mpfr_prec_t);
            public static extern mpfr_prec_t mpfr_min_prec(mpfr_srcptr);

            public static extern mpfr_exp_t mpfr_get_exp(mpfr_srcptr);
            public static extern int mpfr_set_exp(mpfr_ptr, mpfr_exp_t);
            public static extern mpfr_prec_t mpfr_get_prec(mpfr_srcptr);
            public static extern void mpfr_set_prec(mpfr_ptr, mpfr_prec_t);
            public static extern void mpfr_set_prec_raw(mpfr_ptr, mpfr_prec_t);
            public static extern void mpfr_set_default_prec(mpfr_prec_t);
            public static extern mpfr_prec_t mpfr_get_default_prec(void);

            public static extern int mpfr_set_d(mpfr_ptr, double, mpfr_rnd_t);
            public static extern int mpfr_set_flt(mpfr_ptr, float, mpfr_rnd_t);
            #ifdef MPFR_WANT_DECIMAL_FLOATS
            public static extern int mpfr_set_decimal64(mpfr_ptr, _Decimal64, mpfr_rnd_t);
            #endif
            public static extern int mpfr_set_ld(mpfr_ptr, long double, mpfr_rnd_t);
            public static extern int mpfr_set_z(mpfr_ptr, mpz_srcptr, mpfr_rnd_t);
            public static extern int mpfr_set_z_2exp(mpfr_ptr, mpz_srcptr, mpfr_exp_t, mpfr_rnd_t);
            public static extern void mpfr_set_nan(mpfr_ptr);
            public static extern void mpfr_set_inf(mpfr_ptr, int);
            public static extern void mpfr_set_zero(mpfr_ptr, int);
            public static extern int mpfr_set_f(mpfr_ptr, mpf_srcptr, mpfr_rnd_t);
            public static extern int mpfr_get_f(mpf_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_set_si(mpfr_ptr, long, mpfr_rnd_t);
            public static extern int mpfr_set_ui(mpfr_ptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_set_si_2exp(mpfr_ptr, long, mpfr_exp_t, mpfr_rnd_t);
            public static extern int mpfr_set_ui_2exp(mpfr_ptr,unsigned long,mpfr_exp_t,mpfr_rnd_t);
            public static extern int mpfr_set_q(mpfr_ptr, mpq_srcptr, mpfr_rnd_t);
            public static extern int mpfr_set_str(mpfr_ptr, __gmp_const char *, int, mpfr_rnd_t);
            public static extern int mpfr_init_set_str(mpfr_ptr, __gmp_const char *, int, mpfr_rnd_t);
            public static extern int mpfr_set4(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t, int);
            public static extern int mpfr_abs(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_set(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_neg(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_signbit(mpfr_srcptr);
            public static extern int mpfr_setsign(mpfr_ptr, mpfr_srcptr, int, mpfr_rnd_t);
            public static extern int mpfr_copysign(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern mpfr_exp_t mpfr_get_z_2exp(mpz_ptr, mpfr_srcptr);
            public static extern float mpfr_get_flt(mpfr_srcptr, mpfr_rnd_t);
            public static extern double mpfr_get_d(mpfr_srcptr, mpfr_rnd_t);
            #ifdef MPFR_WANT_DECIMAL_FLOATS
            public static extern _Decimal64 mpfr_get_decimal64(mpfr_srcptr, mpfr_rnd_t);
            #endif
            public static extern long double mpfr_get_ld(mpfr_srcptr, mpfr_rnd_t);
            public static extern double mpfr_get_d1(mpfr_srcptr);
            public static extern double mpfr_get_d_2exp(long*, mpfr_srcptr, mpfr_rnd_t);
            public static extern long double mpfr_get_ld_2exp(long*, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_frexp(mpfr_exp_t*, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern long mpfr_get_si(mpfr_srcptr, mpfr_rnd_t);
            public static extern unsigned long mpfr_get_ui(mpfr_srcptr, mpfr_rnd_t);
            public static extern char*mpfr_get_str(char*, mpfr_exp_t*, int, size_t, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_get_z(mpz_ptr z, mpfr_srcptr f, mpfr_rnd_t);

            public static extern void mpfr_free_str(char *);

            public static extern int mpfr_urandom(mpfr_ptr, gmp_randstate_t, mpfr_rnd_t);
            public static extern int mpfr_grandom(mpfr_ptr, mpfr_ptr, gmp_randstate_t, mpfr_rnd_t);
            public static extern int mpfr_urandomb(mpfr_ptr, gmp_randstate_t);

            public static extern void mpfr_nextabove(mpfr_ptr);
            public static extern void mpfr_nextbelow(mpfr_ptr);
            public static extern void mpfr_nexttoward(mpfr_ptr, mpfr_srcptr);

            public static extern int mpfr_printf(__gmp_const char*, ...);
            public static extern int mpfr_asprintf(char**, __gmp_const char*, ...);
            public static extern int mpfr_sprintf(char*, __gmp_const char*, ...);
            public static extern int mpfr_snprintf(char*, size_t, __gmp_const char*, ...);

            public static extern int mpfr_pow(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_pow_si(mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t);
            public static extern int mpfr_pow_ui(mpfr_ptr, mpfr_srcptr, unsigned long int, mpfr_rnd_t);
            public static extern int mpfr_ui_pow_ui(mpfr_ptr, unsigned long int, unsigned long int, mpfr_rnd_t);
            public static extern int mpfr_ui_pow(mpfr_ptr, unsigned long int, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_pow_z(mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t);

            public static extern int mpfr_sqrt(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sqrt_ui(mpfr_ptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_rec_sqrt(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_add(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sub(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_mul(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_div(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_add_ui(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_sub_ui(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_ui_sub(mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_mul_ui(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_div_ui(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_ui_div(mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_add_si(mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t);
            public static extern int mpfr_sub_si(mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t);
            public static extern int mpfr_si_sub(mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_mul_si(mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t);
            public static extern int mpfr_div_si(mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t);
            public static extern int mpfr_si_div(mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_add_d(mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t);
            public static extern int mpfr_sub_d(mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t);
            public static extern int mpfr_d_sub(mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_mul_d(mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t);
            public static extern int mpfr_div_d(mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t);
            public static extern int mpfr_d_div(mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_sqr(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

            public static extern int mpfr_const_pi(mpfr_ptr, mpfr_rnd_t);
            public static extern int mpfr_const_log2(mpfr_ptr, mpfr_rnd_t);
            public static extern int mpfr_const_euler(mpfr_ptr, mpfr_rnd_t);
            public static extern int mpfr_const_catalan(mpfr_ptr, mpfr_rnd_t);

            public static extern int mpfr_agm(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_log(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_log2(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_log10(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_log1p(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_exp(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_exp2(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_exp10(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_expm1(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_eint(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_li2(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);

            public static extern int mpfr_cmp(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_cmp3(mpfr_srcptr, mpfr_srcptr, int);
            public static extern int mpfr_cmp_d(mpfr_srcptr, double);
            public static extern int mpfr_cmp_ld(mpfr_srcptr, long double);
            public static extern int mpfr_cmpabs(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_cmp_ui(mpfr_srcptr, unsigned long);
            public static extern int mpfr_cmp_si(mpfr_srcptr, long);
            public static extern int mpfr_cmp_ui_2exp(mpfr_srcptr, unsigned long, mpfr_exp_t);
            public static extern int mpfr_cmp_si_2exp(mpfr_srcptr, long, mpfr_exp_t);
            public static extern void mpfr_reldiff(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_eq(mpfr_srcptr, mpfr_srcptr, unsigned long);
            public static extern int mpfr_sgn(mpfr_srcptr);

            public static extern int mpfr_mul_2exp(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_div_2exp(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_mul_2ui(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_div_2ui(mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t);
            public static extern int mpfr_mul_2si(mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t);
            public static extern int mpfr_div_2si(mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t);

            public static extern int mpfr_rint(mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_round(mpfr_ptr, mpfr_srcptr);
            public static extern int mpfr_trunc(mpfr_ptr, mpfr_srcptr);
            public static extern int mpfr_ceil(mpfr_ptr, mpfr_srcptr);
            public static extern int mpfr_floor(mpfr_ptr, mpfr_srcptr);
            public static extern int mpfr_rint_round(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_rint_trunc(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_rint_ceil(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_rint_floor(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_frac(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_modf(mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_remquo(mpfr_ptr, long*, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_remainder(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fmod(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_fits_ulong_p(mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fits_slong_p(mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fits_uint_p(mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fits_sint_p(mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fits_ushort_p(mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fits_sshort_p(mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fits_uintmax_p(mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_fits_intmax_p(mpfr_srcptr, mpfr_rnd_t);

            public static extern void mpfr_extract(mpz_ptr, mpfr_srcptr, unsigned int);
            public static extern void mpfr_swap(mpfr_ptr, mpfr_ptr);
            public static extern void mpfr_dump(mpfr_srcptr);

            public static extern int mpfr_nan_p(mpfr_srcptr);
            public static extern int mpfr_inf_p(mpfr_srcptr);
            public static extern int mpfr_number_p(mpfr_srcptr);
            public static extern int mpfr_integer_p(mpfr_srcptr);
            public static extern int mpfr_zero_p(mpfr_srcptr);
            public static extern int mpfr_regular_p(mpfr_srcptr);

            public static extern int mpfr_greater_p(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_greaterequal_p(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_less_p(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_lessequal_p(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_lessgreater_p(mpfr_srcptr,mpfr_srcptr);
            public static extern int mpfr_equal_p(mpfr_srcptr, mpfr_srcptr);
            public static extern int mpfr_unordered_p(mpfr_srcptr, mpfr_srcptr);

            public static extern int mpfr_atanh(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_acosh(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_asinh(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_cosh(mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sinh(mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_tanh(mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sinh_cosh(mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_sech(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_csch(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_coth(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

            public static extern int mpfr_acos(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_asin(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_atan(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_sin(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_sin_cos(mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_cos(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_tan(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_atan2(mpfr_ptr,mpfr_srcptr,mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sec(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_csc(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_cot(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

            public static extern int mpfr_hypot(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_erf(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_erfc(mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_cbrt(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_root(mpfr_ptr,mpfr_srcptr,unsigned long,mpfr_rnd_t);
            public static extern int mpfr_gamma(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_lngamma(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_lgamma(mpfr_ptr,int*,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_digamma(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_zeta(mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
            public static extern int mpfr_zeta_ui(mpfr_ptr,unsigned long,mpfr_rnd_t);
            public static extern int mpfr_fac_ui(mpfr_ptr, unsigned long int, mpfr_rnd_t);
            public static extern int mpfr_j0(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_j1(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_jn(mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_y0(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_y1(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_yn(mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_ai(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_min(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_max(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_dim(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);

            public static extern int mpfr_mul_z(mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t);
            public static extern int mpfr_div_z(mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t);
            public static extern int mpfr_add_z(mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sub_z(mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t);
            public static extern int mpfr_z_sub(mpfr_ptr, mpz_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_cmp_z(mpfr_srcptr, mpz_srcptr);

            public static extern int mpfr_mul_q(mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t);
            public static extern int mpfr_div_q(mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t);
            public static extern int mpfr_add_q(mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sub_q(mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t);
            public static extern int mpfr_cmp_q(mpfr_srcptr, mpq_srcptr);

            public static extern int mpfr_cmp_f(mpfr_srcptr, mpf_srcptr);

            public static extern int mpfr_fma(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_fms(mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
            public static extern int mpfr_sum(mpfr_ptr, mpfr_ptr *__gmp_const, unsigned long, mpfr_rnd_t);

            public static extern void mpfr_free_cache(void);

            public static extern int  mpfr_subnormalize(mpfr_ptr, int, mpfr_rnd_t);

            public static extern int  mpfr_strtofr(mpfr_ptr, __gmp_const char *, char **, int, mpfr_rnd_t);

            public static extern size_t mpfr_custom_get_size(mpfr_prec_t);
            public static extern void   mpfr_custom_init(void *, mpfr_prec_t);
            public static extern void * mpfr_custom_get_significand(mpfr_srcptr);
            public static extern mpfr_exp_t mpfr_custom_get_exp(mpfr_srcptr);
            public static extern void   mpfr_custom_move(mpfr_ptr, void *);
            public static extern void   mpfr_custom_init_set(mpfr_ptr, int, mpfr_exp_t, mpfr_prec_t, void *);
            public static extern int    mpfr_custom_get_kind(mpfr_srcptr);
            */

        }

        private class SafeHandle : SafeHandleZeroOrMinusOneIsInvalid
        {
            public SafeHandle(IntPtr handle)
                : base(true)
            {
                SetHandle(handle);
            }

            public IntPtr Handle
            {
                get
                {
                    return handle;
                }
            }

            [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
            protected override bool ReleaseHandle()
            {
                mpfr_lib.SafeNativeMethods.FreeLibrary(handle);
                return true;
            }
        }

    }
}
